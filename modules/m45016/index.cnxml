<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>GAME 2302-0135: Venturing into a 3D World</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m45016</md:content-id>
  <md:title>GAME 2302-0135: Venturing into a 3D World</md:title>
  <md:abstract>Learn how to update the game-math library to support 3D math, how to program the equations for projecting a 3D world onto a 2D plane, and how to add vectors in 3D. Also learn about scaling, translation, and rotation of a point in both 2D and 3D, about the rotation equations and how to implement them in both 2D and 3D, and much more.</md:abstract>
  <md:uuid>094b4370-4fc4-46bd-a98e-8e9782f3ac03</md:uuid>
</metadata>

<content>
















<section id="h11000">
<title>
Table of Contents

</title>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" target-id="Preface">

Preface

</link>


	

<list id="ul1001" list-type="bulleted">

		

<item id="li1001">
<link id="a1001" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1002" list-type="bulleted">

			

<item id="li1002">
<link id="a1002" target-id="Figures">

Figures

</link>


</item>


			

<item id="li1003">
<link id="a1003" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>


	

<item id="li1004">
<link id="a1004" target-id="Preview_of_coming_attractions">

Preview of coming attractions

</link>


</item>


	

<item id="li1005">
<link id="a1005" target-id="Preview">

Preview of this module

</link>

 

</item>


	

<item id="li1006">
<link id="a1006" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


<list id="ul1003" list-type="bulleted">

		

<item id="li1007">
<link id="a1007" target-id="The_game-math_library_named_GM01">

The game-math library named GM01

</link>




</item>


		

<item id="li1008">
<link id="a1008" target-id="The_program_namedGM01test02">

The program named GM01test02

</link>




</item>


		

<item id="li1009">
<link id="a1009" target-id="The_program_named_GM01test01">

The program named GM01test01

</link>


		

<list id="ul1004" list-type="bulleted">

			

<item id="li1010">
<link id="a1010" target-id="The_method_named_GM01.Point3D.draw">

The method named GM01.Point3D.draw
			

</link>




</item>


			

<item id="li1011">
<link id="a1011" target-id="The_method_named_GM01.Vector3D.draw_">

The method named GM01.Vector3D.draw

</link>




</item>


			

<item id="li1012">
<link id="a1012" target-id="The_method_named_GM01.Line3D.draw">

The method named GM01.Line3D.draw

</link>




</item>


		

</list>


		

</item>


		

<item id="li1013">
<link id="a1013" target-id="The_program_named_GM01test05_">

The program named GM01test05

</link>




</item>


		

<item id="li1014">
<link id="a1014" target-id="The_program_named_GM01test06">

The program named GM01test06

</link>




</item>


		

<item id="li1015">
<link id="a1015" target-id="The_program_named_StringArt02_">

The program named  StringArt02

</link>




</item>


		

<item id="li1016">
<link id="a1016" target-id="The_program_named_StringArt03_">

The program named StringArt03

</link>


</item>


	

</list>


	

</item>


	

<item id="li1017">
<link id="a1017" target-id="Documentation_for_the_GM01_library">

Documentation for the GM01 library

</link>


</item>


	

<item id="li1018">
<link id="a1018" target-id="Homework_assignment">

Homework assignment

</link>


</item>


	

<item id="li1019">
<link id="a1019" target-id="Run_the_program">

Run the programs

</link>


</item>


	

<item id="li1020">
<link id="a1020" target-id="Summary">

Summary

</link>

 

</item>


	

<item id="li1021">
<link id="a1021" target-id="Whats_next">

What's next?

</link>


</item>


	

<item id="li1022">
<link id="a1022" target-id="Miscellaneous">

Miscellaneous

</link>


</item>


	

<item id="li1023">
<link id="a1023" target-id="Complete_program_listing">

Complete program listings

</link>


</item>


	

<item id="li1024">
<link id="a1024" target-id="Exercises">

Exercises

</link>


<list id="ul1005" list-type="bulleted">

		

<item id="li1025">
<link id="a1025" target-id="Exercise_1">

Exercise 1

</link>


</item>


		

<item id="li1026">
<link id="a1026" target-id="Exercise_2">

Exercise 2

</link>


</item>


		

<item id="li1027">
<link id="a1027" target-id="Exercise_3">

Exercise 3

</link>


</item>


		

<item id="li1028">
<link id="a1028" target-id="Exercise_4">

Exercise 4

</link>


</item>


		

<item id="li1029">
<link id="a1029" target-id="Exercise_5">

Exercise 5

</link>


</item>


		

<item id="li1030">
<link id="a1030" target-id="Exercise_6">

Exercise 6

</link>


</item>


	

</list>


	

</item>




</list>


	

	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	

	

<para id="p1000">
This module is one in a collection of modules designed for teaching 

<emphasis id="em1000" effect="italics">

	GAME2302 Mathematical Applications for Game Development

</emphasis>
 at Austin 
	Community College in Austin, TX. 

</para>




<para id="p1001">
<emphasis id="strong1000" effect="bold">
What you have learned

</emphasis>
</para>




<para id="p1002">
In a previous module, I presented and explained four programs that used the 
game-math library named 

<emphasis id="strong1001" effect="bold">
GM2D04

</emphasis>
. One of those programs taught you 
how to use the 

<emphasis id="strong1002" effect="bold">
addVectorToPoint

</emphasis>
 method of the 

<emphasis id="strong1003" effect="bold">
GM2D04.Point

</emphasis>
 class 
to translate a geometric object from one location in space to a different 
location in space.

</para>




<para id="p1003">
Another program taught you how to do the same thing but in a possibly more 
efficient manner.

</para>




<para id="p1004">
The third program taught you how to do rudimentary animation using the 
game-math library.

</para>




<para id="p1005">
The fourth program taught you how to use methods of the game-math library to 
produce relatively complex drawings.

</para>




<para id="p1006">
All of the programs were interactive in that they provide a GUI that allows 
the user to modify certain aspects of the behavior of the program.

</para>




<para id="p1007">
<emphasis id="strong1004" effect="bold">
What you will learn

</emphasis>
</para>




<para id="p1008">
The most important thing that you will learn in this module is how to update 
the game-math library to support 3D math and how to produce 3D images similar to 
that shown in 

<link id="a1031" target-id="Figure_1">

Figure 1

</link>

.

</para>




<para id="p1009">
<emphasis id="Figure_1" effect="bold">


<emphasis id="strong1005" effect="bold">
Figure 1

</emphasis>
</emphasis>


<emphasis id="strong1006" effect="bold">
 A 3D image produced using the game-math library.

</emphasis>
</para>




<para id="p1010">
<media id="media1000" alt="Missing image." display="block">
<image id="img1000" mime-type="image/jpeg" src="../../media/java1710a1.jpg" width="401" height="401"/>
</media>


</para>





<para id="p1011">
<emphasis id="strong1007" effect="bold">
And a whole lot more...

</emphasis>
</para>




<para id="p1012">
You will learn much more than that however. Some highlights of the 
things you will learn are:

</para>




<list id="ul1006" list-type="bulleted">

	

<item id="li1031">
How to program the equations for projecting a 3D world onto a 2D plane 
	for display on a computer screen.

</item>


	

<item id="li1032">
How to cause the direction of the positive y-axis to be up the screen 
	instead of down the screen.

</item>


	

<item id="li1033">
How to add vectors in 3D and how to confirm that the head-to-tail and 
	parallelogram rules apply to 3D as well as to 2D.

</item>


	

<item id="li1034">
About scaling, translation, and rotation of a point in both 2D and 3D.

</item>


	

<item id="li1035">
About the rotation equations and how to implement them in both 2D and 
	3D.

</item>


	

<item id="li1036">
How to rotate a point around an anchor point other than the origin.

</item>


	

<item id="li1037">
About the right-hand rule.

</item>




</list>


	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1013">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and Listings while you are reading about them.

</para>


	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1007" list-type="bulleted">

		

<item id="li1038">
<link id="a1032" target-id="Figure_1">

Figure 1

</link>

. A 3D image produced using the game-math library. 

</item>


		

<item id="li1039">
<link id="a1033" target-id="Figure_2">

Figure 2

</link>

. Graphics output from the program named GM01test02. 

</item>


		

<item id="li1040">
<link id="a1034" target-id="Figure_3">

Figure 3

</link>

. Command-line output from the program named GM01test02. 

</item>


		

<item id="li1041">
<link id="a1035" target-id="Figure_4">

Figure 4

</link>

. Graphic output from the program named GM01test05. 

</item>


		

<item id="li1042">
<link id="a1036" target-id="Figure_5">

Figure 5

</link>

. Graphic output from the program named GM01test06.

</item>


		

<item id="li1043">
<link id="a1037" target-id="Figure_6">

Figure 6

</link>

. Rotation equations for a point in 2D space. 

</item>


		

<item id="li1044">
<link id="a1038" target-id="Figure_7">

Figure 7

</link>

. Initial graphic output from the program named StringArt02. 

</item>


		

<item id="li1045">
<link id="a1039" target-id="Figure_8">

Figure 8

</link>

. Graphic output from the program named StringArt02 with Loops set to 3.

</item>


		

<item id="li1046">
<link id="a1040" target-id="Figure_9">

Figure 9

</link>

. Rotation by 30 degrees around the origin. 

</item>


		

<item id="li1047">
<link id="a1041" target-id="Figure_10">

Figure 10

</link>

. Rotation around an anchor point that is not at the origin. 

</item>


		

<item id="li1048">
<link id="a1042" target-id="Figure_11">

Figure 11

</link>

. Rotation around a point further out in space. 

</item>


		

<item id="li1049">
<link id="a1043" target-id="Figure_12">

Figure 12

</link>

. The six 3D rotation equations. 

</item>


		

<item id="li1050">
<link id="a1044" target-id="Figure_13">

Figure 13

</link>

. Graphic output from the program named StringArt03 at startup. 

</item>


		

<item id="li1051">
<link id="a1045" target-id="Figure_14">

Figure 14

</link>

. Geometric object with 12 vertices, 4 loops, and no rotations. 

</item>


		

<item id="li1052">
<link id="a1046" target-id="Figure_15">

Figure 15

</link>

. Rotation around the z-axis only. 

</item>


		

<item id="li1053">
<link id="a1047" target-id="Figure_16">

Figure 16

</link>

. Rotation around the x-axis only. 

</item>


		

<item id="li1054">
<link id="a1048" target-id="Figure_17">

Figure 17

</link>

. Rotation around the y-axis only. 

</item>


		

<item id="li1055">
<link id="a1049" target-id="Figure_18">

Figure 18

</link>

. Rotation around all three axes with the anchor point at the origin. 

</item>


		

<item id="li1056">
<link id="a1050" target-id="Figure_19">

Figure 19

</link>

. Perform all three rotations with the anchor point away from the origin. 

</item>


		

<item id="li1057">
<link id="a1051" target-id="Figure_20">

Figure 20

</link>

. Screen output from Exercise 1.

</item>


		

<item id="li1058">
<link id="a1052" target-id="Figure_21">

Figure 21

</link>

. Screen output from Exercise 2.

</item>


		

<item id="li1059">
<link id="a1053" target-id="Figure_22">

Figure 22

</link>

. Screen output from Exercise 3.

</item>


		

<item id="li1060">
<link id="a1054" target-id="Figure_23">

Figure 23

</link>

. Screen output from Exercise 4.

</item>


		

<item id="li1061">
<link id="a1055" target-id="Figure_24">

Figure 24

</link>

. Screen output from Exercise 5.

</item>


		

<item id="li1062">
<link id="a1056" target-id="Figure_25">

Figure 25

</link>

. Screen output from Exercise 6.

</item>


	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1008" list-type="bulleted">

		

<item id="li1063">
<link id="a1057" target-id="Listing_1">

Listing 1

</link>

. The static method named convert3Dto2D. 

</item>


		

<item id="li1064">
<link id="a1058" target-id="Listing_2">

Listing 2

</link>

. Transform equations for an oblique parallel projection from 3D to 2D. 

</item>


		

<item id="li1065">
<link id="a1059" target-id="Listing_3">

Listing 3

</link>

. Code in the constructor for the GUI class in the program named GM01test02. 

</item>


		

<item id="li1066">
<link id="a1060" target-id="Listing_4">

Listing 4

</link>

. The method named GM01.Point3D.draw.

</item>


		

<item id="li1067">
<link id="a1061" target-id="Listing_5">

Listing 5

</link>

. The method named GM01.Vector3D.draw. 

</item>


		

<item id="li1068">
<link id="a1062" target-id="Listing_6">

Listing 6

</link>

. The GM01.Line3D.draw method. 

</item>


		

<item id="li1069">
<link id="a1063" target-id="Listing_7">

Listing 7

</link>

. Beginning of the drawOffScreen method in GM01test01. 

</item>


		

<item id="li1070">
<link id="a1064" target-id="Listing_8">

Listing 8

</link>

. Project eight points onto the 2D plane and draw them. 

</item>


		

<item id="li1071">
<link id="a1065" target-id="Listing_9">

Listing 9

</link>

. Draw twelve lines that connect the corners of the box. 

</item>


		

<item id="li1072">
<link id="a1066" target-id="Listing_10">

Listing 10

</link>

. Instantiate and draw a GM01.Vector3D object onto the 2D off-screen image. 

</item>


		

<item id="li1073">
<link id="a1067" target-id="Listing_11">

Listing 11

</link>

. The setCoordinateFrame method. 

</item>


		

<item id="li1074">
<link id="a1068" target-id="Listing_12">

Listing 12

</link>

. The drawOffScreen method of the program named GM01test05. 

</item>


		

<item id="li1075">
<link id="a1069" target-id="Listing_13">

Listing 13

</link>

. The game-math library method named GM01.Point3D.scale.

</item>


		

<item id="li1076">
<link id="a1070" target-id="Listing_14">

Listing 14

</link>

. Beginning of the game-math library method named GM01.Point2D.rotate.

</item>


		

<item id="li1077">
<link id="a1071" target-id="Listing_15">

Listing 15

</link>

. Translate the anchor point to the origin. 

</item>


		

<item id="li1078">
<link id="a1072" target-id="Listing_16">

Listing 16

</link>

. Rotate the translated newPoint object around the origin. 

</item>


		

<item id="li1079">
<link id="a1073" target-id="Listing_17">

Listing 17

</link>

. Translate the rotated newPoint object back to the anchor point. 

</item>


		

<item id="li1080">
<link id="a1074" target-id="Listing_18">

Listing 18

</link>

. Abbreviated listing of the drawOffScreen method. 

</item>


		

<item id="li1081">
<link id="a1075" target-id="Listing_19">

Listing 19

</link>

. Beginning of the method named GM01.Point3D.rotate. 

</item>


		

<item id="li1082">
<link id="a1076" target-id="Listing_20">

Listing 20

</link>

. Get the rotation angle values. 

</item>


		

<item id="li1083">
<link id="a1077" target-id="Listing_21">

Listing 21

</link>

. Rotate the Point3D object around the z-axis. 

</item>


		

<item id="li1084">
<link id="a1078" target-id="Listing_22">

Listing 22

</link>

. Rotate the Point3D object around the x-axis.

</item>


		

<item id="li1085">
<link id="a1079" target-id="Listing_23">

Listing 23

</link>

. Rotate the Point3D object around the y-axis.

</item>


		

<item id="li1086">
<link id="a1080" target-id="Listing_24">

Listing 24

</link>

. Translate the object back to the anchor point. 

</item>


		

<item id="li1087">
<link id="a1081" target-id="Listing_25">

Listing 25

</link>

. Interesting code from the drawOffScreen method. 

</item>


		

<item id="li1088">
<link id="a1082" target-id="Listing_26">

Listing 26

</link>

. Source code for the updated game-math library named GM01.

</item>


		

<item id="li1089">
<link id="a1083" target-id="Listing_27">

Listing 27

</link>

. Source code for the program named GM01test02.

</item>


		

<item id="li1090">
<link id="a1084" target-id="Listing_28">

Listing 28

</link>

. Source code for the program named GM01test01.

</item>


		

<item id="li1091">
<link id="a1085" target-id="Listing_29">

Listing 29

</link>

. Source code for the program named GM01test05. .

</item>


		

<item id="li1092">
<link id="a1086" target-id="Listing_30">

Listing 30

</link>

. Source code for the program named GM01test06. .

</item>


		

<item id="li1093">
<link id="a1087" target-id="Listing_31">

Listing 31

</link>

. Source code for the program named StringArt02. .

</item>


		

<item id="li1094">
<link id="a1088" target-id="Listing_32">

Listing 32

</link>

. Source code for the program named StringArt03. .

</item>



	

</list>




</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview_of_coming_attractions" effect="bold">

Preview of coming attractions

</emphasis>


</title>




<para id="p1014">
In case you are wondering where we are heading as we go down this path, I 
recommend that you skip ahead to the modules titled 

<emphasis id="em1001" effect="italics">
Our First 3D Game Program

</emphasis>
 and


<emphasis id="em1002" effect="italics">
A First-Person Shooter Game

</emphasis>
. 
Copy, compile and run the 3D game programs named 

<emphasis id="strong1008" effect="bold">
GM01Test08

</emphasis>
 and 


<emphasis id="strong1009" effect="bold">
Cannonball01 

</emphasis>
along with the required game-math libraries.

</para>




<para id="p1015">
While the graphics and the story lines for those two game programs are 
rudimentary, the mathematics involved are significant. 

<emphasis id="em1003" effect="italics">
(After all, this is a 
course in game math and not a course in game design or high-quality graphics.)

</emphasis>
</para>



	

</section>
<section id="h11003">
<title>
<emphasis id="Preview" effect="bold">

Preview of this module

</emphasis>


</title>


	

<para id="p1016">
I will present and explain a significantly updated game-math library in 
	this module. 

</para>




<para id="p1017">
I will also present and explain six different sample programs that show how 
to use the new features in the updated library. 

</para>




<para id="p1018">
By studying the library and the sample programs, you will learn 

</para>




<list id="ul1009" list-type="bulleted">

	

<item id="li1095">
how to update the game-math library to support 3D math, 

</item>


	

<item id="li1096">
how to program the equations for projecting a 3D world onto a 2D plane,
	

</item>


	

<item id="li1097">
how to add vectors in 3D, 

</item>


	

<item id="li1098">
about scaling, translation, and rotation of a point in both 2D and 3D,
	

</item>


	

<item id="li1099">
about the rotation equations and 

</item>


	

<item id="li1100">
how to implement them in both 2D and 3D, and much more.

</item>




</list>





<para id="p1019">
I will also provide exercises for you to complete on your own at the end of 
the module. The exercises will concentrate on the material that you have learned 
in this and previous modules.

</para>



	

	

</section>
<section id="h11004">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	

	

<para id="p1020">
In this section, I will present and explain a significantly updated version 
of the game-math library named


<link id="a1089" target-id="The_game-math_library_named_GM01">

GM01

</link>

.

</para>


<para id="p1021">
In addition, 
I will present and explain the following programs that use the update game-math 
library.

</para>




<list id="ul1010" list-type="bulleted">

	

<item id="li1101">
<link id="a1090" target-id="The_program_namedGM01test02">

GM01test02

</link>


</item>


	

<item id="li1102">
<link id="a1091" target-id="The_program_named_GM01test01">

GM01test01

</link>


</item>


	

<item id="li1103">
<link id="a1092" target-id="The_program_named_GM01test05_">

GM01test05

</link>


</item>


	

<item id="li1104">
<link id="a1093" target-id="The_program_named_GM01test06">

GM01test06

</link>


</item>


	

<item id="li1105">
<link id="a1094" target-id="The_program_named_StringArt02_">

StringArt02

</link>


</item>


	

<item id="li1106">
<link id="a1095" target-id="The_program_named_StringArt03_">

StringArt03

</link>


</item>




</list>




<section id="h21001">
<title>
<emphasis id="The_game-math_library_named_GM01" effect="bold">

The game-math library named GM01

</emphasis>


</title>




<para id="p1022">
A complete listing of the updated game-math library named 

<emphasis id="strong1010" effect="bold">
GM01

</emphasis>
 is provided in 


<link id="a1096" target-id="Listing_26">

Listing 26

</link>

 near the end of the module.

</para>




<para id="p1023">
<emphasis id="strong1011" effect="bold">
A major update to add 3D capability

</emphasis>
</para>




<para id="p1024">
This is a major update to the game-math library. This version updates 
the earlier version named 

<emphasis id="strong1012" effect="bold">
GM2D04

</emphasis>
 to a new version named simply 

<emphasis id="strong1013" effect="bold">
GM01

</emphasis>
. 
The primary purpose of the update was to add 3D capability for all of the 2D 
features provided by the previous version. Because both 2D and 3D 
capabilities are now included in the library, it is no longer necessary to 
differentiate between the two in the name of the class. Therefore, this 
version is simply named 

<emphasis id="strong1014" effect="bold">
GM01

</emphasis>
.

</para>




<para id="p1025">
<emphasis id="strong1015" effect="bold">
3D to 2D projections

</emphasis>
</para>




<para id="p1026">
Adding 3D capability was tedious, but not particularly difficult in most 
areas of the library. However, adding 3D capability entailed major 
complexity in one particular area: drawing the objects. It is 
difficult to draw a 3D object on a 2D screen and have the drawing appear to be 
3D. This requires a projection process to project each point in the 3D 
object onto the correct location on a 2D screen. There are a variety of 
ways to do this. This 3D library uses an approach often referred to as an 


<emphasis id="em1004" effect="italics">
<link id="a1097" url="http://en.wikipedia.org/wiki/Oblique_projection">

oblique parallel projection

</link>


</emphasis>
. You can Google that name to learn 
more about the technical details of the process.

</para>




<para id="p1027">
<emphasis id="strong1016" effect="bold">
Eliminating the y-axis confusion

</emphasis>
</para>




<para id="p1028">
In addition to adding 3D capability, this version of the game library also eliminates the 
confusion surrounding the fact that the default direction of the positive y-axis 
is down the screen instead of up the screen as viewers have become accustomed 
to. If you funnel all of your drawing tasks through the library and don't 
draw directly on the screen, you can program under the assumption that the 
positive direction of the y-axis is up.

</para>




<para id="p1029">
<emphasis id="strong1017" effect="bold">
The name of the library

</emphasis>
</para>




<para id="p1030">
The name 

<emphasis id="strong1018" effect="bold">
GM01

</emphasis>
 is an abbreviation for 

<emphasis id="em1005" effect="italics">
GameMath01

</emphasis>
. See the 
file named 

<emphasis id="strong1019" effect="bold">
GM2D01

</emphasis>
 from an earlier module for a general 
description of the game-math library. The library has been updated several 
times. This version updates the file named 

<emphasis id="strong1020" effect="bold">
GM2D04

</emphasis>
.

</para>




<para id="p1031">
<emphasis id="strong1021" effect="bold">
Improving efficiency

</emphasis>
</para>




<para id="p1032">
In addition to the updates mentioned above, this update cleaned up some 
lingering areas of code inefficiency by using the simplest available method to 
draw on an off-screen image.

</para>




<para id="p1033">
<emphasis id="strong1022" effect="bold">
New static methods

</emphasis>
</para>




<para id="p1034">
Also, the following new static methods were added to the class named 

<emphasis id="strong1023" effect="bold">
GM01

</emphasis>
. 
The first method in the following list deals with the problem of displaying a 3D 
image on a 2D screen. The last five methods in the list wrap around the 
standard graphics methods for the purpose of eliminating the issue of the 
direction of the positive Y-axis.

</para>




<list id="ul1011" list-type="bulleted">

	

<item id="li1107">
GM01.convert3Dto2D

</item>


	

<item id="li1108">
GM01.translate

</item>


	

<item id="li1109">
GM01.drawLine

</item>


	

<item id="li1110">
GM01.fillOval

</item>


	

<item id="li1111">
GM01.drawOval

</item>


	

<item id="li1112">
GM01.fillRect

</item>




</list>




<para id="p1035">
It will probably be necessary for me to add more wrapper methods to the 
library in future modules. With the exception of the first method in the 
above list, the coding of these methods was straightforward and explanations of 
that code are not warranted. Note, however, that it is the wrapper methods that resolve the issue regarding the direction of the positive 
y-axis. You will see comments in this regard if you examine the source 
code for the wrapper methods in 

<link id="a1098" target-id="Listing_27">

Listing 27

</link>

. I will explain the code for 
the method named 

<emphasis id="strong1024" effect="bold">
GM01.convert3Dto2D

</emphasis>
 shortly.

</para>




<para id="p1036">
<emphasis id="strong1025" effect="bold">
Other new methods

</emphasis>
</para>




<para id="p1037">
In addition to the new static methods listed above, a number of new methods 
were added to the existing static top-level 2D classes and also included in the 
new static top-level 3D classes. A list of those new methods follows:

</para>




<list id="ul1012" list-type="bulleted">

	

<item id="li1113">
GM01.Vector2D.scale

</item>


	

<item id="li1114">
GM01.Vector2D.negate

</item>


	

<item id="li1115">
GM01.Point2D.clone

</item>


	

<item id="li1116">
GM01.Vector2D.normalize

</item>


	

<item id="li1117">
<emphasis id="strong1026" effect="bold">
GM01.Point2D.rotate

</emphasis>
</item>


	

<item id="li1118">
GM01.Point2D.scale

</item>


	

<item id="li1119">
GM01.Vector3D.scale

</item>


	

<item id="li1120">
GM01.Vector3D.negate

</item>


	

<item id="li1121">
GM01.Point3D.clone

</item>


	

<item id="li1122">
GM01.Vector3D.normalize

</item>


	

<item id="li1123">
<emphasis id="strong1027" effect="bold">
GM01.Point3D.rotate

</emphasis>
</item>


	

<item id="li1124">
GM01.Point3D.scale

</item>




</list>




<para id="p1038">
With the exception of the two 

<emphasis id="strong1028" effect="bold">
rotate

</emphasis>
 methods, the coding of the 
methods in the above list was also straightforward and an explanation of that 
code is not warranted. You can view all of the new code in 

<link id="a1099" target-id="Listing_26">

Listing 26

</link>

.

</para>




<para id="p1039">
The two 

<emphasis id="strong1029" effect="bold">
rotate

</emphasis>
 methods are not straightforward at all. They are 
quite complicated 

<emphasis id="em1006" effect="italics">
(particularly the 3D method)

</emphasis>
 and require quite a lot of 
background information to understand. I will dedicate a large portion of a 
future module to the task of rotating geometric objects in 2D and 3D worlds and 
will defer an explanation of the two 

<emphasis id="strong1030" effect="bold">
rotate

</emphasis>
 methods until that module.

</para>




<para id="p1040">
<emphasis id="strong1031" effect="bold">
The static method named GM01convert3Dto2D

</emphasis>
</para>




<para id="p1041">
Note first that this is a static method of the class named 

<emphasis id="strong1032" effect="bold">
GM01

</emphasis>
. 
Among other things, this means that the method can be called simply by joining 
the name of the method to the name of the class. In other words, an object 
of the class named 

<emphasis id="strong1033" effect="bold">
GM01

</emphasis>
 is not necessary to make the method accessible.

</para>




<para id="p1042">
A complete listing of the method is provided in 

<link id="a1100" target-id="Listing_1">

Listing 1

</link>

.

</para>




	

<table id="table1000" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1000">

			

<row id="tr1000">



<entry id="th1000">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. The static method named convert3Dto2D. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1000">

			

<row id="tr1001">

				

<entry id="td1000">



<code id="pre1000" display="block">  public static GM01.ColMatrix2D convert3Dto2D(
                                   GM01.ColMatrix3D data){
    return new GM01.ColMatrix2D(
                  data.getData(0) - 0.866*data.getData(2),
                  data.getData(1) - 0.50*data.getData(2));
  }//end convert3Dto2D
</code>



	

<para id="p1043">
As you can see, the method is quite short, and once you know how it is 
	required to 

<link id="a1101" target-id="Behavior_of_the_GM01.convert3Dto2D_method">

behave

</link>

, coding the method is not difficult. The complexity comes in 
	understanding the required behavior.

</para>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>







	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1034" effect="bold">
Keeping 2D and 3D classes separate:

</emphasis>

				

<para id="p1044">
All of the static top-level 2D classes in the existing game-math library were renamed with a suffix of 2D to distinguish them from the new top-level 3D classes.  All of the new top-level 3D class names have a 3D suffix.

</para>


				

</note>

			


		



	



	

<para id="p1045">
<emphasis id="strong1035" effect="bold">
The ColMatrix2D and ColMatrix3D classes

</emphasis>
</para>




<para id="p1046">
From the very beginning, the game-math library has contained a static 
top-level class named 

<emphasis id="strong1036" effect="bold">
ColMatrix

</emphasis>
. In the updated version of the 
library, that class has been renamed 

<emphasis id="strong1037" effect="bold">
ColMatrix2D

</emphasis>
.

</para>




<para id="p1047">
Basically, the 

<emphasis id="strong1038" effect="bold">
ColMatrix2D

</emphasis>
 class provides a container for a pair of 
values of type 

<emphasis id="strong1039" effect="bold">
double

</emphasis>
 with appropriate methods for accessing those 
values. 

<emphasis id="em1007" effect="italics">
(I explained the original 

<emphasis id="strong1040" effect="bold">
ColMatrix

</emphasis>
 class in detail in 
an earlier module.) 

</emphasis>
Similarly, the new 

<emphasis id="strong1041" effect="bold">
ColMatrix3D

</emphasis>
 class provides a container for three 
values of type 

<emphasis id="strong1042" effect="bold">
double

</emphasis>
 with appropriate methods for accessing those 
values.

</para>




<para id="p1048">
Objects of the 

<emphasis id="strong1043" effect="bold">
ColMatrix2D

</emphasis>
 class are the fundamental building blocks 
for several of the other 2D classes in the library, and objects of the 

<emphasis id="strong1044" effect="bold">

ColMatrix3D

</emphasis>
 class are the fundamental building blocks for several of the 
other 3D classes in the library.

</para>




<para id="p1049">
<emphasis id="strong1045" effect="bold">
<emphasis id="Behavior_of_the_GM01.convert3Dto2D_method" effect="bold">

Behavior of the 
GM01.convert3Dto2D method

</emphasis>


</emphasis>
</para>




<para id="p1050">
The 

<emphasis id="strong1046" effect="bold">
convert3Dto2D

</emphasis>
 method converts a 

<emphasis id="strong1047" effect="bold">
ColMatrix3D

</emphasis>
 object that 
represents a point in 3D space into a 

<emphasis id="strong1048" effect="bold">
ColMatrix2D

</emphasis>
 object that represents 


<emphasis id="strong1049" effect="bold">
<emphasis id="em1008" effect="italics">
the projection of that 3D point onto a 2D plane

</emphasis>
</emphasis>
. 

</para>




<para id="p1051">
The purpose of the method 
is to accept x, y, and z coordinate values describing a point in 3D space and to 
transform those values into a pair of coordinate values suitable for being 
displayed in two dimensions. The math that is implemented by this method 
to do the projection is described on a web page that seems to move around a bit 
but the last time I checked, it was located at


<link id="a1102" url="http://paulbourke.net/geometry/transformationprojection/">


http://paulbourke.net/geometry/transformationprojection/

</link>

 If you don't find 
it there, try 

<link id="a1103" url="http://paulbourke.net/geometry/">


http://paulbourke.net/geometry/

</link>

 In any event, a Google search should expose 
numerous pages that explain the math for projections of this type.

</para>




<para id="p1052">
<emphasis id="strong1050" effect="bold">
The transform equations

</emphasis>
</para>




<para id="p1053">
I won't attempt to justify or to explain the transform equations that are 
used to accomplish the projection in this module. Rather, I will simply 
use them as presented in the above resource. In the meantime, if you are interested in 
more information on the topic, you will find a wealth of information on 3D to 2D 
projections by performing a Google search for the topic.

</para>




<para id="p1054">
The transform equations along with some of the assumptions that I made in the 
use of the equations are shown in 

<link id="a1104" target-id="Listing_2">

Listing 2

</link>

.

</para>


	


	

<table id="table1001" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1001">

			

<row id="tr1002">



<entry id="th1001">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

.  Transform equations for an oblique parallel projection from 3D to 2D. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1001">

			

<row id="tr1003">

				

<entry id="td1001">



<code id="pre1001" display="block">The transform equations are:
 x2d = x3d + z3d * cos(theta)/tan(alpha)
 y2d = y3d + z3d * sin(theta)/tan(alpha);

Let alpha = 45 degrees and theta = 30 degrees
Then:  cos(theta) = 0.866
       sin(theta) = 0.5
       tan(alpha) = 1;

Note that the signs in the above equations depend
 on the assumed directions of the angles as well as
 the assumed positive directions of the axes. The
 signs used in this method assume the following:
   Positive x is to the right.
   Positive y is up the screen.
   Positive z is protruding out the front of the
     screen.
   The viewing position is above the x axis and to the
     right of the z-y plane.
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1055">
<emphasis id="strong1051" effect="bold">
The terms in the equations

</emphasis>
</para>




<para id="p1056">
In 

<link id="a1105" target-id="Listing_2">

Listing 2

</link>

, the terms 

<emphasis id="em1009" effect="italics">
x2d

</emphasis>
 and 

<emphasis id="em1010" effect="italics">
y2d

</emphasis>
 refer to drawing 
coordinates on the 2D screen, while 

<emphasis id="em1011" effect="italics">
x3d

</emphasis>
, 

<emphasis id="em1012" effect="italics">
y3d

</emphasis>
, and 

<emphasis id="em1013" effect="italics">
z3d

</emphasis>
 refer 
to the coordinates of a point in 3D space. Obviously, 

<emphasis id="em1014" effect="italics">
sin

</emphasis>
, 

<emphasis id="em1015" effect="italics">
cos

</emphasis>
, 
and 

<emphasis id="em1016" effect="italics">
tan

</emphasis>
 refer to the sine, cosine, and tangent of angles named 

<emphasis id="em1017" effect="italics">
alpha

</emphasis>
 
and 

<emphasis id="em1018" effect="italics">
theta

</emphasis>
.

</para>




<para id="p1057">
<emphasis id="strong1052" effect="bold">
Output in two dimensions

</emphasis>
</para>




<para id="p1058">
These equations and the assumptions that I made in using them produce 
displays such as the one shown in 

<link id="a1106" target-id="Figure_1">

Figure 1

</link>

. In that image, the red 
horizontal line is the x-axis with the positive direction to the right. 
The green vertical line is the y-axis with the positive direction pointing up. 
The blue sloping line is the z-axis with the positive direction protruding from 
the screen towards and to the left of the viewer. The three axes intersect 
at the origin in 3D space.

</para>




<para id="p1059">
<emphasis id="em1019" effect="italics">
(The sloping magenta line going from the corner of the box to 
the origin is a 3D vector. I will have more to say about the projections 
of 3D vectors later.)

</emphasis>
</para>




<para id="p1060">
<emphasis id="strong1053" effect="bold">
No perspective in this projection

</emphasis>
</para>




<para id="p1061">
The sloping black lines in 

<link id="a1107" target-id="Figure_1">

Figure 1

</link>

 represent the edges of a rectangular box 
projected onto the 2D screen. Note in particular that there is no 
perspective in this type of projection. In other words, lines that are 
parallel in the 3D space remain parallel in the projection of those lines onto 
the 2D screen. 

<emphasis id="em1020" effect="italics">
(Hence the word parallel in the name oblique parallel 
projection.)

</emphasis>
 Objects don't appear to be smaller simply because they 
are further away from the viewer. 

</para>




<para id="p1062">
<emphasis id="em1021" effect="italics">
(The application of perspective would add another layer of complexity to 
the game math library. I will leave that as an exercise for the student to 
accomplish.)

</emphasis>
</para>




<para id="p1063">
<emphasis id="strong1054" effect="bold">
Options involving the angles

</emphasis>
</para>




<para id="p1064">
I could have produced a somewhat different display by assuming different 
values for the angles named 

<emphasis id="em1022" effect="italics">
alpha

</emphasis>
 and 

<emphasis id="em1023" effect="italics">
theta

</emphasis>
. However, the 
values chosen are commonly used values that produce reasonably good results, so 
I decided to use them. You may find it interesting to experiment with 
other values for one or both angles to see the results produced by those other 
values.

</para>




<para id="p1065">
<emphasis id="strong1055" effect="bold">
The proper algebraic signs

</emphasis>
</para>




<para id="p1066">
Note in particular that the proper signs for the equations in 

<link id="a1108" target-id="Listing_2">

Listing 2

</link>

 
depend on the assumed positive directions of the angles as well as the assumed 
positive directions of the axes. The signs used in the method make the 
assumptions shown in 

<link id="a1109" target-id="Listing_2">

Listing 2

</link>

. 

<emphasis id="em1024" effect="italics">
(These assumptions will be particularly 
important in future modules where we will be rotating objects in 3D space.)

</emphasis>
</para>




<para id="p1067">
<emphasis id="strong1056" effect="bold">
The viewing position

</emphasis>
</para>




<para id="p1068">
Also as indicated in 

<link id="a1110" target-id="Listing_2">

Listing 2

</link>

 and shown in 

<link id="a1111" target-id="Figure_1">

Figure 1

</link>

, the viewing position is 
above the x-axis and to the right of the z-y plane.

</para>




<para id="p1069">
Typically, a game math library would provide the capability to modify the 
viewing position. That capability is not supported directly by this library. 
However, that capability can be approximated by the rotation capability 
discussed later. 

<emphasis id="em1025" effect="italics">
(Another exercise for the student to accomplish.)

</emphasis>
</para>




<para id="p1070">
<emphasis id="strong1057" effect="bold">
The code in the method is straightforward

</emphasis>
</para>




<para id="p1071">
As I mentioned earlier, once you understand the requirements, the code for 
the method named 

<emphasis id="strong1058" effect="bold">
convert3Dto2D 

</emphasis>
<emphasis id="em1026" effect="italics">
(see 

<link id="a1112" target-id="Listing_1">

Listing 1

</link>

)

</emphasis>
 is relatively 
straightforward. If you have studied the code in the previous modules in 
this series, the code in 

<link id="a1113" target-id="Listing_1">

Listing 1

</link>

 shouldn't require further explanation.

</para>




</section>
<section id="h21002">
<title>
<emphasis id="The_program_namedGM01test02" effect="bold">

The program named GM01test02

</emphasis>


</title>




<para id="p1072">
Because I made some changes to the existing 2D classes in the game-math 
library and added some new methods to some of the existing 2D classes, I felt 
the need to write a program that would step through and test the behavior of 
most of the 2D methods in the library. That was the purpose of the program 
named 

<emphasis id="strong1059" effect="bold">
GM01test02

</emphasis>
.

</para>




<para id="p1073">
This program produces both a graphic screen output and lots of text on the 
command-line screen. The graphic output is shown in 

<link id="a1114" target-id="Figure_2">

Figure 2

</link>

.

</para>




<para id="p1074">
<emphasis id="Figure_2" effect="bold">


<emphasis id="strong1060" effect="bold">
Figure 2

</emphasis>
</emphasis>


<emphasis id="strong1061" effect="bold">
 Graphics output from the program named GM01test02.

</emphasis>
</para>




<para id="p1075">
<media id="media1001" alt="Missing image." display="block">
<image id="img1001" mime-type="image/jpeg" src="../../media/java1710a2.jpg" width="401" height="400"/>
</media>


</para>




<para id="p1076">
<emphasis id="strong1062" effect="bold">
Command-line output from the program named GM01test02

</emphasis>
</para>




<para id="p1077">
The command-line output is shown in 

<link id="a1115" target-id="Figure_3">

Figure 3

</link>

.

</para>





<para id="p1078">
<emphasis id="strong1063" effect="bold">
<emphasis id="Figure_3" effect="bold">

Figure 3

</emphasis>

. Command-line output from the program named GM01test02.

</emphasis>
</para>






<code id="pre1002" display="block">Test overridden toString of ColMatrix2D
1.5,2.5

Test setData and getData of ColMatrix2D
4.5
5.5

Test equals method of ColMatrix2D
false
true

Test add method of ColMatrix2D
9.0,11.0

Test subtract method of ColMatrix2D
0.0,0.0

Test toString method of Point2D
4.5,5.5

Test setData and getData of Point2D
1.1
2.2

Test getColMatrix method of Point2D
1.1,2.2

Test equals method of Point2D
false
true

Test getDisplacementVector method of Point2D
1.5,2.5
4.5,5.5
3.0,3.0

Test addVectorToPoint method of Point2D
1.5,2.5
7.0,9.0

Test toString method of Vector2D
1.5,2.5

Test setData and getData methods of Vector2D
4.5
5.5

Test getColMatrix method of Vector2D
4.5,5.5

Test equals method of Vector2D
false
true
Test add method of Vector2D
4.5,5.5
-1.5,3.5
3.0,9.0

Test getLength method of Vector2D
3.0,4.0
5.0

Test toString method of Line2D
Tail = 1.5,2.5
Head = 4.5,5.5

Test setTail, setHead, getTail,
and getHead methods of Line2D
4.5,5.5
1.5,2.5
</code>




	

<para id="p1079">
<emphasis id="strong1064" effect="bold">
Not too exciting

</emphasis>
</para>




<para id="p1080">
Neither the graphics output in 

<link id="a1116" target-id="Figure_2">

Figure 2

</link>

 nor the command-line output in 


<link id="a1117" target-id="Figure_3">

Figure 3

</link>

 are terribly exciting, and neither will mean much to you unless you are 
willing to examine the code and compare the output with the code.

</para>




<para id="p1081">
<emphasis id="strong1065" effect="bold">
Source code for the program named GM01test02

</emphasis>
</para>




<para id="p1082">
A complete listing of the program named 

<emphasis id="strong1066" effect="bold">
GM01test02

</emphasis>
 is shown in 


<link id="a1118" target-id="Listing_27">

Listing 
27

</link>

 near the end of the module.

</para>




<para id="p1083">
<link id="a1119" target-id="Listing_3">

Listing 3

</link>

 shows two of the statements in the constructor for the 

<emphasis id="strong1067" effect="bold">
GUI

</emphasis>
 
class in the program named 

<emphasis id="strong1068" effect="bold">
GM01test02

</emphasis>
. The call to the method named


<emphasis id="strong1069" effect="bold">
testUsingText

</emphasis>
 produces the command-line output shown in 

<link id="a1120" target-id="Figure_3">

Figure 3

</link>

, while 
the call to the method named 

<emphasis id="strong1070" effect="bold">
drawOffScreen

</emphasis>
 produces the graphic output 
shown in 

<link id="a1121" target-id="Figure_2">

Figure 2

</link>

.

</para>




	

<table id="table1002" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1002">

			

<row id="tr1004">



<entry id="th1002">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

.  Code in the constructor for the GUI class in the program named GM01test02. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1002">

			

<row id="tr1005">

				

<entry id="td1002">

				

<code id="pre1003" display="block">    //Perform tests using text.
    testUsingText();
    
    //Perform tests using graphics.
    drawOffScreen(g2D);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1084">
If you examine the source code for those two methods in 

<link id="a1122" target-id="Listing_27">

Listing 27

</link>

, you 
	will see that each of the methods contains calls to library methods for the 
	purpose of confirming that the library methods behave as expected. The 
	code in most of those methods is straightforward and should not require 
	further explanation beyond the embedded comments in 

<link id="a1123" target-id="Listing_27">

Listing 27

</link>

.

</para>




<para id="p1085">
<emphasis id="strong1071" effect="bold">
End of the discussion for the program named GM01test02

</emphasis>
</para>




<para id="p1086">
That concludes the discussion of the program named 

<emphasis id="strong1072" effect="bold">
GM01test02

</emphasis>
. 
You will find a complete listing of this program in 

<link id="a1124" target-id="Listing_27">

Listing 27

</link>

.

</para>




</section>
<section id="h21003">
<title>
<emphasis id="The_program_named_GM01test01" effect="bold">

The program named GM01test01

</emphasis>


</title>




<para id="p1087">
Code in the program named 

<emphasis id="strong1073" effect="bold">
GM01test01 

</emphasis>
makes calls to library methods, 
which in turn make calls to the method named 

<emphasis id="strong1074" effect="bold">
convert3Dto2D 

</emphasis>
shown in 


<link id="a1125" target-id="Listing_1">

Listing 1

</link>

. Because of the complexity of projecting 3D points onto a 2D 
screen for display, it will be useful to discuss the three library methods that 
make calls to the library method named 

<emphasis id="strong1075" effect="bold">
convert3Dto2D

</emphasis>
. Those three 
methods are shown in the 

<emphasis id="following_list" effect="bold">

following list

</emphasis>

:

</para>




<list id="ul1013" list-type="bulleted">

	

<item id="li1125">
GM01.Point3D.draw

</item>


	

<item id="li1126">
GM01.Vector3D.draw

</item>


	

<item id="li1127">
GM01.Line3D.draw

</item>




</list>




<section id="h31002">
<title>
<emphasis id="The_method_named_GM01.Point3D.draw" effect="bold">

The method named 
GM01.Point3D.draw

</emphasis>


</title>




<para id="p1088">
Recall that a point simply represents a location in space and has no width, 
height, or depth. Therefore a point is not visible to the human eye. 
However, it is sometimes useful to draw a small circle around a point to mark 
its location for human consumption. That is the purpose of the 

<emphasis id="strong1076" effect="bold">
draw

</emphasis>
 
method of the 

<emphasis id="strong1077" effect="bold">
GM01.Point3D 

</emphasis>
class, which is shown in its entirety in 


<link id="a1126" target-id="Listing_4">

Listing 4

</link>

.

</para>




	

<table id="table1003" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">



<entry id="th1003">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. The method named GM01.Point3D.draw.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">

				

<code id="pre1004" display="block">    public void draw(Graphics2D g2D){
      
      //Get 2D projection coordinate values.
      ColMatrix2D temp = convert3Dto2D(point);
      drawOval(g2D,temp.getData(0)-3,
                   temp.getData(1)+3,
                   6,
                   6);
    }//end draw
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1089">
<emphasis id="strong1078" effect="bold">
Purpose of the method

</emphasis>
</para>




<para id="p1090">
This method draws a small circle around the location of a point in 3D space. 
The 3D location of the circle is projected onto the 2D plane of the specified 
graphics context for display later on a 2D screen. The code in 

<link id="a1127" target-id="Listing_4">

Listing 4

</link>

 
projects that location in 3D space onto the 2D plane by calling the static 
method named 

<emphasis id="strong1079" effect="bold">
convert3Dto2D

</emphasis>
.

</para>




<para id="p1091">
<emphasis id="strong1080" effect="bold">
Behavior of the GM01.Point3D.draw method

</emphasis>
</para>




<para id="p1092">
The location of a point in 3D space, as represented by an object of the 

<emphasis id="strong1081" effect="bold">

GM01.Point3D 

</emphasis>
class, is actually stored in an object of the 

<emphasis id="strong1082" effect="bold">

GM01.ColMatrix3D

</emphasis>
 class. A reference to that 

<emphasis id="strong1083" effect="bold">
ColMatrix3D

</emphasis>
 object 
is stored in the instance variable named 

<emphasis id="strong1084" effect="bold">
point

</emphasis>
 belonging to the 

<emphasis id="strong1085" effect="bold">

Point3D

</emphasis>
 object. This reference is passed as a parameter to the 

<emphasis id="strong1086" effect="bold">

convert3Dto2D

</emphasis>
 method in 

<link id="a1128" target-id="Listing_4">

Listing 4

</link>

.

</para>




<para id="p1093">
Recall from 

<link id="a1129" target-id="Listing_1">

Listing 1

</link>

 that the 

<emphasis id="strong1087" effect="bold">
convert3Dto2D

</emphasis>
 method receives an 
incoming reference to an object of the class 

<emphasis id="strong1088" effect="bold">
GM01.ColMatrix3D

</emphasis>
 and returns 
a reference to an object of the class 

<emphasis id="strong1089" effect="bold">
GM01.ColMatrix2D

</emphasis>
, which contains 
the horizontal and vertical components of the projection of the 3D point onto a 
2D plane.

</para>




<para id="p1094">
<emphasis id="strong1090" effect="bold">
Using the returned GM01.ColMatrix2D object

</emphasis>
</para>




<para id="p1095">
<link id="a1130" target-id="Listing_4">

Listing 4

</link>

 uses the horizontal and vertical components stored in the returned


<emphasis id="strong1091" effect="bold">
ColMatrix2D 

</emphasis>
object to construct the proper parameters and call the 
wrapper method named 

<emphasis id="strong1092" effect="bold">
GM01.drawOval

</emphasis>
. This wrapper method doesn't 
know that it is receiving parameters that were originally derived from an object 
in 3D space. The world of the wrapper method is confined to 2D space. 
The wrapper method named 

<emphasis id="strong1093" effect="bold">
GM01.drawOval

</emphasis>
 performs the following actions:

</para>




<list id="ul1014" list-type="bulleted">

	

<item id="li1128">
casts the four incoming numeric parameters to type 

<emphasis id="strong1094" effect="bold">
int

</emphasis>
,

</item>


	

<item id="li1129">
flips the sign on the vertical component to resolve the issue regarding 
	the positive value for the y-axis, and

</item>


	

<item id="li1130">
passes the parameters to the 

<emphasis id="strong1095" effect="bold">
drawOval

</emphasis>
 method of the standard 

<emphasis id="strong1096" effect="bold">

	Graphics

</emphasis>
 class to cause a small circle to be drawn at the correct 
	location on the 2D off-screen image.

</item>




</list>




<para id="p1096">
<emphasis id="strong1097" effect="bold">
The small circle is not converted to an ellipse

</emphasis>
</para>




<para id="p1097">
Note that even though the location of the point in 3D space is projected onto 
the 2D plane, the shape of the small circle is not converted to an ellipse to 
reflect the 3D to 2D conversion nature of the operation. Thus, if the 
circle were large, it wouldn't necessarily look right. However, in this 
case, the only purpose of the circle is to mark the location of a point in 3D 
space. Therefore, I didn't consider the actual shape of the marker to be 
too important. 

<link id="a1131" target-id="Figure_1">

Figure 1

</link>

 shows examples of circles marking points in 3D 
space at the corners of the box and at the ends of the axes.

</para>




</section>
<section id="h31003">
<title>
<emphasis id="The_method_named_GM01.Vector3D.draw_" effect="bold">

The method named 
GM01.Vector3D.draw

</emphasis>


</title>




<para id="p1098">
The behavior described above for the method named 

<emphasis id="strong1098" effect="bold">
GM01.Point3D.draw

</emphasis>
 is 
somewhat indicative of the manner in which 3D geometric objects are projected 
onto a 2D plane and the manner in which the issue regarding the positive 
direction of the y-axis is resolved by the code in the updated game-math 
library.

</para>




<para id="p1099">
<emphasis id="strong1099" effect="bold">
The behavior of the three draw methods

</emphasis>
</para>




<para id="p1100">
Each of the three 

<emphasis id="strong1100" effect="bold">
draw

</emphasis>
 methods listed


<link id="a1132" target-id="following_list">

earlier

</link>

 needs the ability to project a


<emphasis id="strong1101" effect="bold">
Point3D

</emphasis>
 object, a 

<emphasis id="strong1102" effect="bold">
Vector3D

</emphasis>
 object, or a 

<emphasis id="strong1103" effect="bold">
Line3D

</emphasis>
 object onto 
a 2D pane. In each case, the object to be drawn is built up using one or 
more

<emphasis id="strong1104" effect="bold">
 ColMatrix3D

</emphasis>
 objects

<emphasis id="strong1105" effect="bold">
 

</emphasis>
as

<emphasis id="strong1106" effect="bold">
 

</emphasis>
fundamental building blocks.

</para>




<para id="p1101">
For the case of the

<emphasis id="strong1107" effect="bold">
 GM01.Point3D.draw

</emphasis>
 method discussed above, the 

<emphasis id="strong1108" effect="bold">

draw

</emphasis>
 method calls the 

<emphasis id="strong1109" effect="bold">
convert3Dto2D

</emphasis>
 method directly to convert the 3D 
coordinate values of the point to the 2D coordinate values required for the 
display.

</para>




<para id="p1102">
<emphasis id="strong1110" effect="bold">
A similar approach for the GM01.Vector3D.draw method

</emphasis>
</para>




<para id="p1103">
A similar approach is used for the 

<emphasis id="strong1111" effect="bold">
GM01.Vector3D.draw

</emphasis>
 method, which is 
shown in 

<link id="a1133" target-id="Listing_5">

Listing 5

</link>

.

</para>




	

<table id="table1004" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">



<entry id="th1004">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. The method named GM01.Vector3D.draw. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">

				

<code id="pre1005" display="block">    public void draw(Graphics2D g2D,GM01.Point3D tail){
      
      //Get a 2D projection of the tail
      GM01.ColMatrix2D tail2D = convert3Dto2D(tail.point);
      
      //Get the 3D location of the head
      GM01.ColMatrix3D head = 
                      tail.point.add(this.getColMatrix());
      
      //Get a 2D projection of the head
      GM01.ColMatrix2D head2D = convert3Dto2D(head);
      drawLine(g2D,tail2D.getData(0),
                   tail2D.getData(1),
                   head2D.getData(0),
                   head2D.getData(1));      

      //Draw a small filled circle to identify the head.
      fillOval(g2D,head2D.getData(0)-3,
                   head2D.getData(1)+3,
                   6,
                   6);

    }//end draw
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1104">
This method draws the 2D visual manifestation of a 

<emphasis id="strong1112" effect="bold">
GM01.Vector3D

</emphasis>
 
	object on the specified 2D graphics context. Recall that a vector has 
	no location property. Therefore, it can be correctly drawn anywhere. 
	The 

<emphasis id="strong1113" effect="bold">
GM01.Vector3D.draw

</emphasis>
 method requires the drawing location of the 
	tail to be specified by a reference to a 

<emphasis id="strong1114" effect="bold">
GM01.Point3D

</emphasis>
 object received 
	as an incoming parameter.

</para>




<para id="p1105">
A small 

<emphasis id="strong1115" effect="bold">
<emphasis id="em1027" effect="italics">
filled

</emphasis>
</emphasis>
 circle is drawn at the head of the vector as shown by the 
magenta filled circle at the origin in 

<link id="a1134" target-id="Figure_1">

Figure 1

</link>

. 

<emphasis id="em1028" effect="italics">
(Note that the other 
circles in 

<link id="a1135" target-id="Figure_1">

Figure 1

</link>

 are not filled.)

</emphasis>
</para>




<para id="p1106">
<emphasis id="strong1116" effect="bold">
Two calls to the convert3Dto2D method

</emphasis>
</para>




<para id="p1107">
Two calls are made to the 

<emphasis id="strong1117" effect="bold">
convert3Dto2D

</emphasis>
 method in 

<link id="a1136" target-id="Listing_5">

Listing 5

</link>

. The 
first call gets a 2D projection of the 3D location of the tail of the vector. 
The second call gets a 2D projection of the 3D location of the head of the 
vector. In both cases, the projected location in 2D space is returned as a 
reference to an object of the 

<emphasis id="strong1118" effect="bold">
GM01.ColMatrix2D

</emphasis>
 class.

</para>




<para id="p1108">
<emphasis id="strong1119" effect="bold">
Draw the vector on the specified drawing context

</emphasis>
</para>




<para id="p1109">
The reference returned by the first call to the 

<emphasis id="strong1120" effect="bold">
convert3Dto2D

</emphasis>
 method 
is used to call the static 

<emphasis id="strong1121" effect="bold">
GM01.drawLine

</emphasis>
 wrapper method to

</para>




<list id="ul1015" list-type="bulleted">

	

<item id="li1131">
handle the issue of the positive direction of the y-axis, and

</item>


	

<item id="li1132">
draw a line on the 2D off-screen image representing the body of the 
	vector as shown by the magenta line in 

<link id="a1137" target-id="Figure_1">

Figure 1

</link>

.

</item>




</list>




<para id="p1110">
The reference returned by the second call to the 

<emphasis id="strong1122" effect="bold">
convert3Dto2D

</emphasis>
 method 
is used to call the static 

<emphasis id="strong1123" effect="bold">
GM01.fillOval

</emphasis>
 wrapper method to

</para>




<list id="ul1016" list-type="bulleted">

	

<item id="li1133">
handle the issue of the positive direction of the y-axis, and

</item>


	

<item id="li1134">
draw a small filled circle on the 2D off-screen image representing the 
	head of the vector as shown by the magenta filled circle at the origin in 
	

<link id="a1138" target-id="Figure_1">

Figure 1

</link>

.

</item>




</list>




</section>
<section id="h31004">
<title>
<emphasis id="The_method_named_GM01.Line3D.draw" effect="bold">

The method named 
GM01.Line3D.draw

</emphasis>


</title>




<para id="p1111">
The 

<emphasis id="strong1124" effect="bold">
GM01.Line3D.draw

</emphasis>
 method is shown in 

<link id="a1139" target-id="Listing_6">

Listing 6

</link>

.

</para>




	

<table id="table1005" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1005">

			

<row id="tr1010">



<entry id="th1005">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. The GM01.Line3D.draw method. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1005">

			

<row id="tr1011">

				

<entry id="td1005">

				

<code id="pre1006" display="block">    public void draw(Graphics2D g2D){
      
      //Get 2D projection coordinates.
      GM01.ColMatrix2D tail = 
                           convert3Dto2D(getTail().point);
      GM01.ColMatrix2D head = 
                           convert3Dto2D(getHead().point);

      drawLine(g2D,tail.getData(0),
                   tail.getData(1),
                   head.getData(0),
                   head.getData(1));
    }//end draw
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1112">
The code in 

<link id="a1140" target-id="Listing_6">

Listing 6

</link>

 is so similar to the code in 

<link id="a1141" target-id="Listing_5">

Listing 5

</link>

 that no 
	further explanation should be required.

</para>




<para id="p1113">
<emphasis id="strong1125" effect="bold">
Now back to the program named GM01test01

</emphasis>
</para>




<para id="p1114">
A complete listing of the program named 

<emphasis id="strong1126" effect="bold">
GM01test01

</emphasis>
 is provided in 


<link id="a1142" target-id="Listing_28">

Listing 28

</link>

 near the end of the module.

</para>




<para id="p1115">
Because all of the 3D classes in the game-math library are new to this 
update, I felt the need to write a program that would step through and test the 
behavior of most of the 3D methods in the library. That was the purpose of 
the program named 

<emphasis id="strong1127" effect="bold">
GM01test01

</emphasis>
.

</para>




<para id="p1116">
Like the program named 

<emphasis id="strong1128" effect="bold">
GM01test02

</emphasis>
 discussed earlier, this 
program produces both a graphic screen output and lots of text on the 
command-line screen. The graphic output is shown in 

<link id="a1143" target-id="Figure_1">

Figure 1

</link>

. I 
won't waste space printing the command-line output in this tutorial. If 
you want to see it, you can copy, compile, and run the program from 

<link id="a1144" target-id="Listing_28">

Listing 28

</link>

 
and produce that output yourself.

</para>




<para id="p1117">
<emphasis id="strong1129" effect="bold">
The graphic output

</emphasis>
</para>




<para id="p1118">
The graphic output shown in 

<link id="a1145" target-id="Figure_1">

Figure 1

</link>

 is produced by the method named 

<emphasis id="strong1130" effect="bold">

drawOffScreen

</emphasis>
, which begins in 

<link id="a1146" target-id="Listing_7">

Listing 7

</link>

. I will briefly walk you 
through this method because everything in it is new. However, much of the 
code is very similar to 2D code that I have explained before.

</para>




	

<table id="table1006" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1006">

			

<row id="tr1012">



<entry id="th1006">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

. Beginning of the drawOffScreen method in GM01test01. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1006">

			

<row id="tr1013">

				

<entry id="td1006">

				

<code id="pre1007" display="block">  void drawOffScreen(Graphics2D g2D){
    
    //Translate the origin on the off-screen
    // image and draw a pair of orthogonal axes on it.
    setCoordinateFrame(g2D);

    //Define eight points that define the corners of
    // a box in 3D that is centered on the origin.
    
    GM01.Point3D[] points = new GM01.Point3D[8];
    //Right side
    points[0] = 
         new GM01.Point3D(new GM01.ColMatrix3D(75,75,75));
    points[1] = 
        new GM01.Point3D(new GM01.ColMatrix3D(75,75,-75));
    points[2] = 
       new GM01.Point3D(new GM01.ColMatrix3D(75,-75,-75));
    points[3] = 
        new GM01.Point3D(new GM01.ColMatrix3D(75,-75,75));
    //Left side
    points[4] = 
        new GM01.Point3D(new GM01.ColMatrix3D(-75,75,75));
    points[5] = 
       new GM01.Point3D(new GM01.ColMatrix3D(-75,75,-75));
    points[6] = 
      new GM01.Point3D(new GM01.ColMatrix3D(-75,-75,-75));
    points[7] = 
       new GM01.Point3D(new GM01.ColMatrix3D(-75,-75,75));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1119">
After translating the origin to the center of the off-screen image, 
	

<link id="a1147" target-id="Listing_7">

Listing 7

</link>

 instantiates eight 

<emphasis id="strong1131" effect="bold">
GM01Point3D

</emphasis>
 objects that define the 
	corners of the 3D box shown in 

<link id="a1148" target-id="Figure_1">

Figure 1

</link>

. References to the eight 
	objects are stored in the elements of an array object referred to by the 
	variable named 

<emphasis id="strong1132" effect="bold">
points

</emphasis>
. Although this code uses three coordinate 
	values instead of two coordinate values to instantiate the objects, the 
	syntax should be very familiar to you by now.

</para>




<para id="p1120">
<emphasis id="strong1133" effect="bold">
Project eight points onto the 2D plane and draw them

</emphasis>
</para>




<para id="p1121">
<link id="a1149" target-id="Listing_8">

Listing 8

</link>

 calls the 

<emphasis id="strong1134" effect="bold">
GM01.Point3D.draw

</emphasis>
 method eight times in succession 
to cause the locations of the eight points in 3D space to be projected onto the 
2D off-screen image and to draw the points as small circles on that image. 
This is the first 

<emphasis id="em1029" effect="italics">
draw

</emphasis>
 method from the


<link id="a1150" target-id="following_list">

earlier list

</link>

 that I explained above.

</para>




	

<table id="table1007" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1007">

			

<row id="tr1014">



<entry id="th1007">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

. Project eight points onto the 2D plane and draw them. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1007">

			

<row id="tr1015">

				

<entry id="td1007">

				

<code id="pre1008" display="block">    //Draw seven of the points in BLACK
    g2D.setColor(Color.BLACK);
    for(int cnt = 1;cnt &lt; points.length;cnt++){
      points[cnt].draw(g2D);
    }//end for loop
    
    //Draw the right top front point in RED to identify
    // it.
    g2D.setColor(Color.RED);
    points[0].draw(g2D);
    g2D.setColor(Color.BLACK);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1122">
Seven of the points are drawn in BLACK and one is drawn in RED. The 
	eight small circles appear at the corners of the box in 

<link id="a1151" target-id="Figure_1">

Figure 1

</link>

. 

</para>




<para id="p1123">
As indicated in the comments, the RED point is drawn at the right top front 
corner of the box to help you get the orientation of the box correct in your 
mind's eye.

</para>




<para id="p1124">
<emphasis id="strong1135" effect="bold">
Draw twelve lines that connect the corners of the box

</emphasis>
</para>




<para id="p1125">
<link id="a1152" target-id="Listing_9">

Listing 9

</link>

 calls the 

<emphasis id="strong1136" effect="bold">
GM01.Line3D.draw

</emphasis>
 method twelve times in succession 
to project the lines that connect the corners of the 3D box onto the 2D 
off-screen image and to draw those lines on that image. This is the second


<emphasis id="em1030" effect="italics">
draw

</emphasis>
 method from the 

<link id="a1153" target-id="following_list">

earlier list

</link>

 
that I explained above.

</para>




	

<table id="table1008" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1008">

			

<row id="tr1016">



<entry id="th1008">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

. Draw twelve lines that connect the corners of the box. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1008">

			

<row id="tr1017">

				

<entry id="td1008">

				

<code id="pre1009" display="block">    //Draw lines that connect the points to define the
    // twelve edges of the box.
    //Right side
    new GM01.Line3D(points[0],points[1]).draw(g2D);
    new GM01.Line3D(points[1],points[2]).draw(g2D);
    new GM01.Line3D(points[2],points[3]).draw(g2D);
    new GM01.Line3D(points[3],points[0]).draw(g2D);
    
    //Left side
    new GM01.Line3D(points[4],points[5]).draw(g2D);
    new GM01.Line3D(points[5],points[6]).draw(g2D);
    new GM01.Line3D(points[6],points[7]).draw(g2D);
    new GM01.Line3D(points[7],points[4]).draw(g2D);
    
    //Front
    new GM01.Line3D(points[0],points[4]).draw(g2D);
    new GM01.Line3D(points[3],points[7]).draw(g2D);
    
    //Back
    new GM01.Line3D(points[1],points[5]).draw(g2D);
    new GM01.Line3D(points[2],points[6]).draw(g2D);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1126">
<emphasis id="strong1137" effect="bold">
Instantiate and draw a GM01.Vector3D object onto the 2D off-screen 
	image

</emphasis>
</para>




<para id="p1127">
<link id="a1154" target-id="Listing_10">

Listing 10

</link>

 instantiates an object of the 

<emphasis id="strong1138" effect="bold">
GM01.Vector3D

</emphasis>
 class and calls 
the 

<emphasis id="strong1139" effect="bold">
draw

</emphasis>
 method of that class to draw the magenta vector shown in 


<link id="a1155" target-id="Figure_1">

Figure 1

</link>

.

</para>




	

<table id="table1009" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1009">

			

<row id="tr1018">



<entry id="th1009">
<emphasis id="Listing_10" effect="bold">

Listing 10

</emphasis>

. Instantiate and draw a GM01.Vector3D object onto the 2D off-screen image. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1009">

			

<row id="tr1019">

				

<entry id="td1009">

				

<code id="pre1010" display="block">    //Instantiate a vector.
    GM01.Vector3D vecA = new GM01.Vector3D(
                        new GM01.ColMatrix3D(75,-75,-75));
                        
    //Draw the vector with its tail at the upper-left
    // corner of the box. The length and direction of the
    // vector will cause its head to be at the origin.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,points[4]);

  }//end drawOffScreen
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1128">
This is the third and final 

<emphasis id="em1031" effect="italics">
draw

</emphasis>
 method from the
	

<link id="a1156" target-id="following_list">

earlier list

</link>

 that I explained 
	above. The vector was drawn with its tail at the upper left corner of 
	the box. The length and direction of the vector were such as to cause 
	the head of the vector to be at the origin in 3D space.

</para>




<para id="p1129">
<emphasis id="strong1140" effect="bold">
Draw the 3D axes

</emphasis>
</para>




<para id="p1130">
The red, green, and blue 3D axes shown in 

<link id="a1157" target-id="Figure_1">

Figure 1

</link>

 were produced by the call 
to the 

<emphasis id="strong1141" effect="bold">
setCoordinateFrame

</emphasis>
 method early in 

<link id="a1158" target-id="Listing_7">

Listing 7

</link>

. The 

<emphasis id="strong1142" effect="bold">

setCoordinateFrame 

</emphasis>
method is shown in 

<link id="a1159" target-id="Listing_11">

Listing 11

</link>

.

</para>





	

<table id="table1010" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1010">

			

<row id="tr1020">



<entry id="th1010">
<emphasis id="Listing_11" effect="bold">

Listing 11

</emphasis>

. The setCoordinateFrame method. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1010">

			

<row id="tr1021">

				

<entry id="td1010">

				

<code id="pre1011" display="block">  private void setCoordinateFrame(Graphics2D g2D){

    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.Point3D pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(-75,0,0));
    GM01.Point3D pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(75,0,0));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,-75,0));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,75,0));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw z-axis in BLUE
    g2D.setColor(Color.BLUE);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,0,-75));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,0,75));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1131">
This method is used to set the origin of the off-screen image. It 
	also projects orthogonal 3D axes onto the 2D off-screen image and draws the 
	projected axes on that image. The axes intersect at the origin in 3D 
	space.

</para>




<para id="p1132">
The lengths of the axes are set so as to match the interior dimensions of the 
box shown in 

<link id="a1160" target-id="Figure_1">

Figure 1

</link>

 and points are drawn where the axes intersect the surfaces 
of the box. That was done to enhance the optical illusion of a 3D object on a 2D 
plane.

</para>




<para id="p1133">
There is nothing in 

<link id="a1161" target-id="Listing_11">

Listing 11

</link>

 that you haven's seen before, so further 
explanation should not be required.

</para>




<para id="p1134">
<emphasis id="strong1143" effect="bold">
End of discussion

</emphasis>
</para>




<para id="p1135">
That concludes the discussion of the program named 

<emphasis id="strong1144" effect="bold">
GM01test01

</emphasis>
. 
You can view the code that was not discussed here in 

<link id="a1162" target-id="Listing_28">

Listing 28

</link>

 near the end of 
the module.

</para>




</section>
</section>
<section id="h21004">
<title>
<emphasis id="The_program_named_GM01test05_" effect="bold">

The program named GM01test05

</emphasis>


</title>




<para id="p1136">
In an earlier module, you learned how to add two or more vectors in 2D. 
This program will show you how to use the updated game-math library to add 
vectors in 3D. You also learned about the 2D parallelogram rule and the 2D 
head-to-tail rule in the earlier module. This program will illustrate that 
those rules also apply to the addition of 3D vectors.

</para>




<para id="p1137">
<link id="a1163" target-id="Figure_4">

Figure 4

</link>

 shows the graphic output produced by this program. 

</para>




<para id="p1138">
<emphasis id="Figure_4" effect="bold">


<emphasis id="strong1145" effect="bold">
Figure 4

</emphasis>
</emphasis>


<emphasis id="strong1146" effect="bold">
 Graphic output from the program named GM01test05.

</emphasis>
</para>




<para id="p1139">
<media id="media1002" alt="Missing image." display="block">
<image id="img1002" mime-type="image/jpeg" src="../../media/java1710a3.jpg" width="301" height="201"/>
</media>


</para>




<para id="p1140">
This output shows the addition of a magenta vector to a light gray vector to 
produce a black vector as the sum of the other two vectors. As you can 
see, both the parallelogram rule and the head-to-tail rule are illustrated by 
the graphic output in 

<link id="a1164" target-id="Figure_4">

Figure 4

</link>

.

</para>




<para id="p1141">
<emphasis id="strong1147" effect="bold">
Very familiar code

</emphasis>
</para>




<para id="p1142">
Most of the code in this program will be very familiar to you by now. 
The new code is mostly contained in the method named 

<emphasis id="strong1148" effect="bold">
drawOffScreen

</emphasis>
, which 
is shown in 

<link id="a1165" target-id="Listing_12">

Listing 12

</link>

. A complete listing of this program is provided in 


<link id="a1166" target-id="Listing_29">

Listing 29

</link>

 near the end of the module.

</para>





	

<table id="table1011" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1011">

			

<row id="tr1022">



<entry id="th1011">
<emphasis id="Listing_12" effect="bold">

Listing 12

</emphasis>

. The drawOffScreen method of the program named GM01test05. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1011">

			

<row id="tr1023">

				

<entry id="td1011">

				

<code id="pre1012" display="block">  //The purpose of this method is to illustrate vector
  // addition in 3D
  void drawOffScreen(Graphics2D g2D){
    
    //Translate the origin on the off-screen image, draw a
    // pair of orthogonal axes on it that intersect at the
    // origin, and paint the background white.
    setCoordinateFrame(g2D);
    
    //Define two vectors that will be added.
    GM01.Vector3D vecA = new GM01.Vector3D(
                         new GM01.ColMatrix3D(75,75,75));
                        
    GM01.Vector3D vecB = new GM01.Vector3D(
                        new GM01.ColMatrix3D(-15,10,-50));
                        
    //Create a ref point at the origin for convenience.
    GM01.Point3D zeroPoint = new GM01.Point3D(
                             new GM01.ColMatrix3D(0,0,0));
                        
    //Draw vecA in MAGENTA with its tail at the origin.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,zeroPoint);
    
    //Draw vecB in LIGHT_GRAY with its tail at the head
    // of vecA.
    g2D.setColor(Color.LIGHT_GRAY);
    GM01.Point3D temp = 
                    new GM01.Point3D(vecA.getColMatrix());
    vecB.draw(g2D,temp);
    
    //Draw vecB in LIGHT_GRAY with its tail at the origin.
    vecB.draw(g2D,zeroPoint);
    
    //Draw vecA in MAGENTA with its tail at the head
    // of vecB. This completes a trapezoid.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,new GM01.Point3D(vecB.getColMatrix()));
    
    //Add the two vectors.
    GM01.Vector3D sum = vecA.add(vecB);
    //Draw sum in BLACK with its tail at the origin.
    g2D.setColor(Color.BLACK);
    sum.draw(g2D,zeroPoint);

  }//end drawOffScreen
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1143">
At this point, you should not find any code in 

<link id="a1167" target-id="Listing_12">

Listing 12

</link>

 that you don't 
	understand. I have explained the code in 

<link id="a1168" target-id="Listing_12">

Listing 12

</link>

 earlier in this 
	module or in an earlier module, so I won't repeat that explanation here.

</para>




<para id="p1144">
<emphasis id="strong1149" effect="bold">
End of discussion

</emphasis>
. 

</para>




<para id="p1145">
That concludes the discussion of the program named 

<emphasis id="strong1150" effect="bold">
GM01test05

</emphasis>
. 
You will find a complete listing of this program in 

<link id="a1169" target-id="Listing_29">

Listing 29

</link>

.

</para>




</section>
<section id="h21005">
<title>
<emphasis id="The_program_named_GM01test06" effect="bold">

The program named GM01test06

</emphasis>


</title>




<para id="p1146">
<emphasis id="strong1151" effect="bold">
Scaling, translation, and rotation of a point

</emphasis>
</para>




<para id="p1147">
Three of the most common and important operations that you will encounter in 
game programming will be to scale, translate, and/or rotate a geometric object.

</para>




<para id="p1148">
Since all geometric objects are composed of points that define the vertices, 
possibly embellished with lines, shading, lighting, etc., if you know how to 
scale, translate, and/or rotate a point, you also know how to scale, translate, 
and/or rotate the entire geometric object. You simply apply the required 
operation to all of the points that comprise the object and you will have 
applied the operation to the object as a whole.

</para>




<para id="p1149">
However, there are some complex issues associated with hiding the back faces 
of a rotated object, which will be addressed in a future module under the 
general topic of 

<emphasis id="em1032" effect="italics">
backface culling

</emphasis>
. Backface culling is a process by 
which you prevent 3D objects from appearing to be transparent.

</para>







	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1152" effect="bold">
Homogeneous Coordinates:

</emphasis>

				

<para id="p1150">
In a future module, we will learn about a mathematical trick commonly known as homogeneous coordinates that can simplify the scaling, translation, and rotation of a point.  However, that will have to wait until we have a better grasp of matrix arithmetic.

</para>


				

</note>

			


		



	



	


<para id="p1151">
In a previous module, you 
learned how to translate a geometric object. In this program, you will 
learn how to scale a geometric object. In the next two programs, you will 
learn how to rotate geometric objects.

</para>



	
	

<para id="p1152">
<emphasis id="strong1153" effect="bold">
The new scaling methods

</emphasis>
</para>




<para id="p1153">
The additions to the game-math library included the following two methods:

</para>




<list id="ul1017" list-type="bulleted">

	

<item id="li1135">
GM01.Point2D.scale

</item>


	

<item id="li1136">
GM01.Point3D.scale

</item>




</list>




<para id="p1154">
As the names imply, these two methods can be used to scale a point in either 
2D or 3D.

</para>




<para id="p1155">
<emphasis id="strong1154" effect="bold">
The game-math library method named GM01.Point3D.scale

</emphasis>
</para>




<para id="p1156">
This method is shown in 

<link id="a1170" target-id="Listing_13">

Listing 13

</link>

.

</para>




	

<table id="table1012" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1012">

			

<row id="tr1024">



<entry id="th1012">
<emphasis id="Listing_13" effect="bold">

Listing 13

</emphasis>

. The game-math library method named GM01.Point3D.scale.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1012">

			

<row id="tr1025">

				

<entry id="td1012">

				

<code id="pre1013" display="block">    public GM01.Point3D scale(GM01.ColMatrix3D scale){
      return new GM01.Point3D(new ColMatrix3D(
                          getData(0) * scale.getData(0),
                          getData(1) * scale.getData(1),
                          getData(2) * scale.getData(2)));
    }//end scale
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1157">
This method multiplies each coordinate value of the 

<emphasis id="strong1155" effect="bold">
Point3D

</emphasis>
 object 
	on which the method is called by the corresponding values in an incoming 

<emphasis id="strong1156" effect="bold">

	ColMatrix3D

</emphasis>
 object to produce and return a new 

<emphasis id="strong1157" effect="bold">
Point3D

</emphasis>
 object. 
	This makes it possible to scale each coordinate value that defines the 
	location in space by a different scale factor.

</para>




<para id="p1158">
If a scale factor for a particular coordinate is less than 1.0 but greater 
than 0.0, the location of the new point will be closer to the origin along that 
axis than was the location of the original point. If a scale factor is 
greater than 1.0, the new point will be further from the origin along that axis. 
If the scale factor is negative, the location of the new point will be on the 
other side of the origin along the same axis.

</para>




<para id="p1159">
<emphasis id="strong1158" effect="bold">
Graphic output from the program named GM01test06

</emphasis>
</para>




<para id="p1160">
The graphic output from the program named 

<emphasis id="strong1159" effect="bold">
GM01test06

</emphasis>
 is shown in 


<link id="a1171" target-id="Figure_5">

Figure 5

</link>

. Compare this with the graphic output from the program named 

<emphasis id="strong1160" effect="bold">

GM01test01

</emphasis>
 shown in 

<link id="a1172" target-id="Figure_1">

Figure 1

</link>

.

</para>




<para id="p1161">
<emphasis id="Figure_5" effect="bold">


<emphasis id="strong1161" effect="bold">
Figure 5

</emphasis>
</emphasis>


<emphasis id="strong1162" effect="bold">
 Graphic output from the program named GM01test06.

</emphasis>
</para>




<para id="p1162">
<media id="media1003" alt="Missing image." display="block">
<image id="img1003" mime-type="image/jpeg" src="../../media/java1710a4.jpg" width="401" height="401"/>
</media>


</para>




<para id="p1163">
<emphasis id="strong1163" effect="bold">
Modifications to the original program

</emphasis>
</para>




<para id="p1164">
The program named 

<emphasis id="strong1164" effect="bold">
GM01test06

</emphasis>
, shown in 

<link id="a1173" target-id="Listing_30">

Listing 30

</link>

, modifies the 
earlier program named 

<emphasis id="strong1165" effect="bold">
GM01test01

</emphasis>
 in three different ways to demonstrate 
the effects of scaling points in 3D.

</para>




<list id="ol1000" list-type="enumerated">

	

<item id="li1137">
Each 

<emphasis id="strong1166" effect="bold">
GM01Point3D

</emphasis>
 object that defines a corner of the box was 
	scaled by a 

<emphasis id="strong1167" effect="bold">
ColMatrix3D

</emphasis>
 object containing the values 0.25, 0.5, and 
	0.75. Thus, the overall size of the box was reduced in comparison with the 
	box in shown 

<link id="a1174" target-id="Figure_1">

Figure 1

</link>

.

</item>


	

<item id="li1138">
Each of the red, green, and blue points on the axes was scaled by 0.25, 
	0.5, or 0.75 respectively to cause the locations of those points to continue 
	to be where the axes intersect the surface of the box.

</item>


	

<item id="li1139">
The magenta vector shown in 

<link id="a1175" target-id="Figure_1">

Figure 1

</link>

 was removed from the program 
	because it didn't contribute to the objective of illustrating the scaling of 
	a geometric object.

</item>




</list>




<para id="p1165">
These modifications are so straightforward that no explanation of the actual 
code is justified. You can view the modifications in 

<link id="a1176" target-id="Listing_30">

Listing 30

</link>

.

</para>




<para id="p1166">
<emphasis id="strong1168" effect="bold">
End of discussion

</emphasis>
. 

</para>




<para id="p1167">
That concludes the discussion of the program named 

<emphasis id="strong1169" effect="bold">
GM01test06

</emphasis>
. 
You will find a complete listing of this program in 

<link id="a1177" target-id="Listing_30">

Listing 30

</link>

.

</para>




</section>
<section id="h21006">
<title>
<emphasis id="The_program_named_StringArt02_" effect="bold">

The program named StringArt02

</emphasis>


</title>




<para id="p1168">
Things are about to get a lot more interesting. This program and the 
one following it both deal with the 

<emphasis id="em1033" effect="italics">
rotation

</emphasis>
 of geometric objects, which 
is a relatively complex topic.

</para>




<para id="p1169">
In this program, I will teach you how to use the new 

<emphasis id="strong1170" effect="bold">
GM01.Point2D.rotate

</emphasis>
 
method to rotate objects in 2D space. In the next program, I will teach 
you how to use the new 

<emphasis id="strong1171" effect="bold">
GM01.Point3D.rotate

</emphasis>
 method to rotate objects in 3D 
space.

</para>




<para id="p1170">
Rotation is 3D space is much more complicated than rotation in 2D space, so I 
will begin my explanation of this topic with the simpler of the two programs.

</para>




<para id="p1171">
<emphasis id="strong1172" effect="bold">
Equations for rotating an object in 2D space

</emphasis>
</para>




<para id="p1172">
Once again, we have some equations to deal with, and once we understand the 
equations, the required code is tedious, but not terribly difficult to write. 
The new game-math library method named 

<emphasis id="strong1173" effect="bold">
GM01.Point2D.rotate

</emphasis>
, which begins 
in 

<link id="a1178" target-id="Listing_14">

Listing 14

</link>

, implements the required equations for rotating an object in 2D 
space.

</para>





	

<table id="table1013" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1013">

			

<row id="tr1026">



<entry id="th1013">
<emphasis id="Listing_14" effect="bold">

Listing 14

</emphasis>

. Beginning of the game-math library method named GM01.Point2D.rotate. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1013">

			

<row id="tr1027">

				

<entry id="td1013">

				

<code id="pre1014" display="block">    public GM01.Point2D rotate(GM01.Point2D anchorPoint,
                               double angle){
      GM01.Point2D newPoint = this.clone();
      
      double tempX ;
      double tempY;
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1173">
The purpose of the 

<emphasis id="strong1174" effect="bold">
GM01.Point2D.rotate

</emphasis>
 method is to rotate a point 
	around a specified 

<emphasis id="em1034" effect="italics">
anchor point

</emphasis>
 in the x-y plane. The location 
	of the anchor point is passed in as a reference to an object of the class 

<emphasis id="strong1175" effect="bold">

	GM01.Point2D

</emphasis>
. The rotation angle is passed in as a 

<emphasis id="strong1176" effect="bold">
double

</emphasis>
 
	value in degrees with the positive angle of rotation being 
	counter-clockwise.

</para>




<para id="p1174">
<emphasis id="strong1177" effect="bold">
Does not modify the original Point 2D object

</emphasis>
</para>




<para id="p1175">
This method does not modify the contents of the original 

<emphasis id="strong1178" effect="bold">
Point2D

</emphasis>
 
object on which the method is called. Rather, it uses the contents of that 
object to instantiate, rotate, and return a new 

<emphasis id="strong1179" effect="bold">
Point2D

</emphasis>
 object, leaving 
the original object intact.

</para>




<para id="p1176">
<emphasis id="strong1180" effect="bold">
Equations for rotating an object in 2D space

</emphasis>
</para>




<para id="p1177">
By using the information on the 

<emphasis id="em1035" effect="italics">



<link id="a1179" url="http://www.ia.hiof.no/~borres/cgraph/math/threed/p-threed.html">

Spatial 
transformations

</link>


</emphasis>
 web page along with other information on the web, we can 
conclude that the equations required to rotate a point around the origin in 2D 
space are shown in 

<link id="a1180" target-id="Figure_6">

Figure 6

</link>

.

</para>




	

<table id="table1014" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1014">

			

<row id="tr1028">



<entry id="th1014">
<emphasis id="Figure_6" effect="bold">

Figure 6

</emphasis>

. Rotation equations for a point in 2D space. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1014">

			

<row id="tr1029">

				

<entry id="td1014">

							

<code id="pre1015" display="block">x2 = x1*cos(alpha) - y1*sin(alpha)
y2 = x1*sin(alpha) + y1*cos(alpha)
</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1178">
I won't attempt to derive or justify these equations. I will simply 
	use them. If you need more information on the topic, simply Google 

<emphasis id="em1036" effect="italics">
2D transform

</emphasis>
s and you 
will probably find more information than you have the time to read.

</para>




<para id="p1179">
In 

<link id="a1181" target-id="Figure_6">

Figure 6

</link>

, the coordinates of the original point are given by 

<emphasis id="strong1181" effect="bold">
x1

</emphasis>
 and


<emphasis id="strong1182" effect="bold">
y1

</emphasis>
, and the coordinates of the rotated point are given by 

<emphasis id="strong1183" effect="bold">
x2

</emphasis>
 and


<emphasis id="strong1184" effect="bold">
y2

</emphasis>
. The angle 

<emphasis id="strong1185" effect="bold">
alpha

</emphasis>
 is a counter-clockwise angle around the 
origin.

</para>




<para id="p1180">
<emphasis id="strong1186" effect="bold">
Houston, we have a problem

</emphasis>
</para>




<para id="p1181">
We still have a problem however. The equations in 

<link id="a1182" target-id="Figure_6">

Figure 6

</link>

 are for 
rotating a point around the origin. Our objective is to rotate a point 
around any arbitrary 

<emphasis id="em1037" effect="italics">
anchor point

</emphasis>
 in 2D space.

</para>




<para id="p1182">
We could probably modify the equations in 

<link id="a1183" target-id="Figure_6">

Figure 6

</link>

 to accomplish this. 
However, there is another way, which is easier to implement. It can be 
shown that the same objective can be achieved by translating the anchor point to 
the origin, rotating the object around the origin, and then translating the 
rotated object back to the anchor point. Since we already know how to 
translate a point in 2D space, this is the approach that we will use.

</para>




<para id="p1183">
<emphasis id="strong1187" effect="bold">
You must be very careful

</emphasis>
</para>




<para id="p1184">
I do want to point out, however, that you really have to think about what you 
are doing when you rotate geometric objects, particularly when you combine 
rotation with translation. For example, rotating an object around the 
origin and then translating it does not produce the same result as translating 
the object and then rotating the translated object around the origin.

</para>




<para id="p1185">
<emphasis id="strong1188" effect="bold">
Clone the original Point2D object

</emphasis>
</para>




<para id="p1186">
<link id="a1184" target-id="Listing_14">

Listing 14

</link>

 begins by calling the new 

<emphasis id="strong1189" effect="bold">
GM01.Point2D.clone

</emphasis>
 method to 
create a clone of the object on which the rotate method was called. The 
clone, referred to by 

<emphasis id="strong1190" effect="bold">
newPoint

</emphasis>
, will be rotated and returned, thus 
preserving the original object.

</para>




<para id="p1187">
Following that, 

<link id="a1185" target-id="Listing_14">

Listing 14

</link>

 declares working variables that will be used 
later.

</para>




<para id="p1188">
<emphasis id="strong1191" effect="bold">
Incoming parameters

</emphasis>
</para>




<para id="p1189">
The 

<emphasis id="strong1192" effect="bold">
GM01.Point2D.rotate

</emphasis>
 method in 

<link id="a1186" target-id="Listing_14">

Listing 14

</link>

 requires two 
incoming parameters. The first parameter is a reference to a 

<emphasis id="strong1193" effect="bold">

GM01.Point2D

</emphasis>
 
object that specifies the anchor point around which the geometric object is to 
be rotated. The second parameter is the rotation angle in degrees, 
counter-clockwise around the origin.

</para>




<para id="p1190">
<emphasis id="strong1194" effect="bold">
Translate the anchor point to the origin

</emphasis>
</para>




<para id="p1191">
<link id="a1187" target-id="Listing_15">

Listing 15

</link>

 gets a 

<emphasis id="strong1195" effect="bold">
Vector2D

</emphasis>
 object that represents the displacement 
vector from the origin to the anchor point.

</para>




	

<table id="table1015" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1015">

			

<row id="tr1030">



<entry id="th1015">
<emphasis id="Listing_15" effect="bold">

Listing 15

</emphasis>

. Translate the anchor point to the origin. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1015">

			

<row id="tr1031">

				

<entry id="td1015">

				

<code id="pre1016" display="block">      GM01.Vector2D tempVec = 
            new GM01.Vector2D(anchorPoint.getColMatrix());
      newPoint = 
              newPoint.addVectorToPoint(tempVec.negate());
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1192">
The negative of the displacement vector is used to translate the clone
	

<emphasis id="em1038" effect="italics">
(

</emphasis>
<emphasis id="strong1196" effect="bold">
<emphasis id="em1039" effect="italics">
newPoint

</emphasis>
</emphasis>
) object, thus translating the anchor 
	point to the origin.

</para>




<para id="p1193">
<emphasis id="strong1197" effect="bold">
Rotate the translated newPoint object around the origin

</emphasis>
</para>




<para id="p1194">
<link id="a1188" target-id="Listing_16">

Listing 16

</link>

 implements the two rotation equations shown in 

<link id="a1189" target-id="Figure_6">

Figure 6

</link>

 to rotate 
the translated 

<emphasis id="strong1198" effect="bold">
newPoint

</emphasis>
 object around the origin.

</para>





	

<table id="table1016" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1016">

			

<row id="tr1032">



<entry id="th1016">
<emphasis id="Listing_16" effect="bold">

Listing 16

</emphasis>

. Rotate the translated newPoint object around the origin. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1016">

			

<row id="tr1033">

				

<entry id="td1016">

				

<code id="pre1017" display="block">      tempX = newPoint.getData(0);
      tempY = newPoint.getData(1);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(angle*Math.PI/180) -
                      tempY*Math.sin(angle*Math.PI/180));

      newPoint.setData(//new y coordinate
                      1,
                      tempX*Math.sin(angle*Math.PI/180) +
                      tempY*Math.cos(angle*Math.PI/180));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1195">
Note that the rotation angle is converted from degrees to radians to make 
	it compatible with the sin and cos functions from the standard Java Math 
	library.

</para>




<para id="p1196">
<emphasis id="strong1199" effect="bold">
Translate the rotated newPoint object back to the anchor point

</emphasis>
</para>




<para id="p1197">
Finally, 

<link id="a1190" target-id="Listing_17">

Listing 17

</link>

 uses the displacement vector that was created and saved 
earlier to translate the rotated 

<emphasis id="strong1200" effect="bold">
newPoint

</emphasis>
 object back to the anchor 
point.

</para>





	

<table id="table1017" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1017">

			

<row id="tr1034">



<entry id="th1017">
<emphasis id="Listing_17" effect="bold">

Listing 17

</emphasis>

. Translate the rotated newPoint object back to the anchor point. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1017">

			

<row id="tr1035">

				

<entry id="td1017">

				

<code id="pre1018" display="block">      //Translate back to anchorPoint
      newPoint = newPoint.addVectorToPoint(tempVec);
      
      return newPoint;

    }//end rotate
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1198">
Then 

<link id="a1191" target-id="Listing_17">

Listing 17

</link>

 returns a reference to the rotated 

<emphasis id="strong1201" effect="bold">
newPoint

</emphasis>
 
	object.

</para>




<para id="p1199">
<emphasis id="strong1202" effect="bold">
Now back to the program named StringArt02

</emphasis>
</para>




<para id="p1200">
This is a 2D version of a string art program that supports rotation in two 
dimensions. This program produces a 2D string art image by connecting 
various points that are equally spaced on the circumference of a circle as shown 
in 

<link id="a1192" target-id="Figure_7">

Figure 7

</link>

.

</para>




<para id="p1201">
<emphasis id="Figure_7" effect="bold">


<emphasis id="strong1203" effect="bold">
Figure 7

</emphasis>
</emphasis>


<emphasis id="strong1204" effect="bold">
 Initial graphic output from the program named StringArt02.

</emphasis>
</para>




<para id="p1202">
<media id="media1004" alt="Missing image." display="block">
<image id="img1004" mime-type="image/jpeg" src="../../media/java1710a5.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1203">
<emphasis id="strong1205" effect="bold">
Initial conditions

</emphasis>
</para>




<para id="p1204">
Initially, the circle is centered on the origin and there are six points on 
the circle connected by lines forming a hexagon. The lines that connect 
the points are different colors. The radius of the circle is 50 units. 
The points at the vertices of the hexagon are not drawn, but the lines that 
connect the vertices are drawn. The anchor point is drawn in black, 
resulting in the small black circle at the origin in 

<link id="a1193" target-id="Figure_7">

Figure 7

</link>

.

</para>




<para id="p1205">
<emphasis id="strong1206" effect="bold">
A graphical user interface

</emphasis>
</para>




<para id="p1206">
A GUI is provided that allows the user to specify the following items and 
click a 

<emphasis id="strong1207" effect="bold">
Replot

</emphasis>
 button to cause the drawing to change:

</para>




<list id="ul1018" list-type="bulleted">

	

<item id="li1140">
Number Points

</item>


	

<item id="li1141">
Number Loops

</item>


	

<item id="li1142">
Rotation angle (deg)

</item>


	

<item id="li1143">
X anchor point

</item>


	

<item id="li1144">
Y anchor point

</item>




</list>




<para id="p1207">
Changing the number of points causes the number of vertices that describe the 
geometric object to change. Changing the number of loops causes the number 
of lines that are drawn to connect the vertices to change. 

</para>




<para id="p1208">
For a value of 1, each vertex is connected to the one next to it. For a 
value of 2, additional lines are drawn connecting every other vertex. For 
a value of 3, additional lines are drawn connecting every third vertex as shown 
in 

<link id="a1194" target-id="Figure_8">

Figure 8

</link>

.

</para>




<para id="p1209">
<emphasis id="Figure_8" effect="bold">


<emphasis id="strong1208" effect="bold">
</emphasis>
</emphasis>


<emphasis id="strong1209" effect="bold">
Figure 8 Graphic output from the program named StringArt02 with Loops set to 3.

</emphasis>
</para>




<para id="p1210">
<media id="media1005" alt="Missing image." display="block">
<image id="img1005" mime-type="image/jpeg" src="../../media/java1710a6.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1211">
<emphasis id="strong1210" effect="bold">
Rotating the geometric object around the origin

</emphasis>
</para>




<para id="p1212">
The geometric object can be rotated around an anchor point. Entering a 
non-zero value in the 

<emphasis id="strong1211" effect="bold">
Rotation

</emphasis>
 field causes the geometric object to be 
rotated by the specified angle around the anchor point.

</para>




<para id="p1213">
The anchor point 
is initially located at the origin, but the location of the anchor point can be 
changed by the user. If the anchor point is at the origin, the geometric 
object is rotated around the origin as shown in 

<link id="a1195" target-id="Figure_9">

Figure 9

</link>

. 

<emphasis id="em1040" effect="italics">
(Compare the 
colors and the locations of the vertices in 

<link id="a1196" target-id="Figure_8">

Figure 8

</link>

 and 

<link id="a1197" target-id="Figure_9">

Figure 9

</link>

 to discern the 
result of the rotation in 

<link id="a1198" target-id="Figure_9">

Figure 9

</link>

.)

</emphasis>
</para>




<para id="p1214">
<emphasis id="Figure_9" effect="bold">


<emphasis id="strong1212" effect="bold">
Figure 9

</emphasis>
</emphasis>


<emphasis id="strong1213" effect="bold">
 Rotation by 30 degrees around the origin.

</emphasis>
</para>




<para id="p1215">
<media id="media1006" alt="Missing image." display="block">
<image id="img1006" mime-type="image/jpeg" src="../../media/java1710a7.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1216">
<emphasis id="strong1214" effect="bold">
Rotating the geometric object around an anchor point away from the origin

</emphasis>
</para>




<para id="p1217">
<link id="a1199" target-id="Figure_10">

Figure 10

</link>

 shows the result of rotating the geometric object by 90 degrees around an anchor 
point that is not located at the origin.

</para>




<para id="p1218">
<emphasis id="Figure_10" effect="bold">


<emphasis id="strong1215" effect="bold">
Figure 10

</emphasis>
</emphasis>


<emphasis id="strong1216" effect="bold">
 Rotation around an anchor point that is not at the origin.

</emphasis>
</para>




<para id="p1219">
<media id="media1007" alt="Missing image." display="block">
<image id="img1007" mime-type="image/jpeg" src="../../media/java1710a8.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1220">
The rotation angle is specified in degrees with a positive angle being 
counter-clockwise. For 

<link id="a1200" target-id="Figure_10">

Figure 10

</link>

, I purposely located the anchor point at the 
upper-right vertex in 

<link id="a1201" target-id="Figure_8">

Figure 8

</link>

 and rotated the geometric object by 90 degrees 
around that anchor point. Compare 

<link id="a1202" target-id="Figure_10">

Figure 10

</link>

 with 

<link id="a1203" target-id="Figure_8">

Figure 8

</link>

 to see the result of 
rotating the geometric object around the anchor point.

</para>




<para id="p1221">
<emphasis id="strong1217" effect="bold">
Rotating around an anchor point further out in space

</emphasis>
</para>




<para id="p1222">
In 

<link id="a1204" target-id="Figure_11">

Figure 11

</link>

, I moved the anchor point further out in space, but still on a 
line that runs through the origin and the upper-right vertex in 

<link id="a1205" target-id="Figure_8">

Figure 8

</link>

. Then I 
rotated the geometric object by 30 degrees around the anchor point.

</para>




<para id="p1223">
<emphasis id="em1041" effect="italics">
(Note that the rotation examples in these images are not cumulative. In 
other words, each rotation is relative to an un-rotated object at the origin.)

</emphasis>
</para>




<para id="p1224">
<emphasis id="Figure_11" effect="bold">


<emphasis id="strong1218" effect="bold">
Figure 11

</emphasis>
</emphasis>


<emphasis id="strong1219" effect="bold">
 Rotation around a point further out in space.

</emphasis>
</para>




<para id="p1225">
<media id="media1008" alt="Missing image." display="block">
<image id="img1008" mime-type="image/jpeg" src="../../media/java1710a9.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1226">
By now, you should have been able to predict in advance what you would see 
when the program was run with these parameters.

</para>




<para id="p1227">
<emphasis id="strong1220" effect="bold">
Let's see some code

</emphasis>
</para>




<para id="p1228">
Given what you have already learned, the only interesting new code in this 
program is in the 

<emphasis id="strong1221" effect="bold">
drawOffScreen

</emphasis>
 method. An abbreviated listing of that 
method is shown in 

<link id="a1206" target-id="Listing_18">

Listing 18

</link>

. A complete listing of the 

<emphasis id="strong1222" effect="bold">
StringArt02

</emphasis>
 
program is provided in 

<link id="a1207" target-id="Listing_31">

Listing 31

</link>

 near the end of the module.

</para>





	

<table id="table1018" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1018">

			

<row id="tr1036">



<entry id="th1018">
<emphasis id="Listing_18" effect="bold">

Listing 18

</emphasis>

. Abbreviated listing of the drawOffScreen method. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1018">

			

<row id="tr1037">

				

<entry id="td1018">



<code id="pre1019" display="block">  void drawOffScreen(Graphics2D g2D){
    setCoordinateFrame(g2D,false);

    //Create a set of Point2D objects that specify
    // locations on the circumference of a circle that
    // is in the x-y plane with a radius of 50 units. Save
    // references to the Point2D objects in an array.
    for(int cnt = 0;cnt &lt; numberPoints;cnt++){
      points[cnt] = new GM01.Point2D(new GM01.ColMatrix2D(
        50*Math.cos((cnt*360/numberPoints)*Math.PI/180),
        50*Math.sin((cnt*360/numberPoints)*Math.PI/180)));
     
      //The following object is populated with the 2D 
      // coordinates of the point around which the 
      //rotations will take place.
      GM01.Point2D anchorPoint = new GM01.Point2D(
                            new GM01.ColMatrix2D(
                              xAnchorPoint,yAnchorPoint));
      //Draw the anchorPoint in BLACK.
      g2D.setColor(Color.BLACK);
      anchorPoint.draw(g2D);
      
      //The following statement causes the rotation to be 
      //performed.
      points[cnt] = 
                 points[cnt].rotate(anchorPoint,rotation);

    }//end for loop
    
//Code deleted for brevity

  }//end drawOffScreen
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1229">
Within the method named 

<emphasis id="strong1223" effect="bold">
drawOffScreen

</emphasis>
, the only really interesting 
	code is the statement that calls the 

<emphasis id="strong1224" effect="bold">
rotate

</emphasis>
 method of the game-math 
	library on each 

<emphasis id="strong1225" effect="bold">
Point2D

</emphasis>
 object inside a 

<emphasis id="strong1226" effect="bold">
for

</emphasis>
 loop. Knowing what 
	you do about the 

<emphasis id="strong1227" effect="bold">
rotate

</emphasis>
 method, you should have no problem 
	understanding the code in 

<link id="a1208" target-id="Listing_18">

Listing 18

</link>

.

</para>




<para id="p1230">
<emphasis id="strong1228" effect="bold">
End of the discussion

</emphasis>
</para>




<para id="p1231">
That concludes the discussion of the program named 

<emphasis id="strong1229" effect="bold">
StringArt02

</emphasis>
. You 
will find a complete listing of this program in 

<link id="a1209" target-id="Listing_31">

Listing 31

</link>

.

</para>




</section>
<section id="h21007">
<title>
<emphasis id="The_program_named_StringArt03_" effect="bold">

The program named StringArt03

</emphasis>


</title>




<para id="p1232">
I saved the best for last, or at least I saved the most difficult program 
until last. In this program, I will teach you how to use the new 

<emphasis id="strong1230" effect="bold">

GM01.Point3D.rotate

</emphasis>
 method to rotate objects in 3D space.

</para>




<para id="p1233">
Not only is the code for doing rotations in 3D space much more complicated 
than the rotation code in 2D, it is also more difficult to examine the graphic 
output produced by rotating an object in 3D space and be certain that the 
program is working as it should. Therefore, we need to start this discussion 
with an explanation of the game-math library method named 

<emphasis id="strong1231" effect="bold">
GM01.Point3D.rotate

</emphasis>
. 
Before we can get to that method, however, we must deal with the rotation 
equations for rotation of a point in 3D space.

</para>




<para id="p1234">
<emphasis id="strong1232" effect="bold">
The six 3D rotation equations

</emphasis>
</para>




<para id="p1235">
Unlike with 2D rotation where things were less complicated, we now have to 
deal with three coordinate values, three rotation angles, and six equations. 
Using the 

<emphasis id="em1042" effect="italics">



<link id="a1210" url="http://www.ia.hiof.no/~borres/cgraph/math/threed/p-threed.html">

Spatial 
Transformations

</link>


</emphasis>
 webpage and other online material as well, we can 
conclude that our 3D rotation method must implement the six equations shown in 


<link id="a1211" target-id="Figure_12">

Figure 12

</link>

.

</para>




	

<table id="table1019" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1019">

			

<row id="tr1038">



<entry id="th1019">
<emphasis id="Figure_12" effect="bold">

Figure 12

</emphasis>

. The six 3D rotation equations. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1019">

			

<row id="tr1039">

				

<entry id="td1019">



<code id="pre1020" display="block">Let rotation angle around z-axis be zAngle
Let rotation angle around z-axis be xAngle
Let rotation angle around z-axis be yAngle

Rotation around the z-axis
x2 = x1*cos(zAngle) - y1*sin(zAngle)
y2 = x1*sin(zAngle) + y1*cos(zAngle)

Rotation around the x-axis
y2 = y1*cos(xAngle) - z1*sin(xAngle)
z2 = y1*sin(xAngle) + z1* cos(xAngle) 

Rotation around the y-axis
x2 = x1*cos(yAngle) + z1*sin(yAngle)
z2 = -x1*sin(yAngle) + z1*cos(yAngle)

Where:
  x1, y1, and z1 are coordinates of original point
  x2, y2, and z2 are coordinates of rotated point
</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1236">
Also, as before, these six equations are only good for rotation around 
	the origin, but our objective is to be able to rotate a point about any 
	arbitrary anchor point in 3D space. Once again, we will use the trick of 
	translating the anchor point to the origin, rotating the object around the 
	origin, and then translating the object back to the anchor point.

</para>




<para id="p1237">
<emphasis id="strong1233" effect="bold">
Beginning of the method named GM01.Point3D.rotate

</emphasis>
</para>




<para id="p1238">
The method named 

<emphasis id="strong1234" effect="bold">
GM01.Point3D.rotate

</emphasis>
 begins in 

<link id="a1212" target-id="Listing_19">

Listing 19

</link>

.

</para>





	

<table id="table1020" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1020">

			

<row id="tr1040">



<entry id="th1020">
<emphasis id="Listing_19" effect="bold">

Listing 19

</emphasis>

. Beginning of the method named GM01.Point3D.rotate. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1020">

			

<row id="tr1041">

				

<entry id="td1020">



<code id="pre1021" display="block">    public GM01.Point3D </code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1239">
The purpose of this method is to rotate a point around a specified anchor 
	point in 3D space in the following order:

</para>




<list id="ul1019" list-type="bulleted">

	

<item id="li1145">
Rotate around z - rotation in x-y plane.

</item>


	

<item id="li1146">
Rotate around x - rotation in y-z plane.

</item>


	

<item id="li1147">
Rotate around y - rotation in x-z plane.

</item>




</list>








	

<note id="note1002" type="">


		


			


				

<emphasis id="strong1235" effect="bold">
A useful upgrade:

</emphasis>

				

<para id="p1240">
A useful upgrade to the game-math library might be to write three separate rotation methods, each designed to rotate a Point3D object around only one of the three axes.

</para>


				

</note>

			


		



	





<para id="p1241">
It is very important to understand that the order of the rotations is 
critical. You cannot change the order of rotations and expect to end up with the 
same results. This method is designed to allow you to rotate an object around 
all three axes with a single method call in the order given above. If you need 
to rotate your object in some different order, you should call the method up to 
three times in succession, rotating around only one axis with each call to the 
method.

</para>




<para id="p1242">
<emphasis id="strong1236" effect="bold">
Incoming parameters

</emphasis>
</para>




<para id="p1243">
The anchor point is passed in as a reference to an object of the 

<emphasis id="strong1237" effect="bold">

GM01.Point3D

</emphasis>
 class.

</para>




<para id="p1244">
The rotation angles are passed in as double values in degrees 

<emphasis id="em1043" effect="italics">
(based on 
the 

<link id="a1213" target-id="The_right-hand_rule">

right-hand rule

</link>

)

</emphasis>
 in the order given above, packaged in an object of the 
class 

<emphasis id="strong1238" effect="bold">
GM01.ColMatrix3D

</emphasis>
. 

</para>




<para id="p1245">
<emphasis id="em1044" effect="italics">
(Note that in this case, the 

<emphasis id="strong1239" effect="bold">
ColMatrix3D

</emphasis>
 
object is simply a convenient container for the three 

<emphasis id="strong1240" effect="bold">
double

</emphasis>
 angle values 
and it has no significance from a matrix arithmetic viewpoint. Also pay 
attention to the order of the three values and the rotation axes associated with 
those values. See 

<link id="a1214" target-id="Listing_20">

Listing 20

</link>

. It is z, x, y, and not x, y, z as you might assume.)

</emphasis>
</para>




<para id="p1246">
<emphasis id="strong1241" effect="bold">
<emphasis id="The_right-hand_rule" effect="bold">

The right-hand rule

</emphasis>


</emphasis>
</para>




<para id="p1247">
The right-hand rule states that if you point the thumb of your right hand in 
the positive direction of an axis and curl your fingers to make a fist, the 
direction of positive rotation around that axis is given by the direction that 
your fingers will be pointing.

</para>




<para id="p1248">
I will refer back to this rule later when describing rotations around various 
axes.

</para>




<para id="p1249">
<emphasis id="strong1242" effect="bold">
Original object is not modified

</emphasis>
</para>




<para id="p1250">
This method does not modify the contents of the 

<emphasis id="strong1243" effect="bold">
Point3D

</emphasis>
 object on 
which the method is called. Rather, it uses the contents of that object to 
instantiate, rotate, and return a new 

<emphasis id="strong1244" effect="bold">
Point3D

</emphasis>
 object.

</para>




<para id="p1251">
<emphasis id="strong1245" effect="bold">
Rotation around the anchor point

</emphasis>
</para>




<para id="p1252">
For simplicity, this method translates the anchor point to the origin, 
rotates around the origin, and then translates the object back to the anchor 
point.

</para>




<para id="p1253">
<emphasis id="strong1246" effect="bold">
Very familiar code

</emphasis>
</para>




<para id="p1254">
The code in 

<link id="a1215" target-id="Listing_19">

Listing 19

</link>

 is very similar to the code that I explained earlier 
beginning in 

<link id="a1216" target-id="Listing_14">

Listing 14

</link>

. Therefore, this code should not require an 
explanation beyond the embedded comments.

</para>




<para id="p1255">
<emphasis id="strong1247" effect="bold">
Get the rotation angle values

</emphasis>
</para>




<para id="p1256">
<link id="a1217" target-id="Listing_20">

Listing 20

</link>

 extracts the rotation angle values from the 

<emphasis id="strong1248" effect="bold">
GM01.ColMatrix3D

</emphasis>
 
object in which they are contained.

</para>





	

<table id="table1021" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1021">

			

<row id="tr1042">



<entry id="th1021">
<emphasis id="Listing_20" effect="bold">

Listing 20

</emphasis>

. Get the rotation angle values. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1021">

			

<row id="tr1043">

				

<entry id="td1021">



<code id="pre1022" display="block">      double zAngle = angles.getData(0);
      double xAngle = angles.getData(1);
      double yAngle = angles.getData(2);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1257">
<emphasis id="strong1249" effect="bold">
Rotate the Point3D object around the z-axis

</emphasis>
</para>




<para id="p1258">
By this point in the execution of the method, the object has been translated 
to the origin using the negative of the anchor-point displacement vector. The 
object will be rotated around the origin and will then be translated back to the 
anchor point.

</para>




<para id="p1259">
<link id="a1218" target-id="Listing_21">

Listing 21

</link>

 implements the first two equations from 

<link id="a1219" target-id="Figure_12">

Figure 12

</link>

 to rotate the 

<emphasis id="strong1250" effect="bold">

Point3D

</emphasis>
 object around the z-axis. By this, I mean that the object is rotated 
in a plane that is perpendicular to the z-axis modifying only x and y coordinate 
values from the object being rotated.

</para>





	

<table id="table1022" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1022">

			

<row id="tr1044">



<entry id="th1022">
<emphasis id="Listing_21" effect="bold">

Listing 21

</emphasis>

. Rotate the Point3D object around the z-axis. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1022">

			

<row id="tr1045">

				

<entry id="td1022">



<code id="pre1023" display="block">      //Rotate around z-axis
      tempX = newPoint.getData(0);
      tempY = newPoint.getData(1);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(zAngle*Math.PI/180) -
                      tempY*Math.sin(zAngle*Math.PI/180));

      newPoint.setData(//new y coordinate
                      1,
                      tempX*Math.sin(zAngle*Math.PI/180) +
                      tempY*Math.cos(zAngle*Math.PI/180));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1260">
This is the only rotation possibility in 2D rotation and the code in 
	

<link id="a1220" target-id="Listing_21">

Listing 21

</link>

 is essentially the same as the code in 

<link id="a1221" target-id="Listing_16">

Listing 16

</link>

 for 2D 
	rotation.

</para>




<para id="p1261">
<emphasis id="strong1251" effect="bold">
Rotate the Point 3D object around the x-axis

</emphasis>
</para>




<para id="p1262">
Before translating the partially rotated object back to the anchor point, it 
must still be rotated around the x and y-axes. 

<link id="a1222" target-id="Listing_22">

Listing 22

</link>

 implements the middle 
two equations in 

<link id="a1223" target-id="Figure_12">

Figure 12

</link>

 to rotate the 

<emphasis id="strong1252" effect="bold">
Point3D

</emphasis>
 object in a plane that 
is perpendicular to the x-axis, modifying only the y and z coordinate values.

</para>





	

<table id="table1023" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1023">

			

<row id="tr1046">



<entry id="th1023">
<emphasis id="Listing_22" effect="bold">

Listing 22

</emphasis>

. Rotate the Point3D object around the x-axis.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1023">

			

<row id="tr1047">

				

<entry id="td1023">



<code id="pre1024" display="block">      //Rotate around x-axis
      tempY = newPoint.getData(1);
      tempZ = newPoint.getData(2);
      newPoint.setData(//new y coordinate
                      1,
                      tempY*Math.cos(xAngle*Math.PI/180) -
                      tempZ*Math.sin(xAngle*Math.PI/180));

      newPoint.setData(//new z coordinate
                      2,
                      tempY*Math.sin(xAngle*Math.PI/180) +
                      tempZ*Math.cos(xAngle*Math.PI/180));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1263">
<emphasis id="strong1253" effect="bold">
Rotate the Point3D object around the y-axis

</emphasis>
</para>




<para id="p1264">
<link id="a1224" target-id="Listing_23">

Listing 23

</link>

 implements the last two equations in 

<link id="a1225" target-id="Figure_12">

Figure 12

</link>

 to rotate the 

<emphasis id="strong1254" effect="bold">

Point3D

</emphasis>
 object in a plane that is perpendicular to the y-axis, modifying 
only the x and z coordinate values.

</para>







	

<table id="table1024" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1024">

			

<row id="tr1048">



<entry id="th1024">
<emphasis id="Listing_23" effect="bold">

Listing 23

</emphasis>

. Rotate the Point3D object around the y-axis.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1024">

			

<row id="tr1049">

				

<entry id="td1024">



<code id="pre1025" display="block">      //Rotate around y-axis
      tempX = newPoint.getData(0);
      tempZ = newPoint.getData(2);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(yAngle*Math.PI/180) +
                      tempZ*Math.sin(yAngle*Math.PI/180));

      newPoint.setData(//new z coordinate
                     2,
                     -tempX*Math.sin(yAngle*Math.PI/180) +
                     tempZ*Math.cos(yAngle*Math.PI/180));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1265">
<emphasis id="strong1255" effect="bold">
Translate the object back to the anchor point

</emphasis>
</para>




<para id="p1266">
<link id="a1226" target-id="Listing_24">

Listing 24

</link>

 translates the rotated object back to the anchor point, thus 
completing the 3D rotation of a single 

<emphasis id="strong1256" effect="bold">
GM01.Point3D

</emphasis>
 object. 

</para>





	

<table id="table1025" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1025">

			

<row id="tr1050">



<entry id="th1025">
<emphasis id="Listing_24" effect="bold">

Listing 24

</emphasis>

. Translate the object back to the anchor point. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1025">

			

<row id="tr1051">

				

<entry id="td1025">



<code id="pre1026" display="block">      //Translate back to anchorPoint
      newPoint = newPoint.addVectorToPoint(tempVec);
      
      return newPoint;

    }//end rotate
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1267">
In order to rotate an entire 3D geometric object, such as the hexagon in 
	

<link id="a1227" target-id="Figure_13">

Figure 13

</link>

, every point that comprises the geometric object must be rotated 
	using the same set of rotation angles and the same anchor point.

</para>




<para id="p1268">
<emphasis id="strong1257" effect="bold">
Now back to the program named StringArt03

</emphasis>
</para>




<para id="p1269">
This is a 3D version of a string art program that demonstrates rotation in 
three dimensions. This program produces a 3D string-art image by connecting 
various points that are equally spaced on the circumference of a circle. 
Initially, the circle is on the x-y plane centered on the origin as shown in 


<link id="a1228" target-id="Figure_13">

Figure 13

</link>

.

</para>




<para id="p1270">
<emphasis id="Figure_13" effect="bold">


<emphasis id="strong1258" effect="bold">
Figure 13

</emphasis>
</emphasis>


<emphasis id="strong1259" effect="bold">
 Graphic output from the program named StringArt03 at startup.

</emphasis>
</para>




<para id="p1271">
<media id="media1009" alt="Missing image." display="block">
<image id="img1009" mime-type="image/jpeg" src="../../media/java1710b1.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1272">
At startup, there are six points 

<emphasis id="em1045" effect="italics">
(vertices)

</emphasis>
 on the circle connected by 
lines forming a hexagon. The lines that connect the points are different colors. 
The radius of the circle is 50 units. The points at the vertices of the hexagon 
are not drawn, but the lines that connect the vertices are drawn.

</para>




<para id="p1273">
You may have noticed that the startup graphic output in 

<link id="a1229" target-id="Figure_13">

Figure 13

</link>

 looks a lot 
like the startup graphic output of the 2D program in 

<link id="a1230" target-id="Figure_7">

Figure 7

</link>

. There is a 
significant difference however. 

<link id="a1231" target-id="Figure_7">

Figure 7

</link>

 shows only two orthogonal axes whereas 


<link id="a1232" target-id="Figure_13">

Figure 13

</link>

 shows three orthogonal axes using oblique parallel projection to 
transform the 3D image to a 2D display plane.

</para>




<para id="p1274">
<emphasis id="strong1260" effect="bold">
A graphical user interface

</emphasis>
</para>




<para id="p1275">
A GUI is provided that allows the user to specify the following items and 
click a 

<emphasis id="strong1261" effect="bold">
Replot

</emphasis>
 button to cause the drawing to change:

</para>




<list id="ul1020" list-type="bulleted">

	

<item id="li1148">
Number Points

</item>


	

<item id="li1149">
Number Loops

</item>


	

<item id="li1150">
Rotate around Z (deg)

</item>


	

<item id="li1151">
Rotate around X (deg)

</item>


	

<item id="li1152">
Rotate around Y (deg)

</item>


	

<item id="li1153">
X Anchor point

</item>


	

<item id="li1154">
Y Anchor point

</item>


	

<item id="li1155">
Z Anchor point

</item>




</list>




<para id="p1276">
Again, the 3D GUI in 

<link id="a1233" target-id="Figure_13">

Figure 13

</link>

 looks similar to the 2D GUI in 

<link id="a1234" target-id="Figure_7">

Figure 7

</link>

. The 
big difference is that the 2D GUI in 

<link id="a1235" target-id="Figure_7">

Figure 7

</link>

 allows only for rotation around 
one axis, and only two coordinate values can be specified for the location of 
the anchor point.

</para>




<para id="p1277">
As before, changing the number of points causes the number of vertices that 
describe the geometric object to change. Changing the number of loops causes the 
number of lines that are drawn to connect the vertices to change.

</para>




<para id="p1278">
The geometric object can be rotated in any or all of three dimensions around 
an anchor point. Entering a non-zero value in one or more of the 

<emphasis id="strong1262" effect="bold">
Rotate

</emphasis>
 
fields causes the object to be rotated by the specified angle or angles around 
the anchor point.

</para>




<para id="p1279">
The anchor point is initially specified to be at the origin, but the location 
of the anchor point can be changed by the user. If the anchor point is at the 
origin, the image is rotated around the origin.

</para>




<para id="p1280">
<emphasis id="strong1263" effect="bold">
Geometric object with 12 vertices, 4 loops, and no rotations

</emphasis>
</para>




<para id="p1281">
As a baseline case, 

<link id="a1236" target-id="Figure_14">

Figure 14

</link>

 shows the string-art geometric object with 12 
vertices, 4 loops, and no rotations. At this point, the geometric object is an 
infinitely thin disk in the x-y plane centered on the origin. Note the break in 
color between yellow and blue that occurs where the circle crosses the positive 
x-axis.

</para>




<para id="p1282">
<emphasis id="Figure_14" effect="bold">


<emphasis id="strong1264" effect="bold">
Figure 14

</emphasis>
</emphasis>


<emphasis id="strong1265" effect="bold">
 Geometric object with 12 vertices, 4 loops, and no rotations.

</emphasis>
</para>




<para id="p1283">
<media id="media1010" alt="Missing image." display="block">
<image id="img1010" mime-type="image/jpeg" src="../../media/java1710b2.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1284">
The rotation angle must be specified in degrees with a positive angle being 
given by the 

<link id="a1237" target-id="The_right-hand_rule">

right-hand rule

</link>

 as applied to 
the axis around which the image is being rotated.

</para>




<para id="p1285">
<emphasis id="strong1266" effect="bold">
Rotation around one axis only

</emphasis>
</para>




<para id="p1286">
<link id="a1238" target-id="Figure_15">

Figure 15

</link>

, 

<link id="a1239" target-id="Figure_16">

Figure 16

</link>

, and 

<link id="a1240" target-id="Figure_17">

Figure 17

</link>

 show the results of rotating the object 
around only one axis at a time with the anchor point at the origin. 

</para>




<para id="p1287">
<link id="a1241" target-id="Figure_15">

Figure 15

</link>

 
shows the result of rotating the object around the z-axis only by an angle of 60 
degrees.

</para>




<para id="p1288">
<emphasis id="Figure_15" effect="bold">


<emphasis id="strong1267" effect="bold">
Figure 15

</emphasis>
</emphasis>


<emphasis id="strong1268" effect="bold">
 Rotation around the z-axis only.

</emphasis>
</para>




<para id="p1289">
<media id="media1011" alt="Missing image." display="block">
<image id="img1011" mime-type="image/jpeg" src="../../media/java1710b3.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1290">
This results in the object still being in the x-y plane, but it has been 
rotated counter-clockwise by 60 degrees. Compare 

<link id="a1242" target-id="Figure_15">

Figure 15

</link>

 with 

<link id="a1243" target-id="Figure_14">

Figure 14

</link>

 and 
note how the color break between yellow and blue has moved around to be near the 
intersection of the circle and the positive y-axis.

</para>




<para id="p1291">
<emphasis id="strong1269" effect="bold">
Rotation around the x-axis only

</emphasis>
</para>




<para id="p1292">
<link id="a1244" target-id="Figure_16">

Figure 16

</link>

 shows the result of rotating the object around only the x-axis with 
a rotation angle of -60 degrees. 

</para>




<para id="p1293">
<emphasis id="Figure_16" effect="bold">


<emphasis id="strong1270" effect="bold">
Figure 16

</emphasis>
</emphasis>


<emphasis id="strong1271" effect="bold">
 Rotation around the x-axis only.

</emphasis>
</para>




<para id="p1294">
<media id="media1012" alt="Missing image." display="block">
<image id="img1012" mime-type="image/jpeg" src="../../media/java1710b4.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1295">
The object is still a disk, but that disk is no longer in the x-y plane. 
Instead, it has been tilted so that it is now closer to the x-z plane than to 
the x-y plane. Unfortunately, the oblique parallel projection does not make it 
practical to do any quantitative measurements on the image.

</para>




<para id="p1296">
<emphasis id="strong1272" effect="bold">
Rotation around the y-axis only

</emphasis>
</para>




<para id="p1297">
<link id="a1245" target-id="Figure_17">

Figure 17

</link>

 shows the result of rotating the object around only the y-axis with 
a rotation angle of -60 degrees.

</para>




<para id="p1298">
<emphasis id="Figure_17" effect="bold">


<emphasis id="strong1273" effect="bold">
Figure 17

</emphasis>
</emphasis>


<emphasis id="strong1274" effect="bold">
 Rotation around the y-axis only.

</emphasis>
</para>




<para id="p1299">
<media id="media1013" alt="Missing image." display="block">
<image id="img1013" mime-type="image/jpeg" src="../../media/java1710b5.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1300">
I will let you interpret what you see there.

</para>




<para id="p1301">
<emphasis id="strong1275" effect="bold">
Rotation around all three axes with the anchor point at the origin

</emphasis>
</para>




<para id="p1302">
When more than one rotation angle has a non-zero value, the rotational 
effects are cumulative. The object is first rotated around the anchor point in a 
direction consistent with rotation around the z-axis 

<emphasis id="em1046" effect="italics">
(rotation in the x-y 
plane)

</emphasis>
. Then that rotated object is rotated in a direction consistent with 
rotation around the x-axis 

<emphasis id="em1047" effect="italics">
(rotation in the y-z plane)

</emphasis>
. Finally, the 
previously rotated object is rotated in a direction consistent with rotation 
around the y-axis 

<emphasis id="em1048" effect="italics">
(rotation in the x-z plane)

</emphasis>
. It is important to note, 
however, that the actual rotation is around the anchor point and not around the 
origin unless the anchor point is at the origin.

</para>




<para id="p1303">
<link id="a1246" target-id="Figure_18">

Figure 18

</link>

 shows the result of applying all three of the rotations described 
above with the anchor point at the origin.

</para>




<para id="p1304">
<emphasis id="Figure_18" effect="bold">


<emphasis id="strong1276" effect="bold">
Figure 18

</emphasis>
</emphasis>


<emphasis id="strong1277" effect="bold">
 Rotation around all three axes with the anchor point at the origin.

</emphasis>
</para>




<para id="p1305">
<media id="media1014" alt="Missing image." display="block">
<image id="img1014" mime-type="image/jpeg" src="../../media/java1710b6.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1306">
Once again, I will let you interpret what you see there.

</para>




<para id="p1307">
<emphasis id="strong1278" effect="bold">
Perform all three rotations with the anchor point away from the origin

</emphasis>
</para>




<para id="p1308">
<link id="a1247" target-id="Figure_19">

Figure 19

</link>

 performs the same three rotations as were performed in 

<link id="a1248" target-id="Figure_18">

Figure 18

</link>

. 
However, in 

<link id="a1249" target-id="Figure_19">

Figure 19

</link>

, the anchor point was at a location defined by the 
coordinate values (50,50,50).

</para>




<para id="p1309">
<emphasis id="Figure_19" effect="bold">


<emphasis id="strong1279" effect="bold">
Figure 19

</emphasis>
</emphasis>


<emphasis id="strong1280" effect="bold">
 Perform all three rotations with the anchor point away from the origin.

</emphasis>
</para>




<para id="p1310">
<media id="media1015" alt="Missing image." display="block">
<image id="img1015" mime-type="image/jpeg" src="../../media/java1710b7.jpg" width="301" height="471"/>
</media>


</para>





<para id="p1311">
At the risk of being boring, I will state once again that I will let you 
interpret what you see there.

</para>




<para id="p1312">
<emphasis id="strong1281" effect="bold">
Will animate the process later

</emphasis>
</para>




<para id="p1313">
For me, at least, it isn't easy to visualize the process of rotating around 
an arbitrary anchor point in 3D. In a future module, I will animate the rotation 
process and run it in slow motion so that you can see the progress of each 
individual rotation from the beginning until the point where all three rotations 
are complete. Hopefully, that will make it easier to visualize rotation around 
an arbitrary anchor point in 3D. As a bonus, it will also give you some 
experience in using the game-math library for a non-trivial animation project.

</para>




<para id="p1314">
<emphasis id="strong1282" effect="bold">
Let's see some code

</emphasis>
</para>




<para id="p1315">
As was the case with the previous program, given what you have already 
learned, the only interesting new code in this program is in the 

<emphasis id="strong1283" effect="bold">

drawOffScreen

</emphasis>
 method. Furthermore, only a small portion of the code in that 
method is new and interesting. 

<link id="a1250" target-id="Listing_25">

Listing 25

</link>

 contains some code that was extracted 
from the 

<emphasis id="strong1284" effect="bold">
drawOffScreen

</emphasis>
 method.

</para>




<para id="p1316">
A complete listing of the program named 

<emphasis id="strong1285" effect="bold">
StringArt03 

</emphasis>
is provided in 


<link id="a1251" target-id="Listing_32">

Listing 32

</link>

.

</para>





	

<table id="table1026" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1026">

			

<row id="tr1052">



<entry id="th1026">
<emphasis id="Listing_25" effect="bold">

Listing 25

</emphasis>

. Interesting code from the drawOffScreen method. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1026">

			

<row id="tr1053">

				

<entry id="td1026">



<code id="pre1027" display="block">
    for(int cnt = 0;cnt &lt; numberPoints;cnt++){
      points[cnt] = new GM01.Point3D(
        new GM01.ColMatrix3D(
          50*Math.cos((cnt*360/numberPoints)*Math.PI/180),
          50*Math.sin((cnt*360/numberPoints)*Math.PI/180),
          0.0));

      //Populate a ColMatrix3D object with rotation values
      GM01.ColMatrix3D angles = new GM01.ColMatrix3D(
                           zRotation,xRotation,yRotation);
      
      //Populate a Point3D object with anchor point 
      // coordinates.
      GM01.Point3D anchorPoint = new GM01.Point3D(
               new GM01.ColMatrix3D(
                 xAnchorPoint,yAnchorPoint,zAnchorPoint));
      //Draw the anchorPoint in BLACK.
      g2D.setColor(Color.BLACK);
      anchorPoint.draw(g2D);
      
      //The following statement causes the rotation to be 
      //performed.
      points[cnt] = 
                   points[cnt].rotate(anchorPoint,angles);

    }//end for loop
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1317">
The only really interesting code in 

<link id="a1252" target-id="Listing_25">

Listing 25

</link>

 is the statement that 
	calls the 

<emphasis id="strong1286" effect="bold">
rotate

</emphasis>
 method of the game-math library on each 

<emphasis id="strong1287" effect="bold">
Point3D

</emphasis>
 
	object inside a 

<emphasis id="strong1288" effect="bold">
for

</emphasis>
 loop near the bottom of the listing. Knowing what 
	you do about the 

<emphasis id="strong1289" effect="bold">
rotate

</emphasis>
 
	method, you should have no problem understanding the code in 

<link id="a1253" target-id="Listing_25">

Listing 25

</link>

.

</para>




<para id="p1318">
<emphasis id="strong1290" effect="bold">
End of the discussion

</emphasis>
</para>




<para id="p1319">
That concludes the discussion of the program named 

<emphasis id="strong1291" effect="bold">
StringArt03

</emphasis>
. You 
will find a complete listing of this program in 

<link id="a1254" target-id="Listing_32">

Listing 32

</link>

.

</para>




</section>
</section>
<section id="h11005">
<title>
<emphasis id="Documentation_for_the_GM01_library" effect="bold">

Documentation 
for the GM01 library

</emphasis>


</title>




<para id="p1320">
Click 

<link id="a1255" url="GM01docs.zip">

here

</link>

 to download a zip file containing 
standard javadoc documentation for the library named 

<emphasis id="strong1292" effect="bold">
GM01

</emphasis>
. 
Extract the contents of the zip file into an empty folder and open the file 
named 

<emphasis id="strong1293" effect="bold">
index.html

</emphasis>
 in your browser to view the documentation.

</para>




<para id="p1321">
Although the documentation doesn't provide much in the way of explanatory 
text 

<emphasis id="em1049" effect="italics">
(see 

<link id="a1256" target-id="Listing_26">

Listing 26

</link>

 and the explanations given 
above)

</emphasis>
, the documentation does provide a good overview of the organization 
and structure of the library. You may find it helpful in that regard. 

</para>


	

</section>
<section id="h11006">
<title>
<emphasis id="Homework_assignment" effect="bold">

Homework assignment

</emphasis>


</title>




<para id="p1322">
The homework assignment for this module was to study the Kjell tutorial 
through 

<emphasis id="em1050" effect="italics">
Chapter6 - Scaling and Unit Vectors

</emphasis>
.

</para>




<para id="p1323">
The homework assignment for the next module is to continue studying the same 
material.

</para>




<para id="p1324">
In addition to studying the Kjell material, you should read at least the next 
two modules in this collection and bring your questions about that material to 
the next classroom session.

</para>




<para id="p1325">
Finally, you should have begun studying the


<link id="a1257" url="http://cnx.org/content/m44992/latest/">

physics material

</link>

 at the 
beginning of the semester and you should continue studying one physics module 
per week thereafter. You should also feel free to bring your questions about 
that material to the classroom for discussion. 

</para>






</section>
<section id="h11007">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the programs

</emphasis>


</title>






<para id="p1326">
I encourage you to copy the code from 

<link id="a1258" target-id="Listing_26">

Listing 26

</link>

 through 

<link id="a1259" target-id="Listing_32">

Listing 32

</link>

. Compile the code and 
execute it in conjunction with the game-math library provided in


<link id="a1260" target-id="Listing_26">

Listing 26

</link>

. Experiment with the code, 
making changes, and observing the results of your changes. Make certain that you 
can explain why your changes behave as they do.

</para>


	

</section>
<section id="h11008">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1327">
The most important thing that you learned in this module was how to update 
the game-math library to support 3D math and how to produce 3D images similar to 
that shown in 

<link id="a1261" target-id="Figure_1">

Figure 1

</link>

. You learned much more than that however. Some highlights 
of the things you learned are:

</para>




<list id="ul1021" list-type="bulleted">

	

<item id="li1156">
You learned how to program the equations for projecting a 3D world onto 
	a 2D plane for display on a computer screen.

</item>


	

<item id="li1157">
You learned how to cause the direction of the positive y-axis to be up 
	the screen instead of down the screen.

</item>


	

<item id="li1158">
You learned how to add vectors in 3D and confirmed that the head-to-tail 
	and parallelogram rules apply to 3D as well as to 2D.

</item>


	

<item id="li1159">
You learned about scaling, translation, and rotation of a point in both 
	2D and 3D.

</item>


	

<item id="li1160">
You learned about the rotation equations and how to implement them in 
	both 2D and 3D.

</item>


	

<item id="li1161">
You learned how to rotate a point around an anchor point other than the 
	origin.

</item>


	

<item id="li1162">
You learned about the right-hand rule.

</item>




</list>




</section>
<section id="h11009">
<title>
<emphasis id="Whats_next" effect="bold">

What's next?

</emphasis>


</title>




<para id="p1328">
In the next module in this collection, you will learn how to write your first 
interactive 3D game using the game-math library. You will also learn how to 
write a Java program that simulates flocking behavior such as that exhibited by 
birds and fish and how to incorporate that behavior into a game.

</para>


	

</section>
<section id="h11010">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1329">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1003" type="">


		


			


				

<emphasis id="strong1294" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1022" list-type="bulleted">

					

<item id="li1163">
Module name: GAME 2302-0135: Venturing into a 3D World

</item>


					

<item id="li1164">
File: Game135.htm


</item>


					

<item id="li1165">
Published: 10/18/12

</item>


					

<item id="li1166">
Revised: 02/01/16

</item>


				

</list>


				

</note>

			


		



	






	

<note id="note1004" type="">


		


			


				

<emphasis id="strong1295" effect="bold">
Disclaimers:

</emphasis>
<para id="p1330">
<emphasis id="strong1296" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>


				

<para id="p1331">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>


				

<para id="p1332">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>


				

<para id="p1333">
<emphasis id="strong1297" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>


				

</note>

			


		



	





</section>
<section id="h11011">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1334">
Complete listings of the programs discussed in this module are shown in 


<link id="a1262" target-id="Listing_26">

Listing 26

</link>

 through 

<link id="a1263" target-id="Listing_32">

Listing 32

</link>

 below.

</para>





<para id="p1335">
<emphasis id="strong1298" effect="bold">
<emphasis id="Listing_26" effect="bold">

Listing 26

</emphasis>

. Source code for the updated game-math library named GM01.

</emphasis>
</para>





<code id="pre1028" display="block">/*GM01.java 
Copyright 2008, R.G.Baldwin
Revised 02/24/08

This is a major upgrade to the game-math library. This
version upgrades the version named GM2D04 to a new version
named simply GM01.

The primary purpose of the upgrade was to add 3D 
capability for all of the 2D features provided by the
previous version. Because both 2D and 3D capabilities
are included, it is no longer necessary to differentiate
between the two in the name of the class. Therefore, this
version is named GM01.

Adding 3D capability entailed major complexity in one
particular area: drawing the objects. It is difficult to
draw a 3D object on a 2D screen. This requires a 
projection process to project each point in the 3D object
onto the correct location on a 2D plane. There are a 
variety of ways to do this. This 3D library uses an
approach often referred to as an oblique parallel
projection. See the following URL for technical 
information on the projection process:

http://local.wasp.uwa.edu.au/~pbourke/geometry/
classification/


In addition to adding 3D capability, this version also
eliminates the confusion surrounding the fact that the
default direction of the positive y-axis is going down
the screen instead of up the screen as viewers have become
accustomed to. When you use this library, you can program
under the assumption that the positive direction of the
y-axis is up the screen, provided you funnel all of your
drawing tasks through the library and don't draw
directly on the screen.

The name GMnn is an abbreviation for GameMathnn.

See the file named GM2D01.java for a general description 
of the game-math library. The library has been updated
several times. This file is an update of GM2D04.

In addition to the updates mentioned above, this update
cleaned up some lingering areas of code inefficiency,
using the simplest available method to draw on an 
off-screen image. In addition, the following new methods 
were added:

The following methods are new static methods of the class
named GM01. The first method in the list deals with the
problem of displaying a 3D image on a 3D screen.

The last five methods in the list wrap the standard 
graphics methods for the purpose of eliminating the issue 
of the direction of the positive Y-axis.

GM01.convert3Dto2D
GM01.translate
GM01.drawLine
GM01.fillOval
GM01.drawOval
GM01.fillRect

The following methods are new instance methods of the 
indicated static top-level classes belonging to the class
named GM01.

GM01.Vector2D.scale
GM01.Vector2D.negate
GM01.Point2D.clone
GM01.Vector2D.normalize
GM01.Point2D.rotate
GM01.Point2D.scale

GM01.Vector3D.scale
GM01.Vector3D.negate
GM01.Point3D.clone
GM01.Vector3D.normalize
GM01.Point3D.rotate
GM01.Point3D.scale

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.geom.*;
import java.awt.*;

public class GM01{
  //----------------------------------------------------//
  
  //This method converts a ColMatrix3D object to a
  // ColMatrix2D object. The purpose is to accept
  // x, y, and z coordinate values and transform those
  // values into a pair of coordinate values suitable for
  // display in two dimensions.
  //See http://local.wasp.uwa.edu.au/~pbourke/geometry/
  // classification/ for technical background on the
  // transform from 3D to 2D.
  //The transform equations are:
  // x2d = x3d + z3d * cos(theta)/tan(alpha)
  // y2d = y3d + z3d * sin(theta)/tan(alpha);
  //Let theta = 30 degrees and alpha = 45 degrees
  //Then:cos(theta) = 0.866
  //     sin(theta) = 0.5
  //     tan(alpha) = 1;
  //Note that the signs in the above equations depend
  // on the assumed directions of the angles as well as
  // the assumed positive directions of the axes. The
  // signs used in this method assume the following:
  //   Positive x is to the right.
  //   Positive y is up the screen.
  //   Positive z is protruding out the front of the
  //     screen.
  //   The viewing position is above the x axis and to the
  //     right of the z-y plane.
  public static GM01.ColMatrix2D convert3Dto2D(
                                   GM01.ColMatrix3D data){
    return new GM01.ColMatrix2D(
                  data.getData(0) - 0.866*data.getData(2),
                  data.getData(1) - 0.50*data.getData(2));
  }//end convert3Dto2D 
  //----------------------------------------------------//
  
  //This method wraps around the translate method of the
  // Graphics2D class. The purpose is to cause the
  // positive direction for the y-axis to be up the screen
  // instead of down the screen. When you use this method,
  // you should program as though the positive direction
  // for the y-axis is up.
  public static void translate(Graphics2D g2D,
                               double xOffset,
                               double yOffset){
    //Flip the sign on the y-coordinate to change the
    // direction of the positive y-axis to go up the
    // screen.
    g2D.translate(xOffset,-yOffset);
  }//end translate
  //----------------------------------------------------//
  
  //This method wraps around the drawLine method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void drawLine(Graphics2D g2D,
                              double x1,
                              double y1,
                              double x2,
                              double y2){
    //Flip the sign on the y-coordinate value.
    g2D.drawLine((int)x1,-(int)y1,(int)x2,-(int)y2);
  }//end drawLine
  //----------------------------------------------------//
  
  //This method wraps around the fillOval method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void fillOval(Graphics2D g2D,
                              double x,
                              double y,
                              double width,
                              double height){
    //Flip the sign on the y-coordinate value.
    g2D.fillOval((int)x,-(int)y,(int)width,(int)height);
  }//end fillOval
  //----------------------------------------------------//

  //This method wraps around the drawOval method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void drawOval(Graphics2D g2D,
                              double x,
                              double y,
                              double width,
                              double height){
    //Flip the sign on the y-coordinate value.
    g2D.drawOval((int)x,-(int)y,(int)width,(int)height);
  }//end drawOval
  //----------------------------------------------------//
  
  //This method wraps around the fillRect method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void fillRect(Graphics2D g2D,
                              double x,
                              double y,
                              double width,
                              double height){
    //Flip the sign on the y-coordinate value.
    g2D.fillRect((int)x,-(int)y,(int)width,(int)height);
  }//end fillRect
  //----------------------------------------------------//
  
  

  //An object of this class represents a 2D column matrix.
  // An object of this class is the fundamental building
  // block for several of the other classes in the
  // library.
  public static class ColMatrix2D{
    double[] data = new double[2];
    
    public ColMatrix2D(double data0,double data1){
      data[0] = data0;
      data[1] = data1;
    }//end constructor
    //--------------------------------------------------//
    
    //Overridden toString method.
    public String toString(){
      return data[0] + "," + data[1];
    }//end overridden toString method
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return data[index];
      }//end else
    }//end getData method
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        this.data[index] = data;
      }//end else
    }//end setData method
    //--------------------------------------------------//
    
    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in two matrices and returns true if the
    // values are equal or almost equal and returns false
    // otherwise. 
    public boolean equals(Object obj){
      if(obj instanceof GM01.ColMatrix2D &amp;&amp;
         Math.abs(((GM01.ColMatrix2D)obj).getData(0) - 
                                 getData(0)) &lt;= 0.00001 &amp;&amp;
         Math.abs(((GM01.ColMatrix2D)obj).getData(1) - 
                                  getData(1)) &lt;= 0.00001){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Adds one ColMatrix2D object to another ColMatrix2D
    // object, returning a ColMatrix2D object.
    public GM01.ColMatrix2D add(GM01.ColMatrix2D matrix){
      return new GM01.ColMatrix2D(
                            getData(0)+matrix.getData(0),
                            getData(1)+matrix.getData(1));
    }//end add
    //--------------------------------------------------//
    
    //Subtracts one ColMatrix2D object from another
    // ColMatrix2D object, returning a ColMatrix2D object.
    // The object that is received as an incoming
    // parameter  is subtracted from the object on which
    // the method is called.
    public GM01.ColMatrix2D subtract(
                                 GM01.ColMatrix2D matrix){
      return new GM01.ColMatrix2D(
                            getData(0)-matrix.getData(0),
                            getData(1)-matrix.getData(1));
    }//end subtract
    //--------------------------------------------------//
  }//end class ColMatrix2D
  //====================================================//


  //An object of this class represents a 3D column matrix.
  // An object of this class is the fundamental building
  // block for several of the other classes in the
  // library.
  public static class ColMatrix3D{
    double[] data = new double[3];
    
    public ColMatrix3D(
                  double data0,double data1,double data2){
      data[0] = data0;
      data[1] = data1;
      data[2] = data2;
    }//end constructor
    //--------------------------------------------------//
    
    public String toString(){
      return data[0] + "," + data[1] + "," + data[2];
    }//end overridden toString method
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return data[index];
      }//end else
    }//end getData method
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        this.data[index] = data;
      }//end else
    }//end setData method
    //--------------------------------------------------//
    
    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in two matrices and returns true if the
    // values are equal or almost equal and returns false
    // otherwise. 
    public boolean equals(Object obj){
      if(obj instanceof GM01.ColMatrix3D &amp;&amp;
         Math.abs(((GM01.ColMatrix3D)obj).getData(0) - 
                                 getData(0)) &lt;= 0.00001 &amp;&amp;
         Math.abs(((GM01.ColMatrix3D)obj).getData(1) - 
                                 getData(1)) &lt;= 0.00001 &amp;&amp;
         Math.abs(((GM01.ColMatrix3D)obj).getData(2) - 
                                  getData(2)) &lt;= 0.00001){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Adds one ColMatrix3D object to another ColMatrix3D
    // object, returning a ColMatrix3D object.
    public GM01.ColMatrix3D add(GM01.ColMatrix3D matrix){
      return new GM01.ColMatrix3D(
                            getData(0)+matrix.getData(0),
                            getData(1)+matrix.getData(1),
                            getData(2)+matrix.getData(2));
    }//end add
    //--------------------------------------------------//
    
    //Subtracts one ColMatrix3D object from another
    // ColMatrix3D object, returning a ColMatrix3D object.
    // The object that is received as an incoming
    // parameter is subtracted from the object on which
    // the method is called.
    public GM01.ColMatrix3D subtract(
                                 GM01.ColMatrix3D matrix){
      return new GM01.ColMatrix3D(
                            getData(0)-matrix.getData(0),
                            getData(1)-matrix.getData(1),
                            getData(2)-matrix.getData(2));
    }//end subtract
    //--------------------------------------------------//
  }//end class ColMatrix3D
  //====================================================//
  //====================================================//


  public static class Point2D{
    GM01.ColMatrix2D point;
    
    public Point2D(GM01.ColMatrix2D point){//constructor
      //Create and save a clone of the ColMatrix2D object
      // used to define the point to prevent the point
      // from being corrupted by a later change in the
      // values stored in the original ColMatrix2D object
      // through use of its set method.
      this.point = new ColMatrix2D(
                       point.getData(0),point.getData(1));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return point.getData(0) + "," + point.getData(1);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return point.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        point.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//

    //This method draws a small circle around the location
    // of the point on the specified graphics context.
    public void draw(Graphics2D g2D){
      drawOval(g2D,getData(0)-3,
                   getData(1)+3,6,6);
    }//end draw

    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix2D object that
    // defines this Point2D object.
    public GM01.ColMatrix2D getColMatrix(){
      return point;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix2D objects that define two
    // Point2D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(point.equals(((GM01.Point2D)obj).
                                         getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Gets a displacement vector from one Point2D object
    // to a second Point2D object. The vector points from
    // the object on which the method is called to the
    // object passed as a parameter to the method. Kjell
    // describes this as the distance you would have to
    // walk along the x and then the y axes to get from
    // the first point to the second point.
    public GM01.Vector2D getDisplacementVector(
                                      GM01.Point2D point){
      return new GM01.Vector2D(new GM01.ColMatrix2D(
                            point.getData(0)-getData(0),
                            point.getData(1)-getData(1)));
    }//end getDisplacementVector
    //--------------------------------------------------//
    
    //Adds a Vector2D to a Point2D producing a
    // new Point2D.
    public GM01.Point2D addVectorToPoint(
                                      GM01.Vector2D vec){
      return new GM01.Point2D(new GM01.ColMatrix2D(
                          getData(0) + vec.getData(0),
                          getData(1) + vec.getData(1)));
    }//end addVectorToPoint
    //--------------------------------------------------//
    
    //Returns a new Point2D object that is a clone of
    // the object on which the method is called.
    public Point2D clone(){
      return new Point2D(
                  new ColMatrix2D(getData(0),getData(1)));
    }//end clone
    //--------------------------------------------------//
    
    //The purpose of this method is to rotate a point
    // around a specified anchor point in the x-y plane.
    //The rotation angle is passed in as a double value
    // in degrees with the positive angle of rotation
    // being counter-clockwise.
    //This method does not modify the contents of the
    // Point2D object on which the method is called.
    // Rather, it uses the contents of that object to
    // instantiate, rotate, and return a new Point2D
    // object.
    //For simplicity, this method translates the
    // anchorPoint to the origin, rotates around the
    // origin, and then translates back to the
    // anchorPoint.
    /*
    See http://www.ia.hiof.no/~borres/cgraph/math/threed/
    p-threed.html for a definition of the equations
    required to do the rotation.

    x2 = x1*cos - y1*sin
    y2 = x1*sin + y1*cos
    */ 
    public GM01.Point2D rotate(GM01.Point2D anchorPoint,
                               double angle){
      GM01.Point2D newPoint = this.clone();
      
      double tempX ;
      double tempY;
 
      //Translate anchorPoint to the origin
      GM01.Vector2D tempVec = 
            new GM01.Vector2D(anchorPoint.getColMatrix());
      newPoint = 
              newPoint.addVectorToPoint(tempVec.negate());
      
      //Rotate around the origin.
      tempX = newPoint.getData(0);
      tempY = newPoint.getData(1);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(angle*Math.PI/180) -
                      tempY*Math.sin(angle*Math.PI/180));

      newPoint.setData(//new y coordinate
                      1,
                      tempX*Math.sin(angle*Math.PI/180) +
                      tempY*Math.cos(angle*Math.PI/180));

      //Translate back to anchorPoint
      newPoint = newPoint.addVectorToPoint(tempVec);
      
      return newPoint;

    }//end rotate
    //--------------------------------------------------//
    
    //Multiplies this point by a scaling matrix received
    // as an incoming parameter and returns the scaled
    // point.
    public GM01.Point2D scale(GM01.ColMatrix2D scale){
      return new GM01.Point2D(new ColMatrix2D(
                          getData(0) * scale.getData(0),
                          getData(1) * scale.getData(1)));
    }//end scale
    //--------------------------------------------------//
  }//end class Point2D
  //====================================================//


  public static class Point3D{
    GM01.ColMatrix3D point;
    
    public Point3D(GM01.ColMatrix3D point){//constructor
      //Create and save a clone of the ColMatrix3D object
      // used to define the point to prevent the point
      // from being corrupted by a later change in the
      // values stored in the original ColMatrix3D object
      // through use of its set method.
      this.point = 
         new ColMatrix3D(point.getData(0),
                         point.getData(1),
                         point.getData(2));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return point.getData(0) + "," + point.getData(1) 
                                 + "," + point.getData(2);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return point.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        point.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//

    //This method draws a small circle around the location
    // of the point on the specified graphics context.
    public void draw(Graphics2D g2D){
      
      //Get 2D projection coordinate values.
      ColMatrix2D temp = convert3Dto2D(point);
      drawOval(g2D,temp.getData(0)-3,
                   temp.getData(1)+3,
                   6,
                   6);
    }//end draw
    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix3D object that
    // defines this Point3D object.
    public GM01.ColMatrix3D getColMatrix(){
      return point;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix3D objects that define two
    // Point3D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(point.equals(((GM01.Point3D)obj).
                                         getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Gets a displacement vector from one Point3D object
    // to a second Point3D object. The vector points from
    // the object on which the method is called to the
    // object passed as a parameter to the method. Kjell
    // describes this as the distance you would have to
    // walk along the x and then the y axes to get from
    // the first point to the second point.
    public GM01.Vector3D getDisplacementVector(
                                      GM01.Point3D point){
      return new GM01.Vector3D(new GM01.ColMatrix3D(
                            point.getData(0)-getData(0),
                            point.getData(1)-getData(1),
                            point.getData(2)-getData(2)));
    }//end getDisplacementVector
    //--------------------------------------------------//
    
    //Adds a Vector3D to a Point3D producing a
    // new Point3D.
    public GM01.Point3D addVectorToPoint(
                                      GM01.Vector3D vec){
      return new GM01.Point3D(new GM01.ColMatrix3D(
                          getData(0) + vec.getData(0),
                          getData(1) + vec.getData(1),
                          getData(2) + vec.getData(2)));
    }//end addVectorToPoint
    //--------------------------------------------------//
    
    //Returns a new Point3D object that is a clone of
    // the object on which the method is called.
    public Point3D clone(){
      return new Point3D(new ColMatrix3D(getData(0),
                                         getData(1),
                                         getData(2)));
    }//end clone
    //--------------------------------------------------//
    
    //The purpose of this method is to rotate a point
    // around a specified anchor point in the following
    // order:
    // Rotate around z - rotation in x-y plane.
    // Rotate around x - rotation in y-z plane.
    // Rotate around y - rotation in x-z plane.
    //The rotation angles are passed in as double values
    // in degrees (based on the right-hand rule) in the
    // order given above, packaged in an object of the
    // class GM01.ColMatrix3D. (Note that in this case,
    // the ColMatrix3D object is simply a convenient
    // container and it has no significance from a matrix
    // viewpoint.)
    //The right-hand rule states that if you point the
    // thumb of your right hand in the positive direction
    // of an axis, the direction of positive rotation
    // around that axis is given by the direction that
    // your fingers will be pointing.
    //This method does not modify the contents of the
    // Point3D object on which the method is called.
    // Rather, it uses the contents of that object to
    // instantiate, rotate, and return a new Point3D
    // object.
    //For simplicity, this method translates the
    // anchorPoint to the origin, rotates around the
    // origin, and then translates back to the
    // anchorPoint.
    /*
    See http://www.ia.hiof.no/~borres/cgraph/math/threed/
    p-threed.html for a definition of the equations
    required to do the rotation.
    z-axis 
    x2 = x1*cos - y1*sin
    y2 = x1*sin + y1*cos
    
    x-axis
    y2 = y1*cos(v) - z1*sin(v)
    z2 = y1*sin(v) + z1* cos(v) 
    
    y-axis
    x2 = x1*cos(v) + z1*sin(v)
    z2 = -x1*sin(v) + z1*cos(v)
    */ 
    public GM01.Point3D rotate(GM01.Point3D anchorPoint,
                               GM01.ColMatrix3D angles){
      GM01.Point3D newPoint = this.clone();
      
      double tempX ;
      double tempY;
      double tempZ;
 
      //Translate anchorPoint to the origin
      GM01.Vector3D tempVec = 
            new GM01.Vector3D(anchorPoint.getColMatrix());
      newPoint = 
              newPoint.addVectorToPoint(tempVec.negate());

      double zAngle = angles.getData(0);
      double xAngle = angles.getData(1);
      double yAngle = angles.getData(2);
      
      //Rotate around z-axis
      tempX = newPoint.getData(0);
      tempY = newPoint.getData(1);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(zAngle*Math.PI/180) -
                      tempY*Math.sin(zAngle*Math.PI/180));

      newPoint.setData(//new y coordinate
                      1,
                      tempX*Math.sin(zAngle*Math.PI/180) +
                      tempY*Math.cos(zAngle*Math.PI/180));
      
      //Rotate around x-axis
      tempY = newPoint.getData(1);
      tempZ = newPoint.getData(2);
      newPoint.setData(//new y coordinate
                      1,
                      tempY*Math.cos(xAngle*Math.PI/180) -
                      tempZ*Math.sin(xAngle*Math.PI/180));

      newPoint.setData(//new z coordinate
                      2,
                      tempY*Math.sin(xAngle*Math.PI/180) +
                      tempZ*Math.cos(xAngle*Math.PI/180));
      
      //Rotate around y-axis
      tempX = newPoint.getData(0);
      tempZ = newPoint.getData(2);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(yAngle*Math.PI/180) +
                      tempZ*Math.sin(yAngle*Math.PI/180));

      newPoint.setData(//new z coordinate
                     2,
                     -tempX*Math.sin(yAngle*Math.PI/180) +
                     tempZ*Math.cos(yAngle*Math.PI/180));
      
      //Translate back to anchorPoint
      newPoint = newPoint.addVectorToPoint(tempVec);
      
      return newPoint;

    }//end rotate
    //--------------------------------------------------//
    
    //Multiplies this point by a scaling matrix received
    // as an incoming parameter and returns the scaled
    // point.
    public GM01.Point3D scale(GM01.ColMatrix3D scale){
      return new GM01.Point3D(new ColMatrix3D(
                          getData(0) * scale.getData(0),
                          getData(1) * scale.getData(1),
                          getData(2) * scale.getData(2)));
    }//end scale
    //--------------------------------------------------//
  }//end class Point3D
  //====================================================//
  //====================================================//

  
  public static class Vector2D{
    GM01.ColMatrix2D vector;
    
    public Vector2D(GM01.ColMatrix2D vector){//constructor
      //Create and save a clone of the ColMatrix2D object
      // used to define the vector to prevent the vector
      // from being corrupted by a later change in the
      // values stored in the original ColVector2D object.
      this.vector = new ColMatrix2D(
                     vector.getData(0),vector.getData(1));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return vector.getData(0) + "," + vector.getData(1);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 1)){
        throw new IndexOutOfBoundsException();
      }else{
        return vector.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        vector.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//
    
    //This method draws a vector on the specified graphics
    // context, with the tail of the vector located at a
    // specified point, and with a small filled circle at
    // the head.
    public void draw(Graphics2D g2D,GM01.Point2D tail){

      drawLine(g2D,
               tail.getData(0),
               tail.getData(1),
               tail.getData(0)+vector.getData(0),
               tail.getData(1)+vector.getData(1));

      fillOval(g2D,
               tail.getData(0)+vector.getData(0)-3,
               tail.getData(1)+vector.getData(1)+3,
               6,
               6);
    }//end draw
    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix2D object that
    // defines this Vector2D object.
    public GM01.ColMatrix2D getColMatrix(){
      return vector;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix2D objects that define two
    // Vector2D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(vector.equals((
                     (GM01.Vector2D)obj).getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//
    
    //Adds this vector to a vector received as an incoming
    // parameter and returns the sum as a vector.
    public GM01.Vector2D add(GM01.Vector2D vec){
      return new GM01.Vector2D(new ColMatrix2D(
                       vec.getData(0)+vector.getData(0),
                       vec.getData(1)+vector.getData(1)));
    }//end add
    //--------------------------------------------------//
    
    //Returns the length of a Vector2D object.
    public double getLength(){
      return Math.sqrt(
           getData(0)*getData(0) + getData(1)*getData(1));
    }//end getLength
    //--------------------------------------------------//
    
    //Multiplies this vector by a scale factor received as
    // an incoming parameter and returns the scaled
    // vector.
    public GM01.Vector2D scale(Double factor){
      return new GM01.Vector2D(new ColMatrix2D(
                                    getData(0) * factor,
                                    getData(1) * factor));
    }//end scale
    //--------------------------------------------------//
    
    //Changes the sign on each of the vector components
    // and returns the negated vector.
    public GM01.Vector2D negate(){
      return new GM01.Vector2D(new ColMatrix2D(
                                            -getData(0),
                                            -getData(1)));
    }//end negate
    //--------------------------------------------------//
    
    //Returns a new vector that points in the same
    // direction but has a length of one unit.
    public GM01.Vector2D normalize(){
      double length = getLength();
      return new GM01.Vector2D(new ColMatrix2D(
                                      getData(0)/length,
                                      getData(1)/length));
    }//end normalize
    //--------------------------------------------------//
  }//end class Vector2D
  //====================================================//


  public static class Vector3D{
    GM01.ColMatrix3D vector;
    
    public Vector3D(GM01.ColMatrix3D vector){//constructor
      //Create and save a clone of the ColMatrix3D object
      // used to define the vector to prevent the vector
      // from being corrupted by a later change in the
      // values stored in the original ColMatris3D object.
      this.vector = new ColMatrix3D(vector.getData(0),
                                    vector.getData(1),
                                    vector.getData(2));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return vector.getData(0) + "," + vector.getData(1) 
                                + "," + vector.getData(2);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 2)){
        throw new IndexOutOfBoundsException();
      }else{
        return vector.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        vector.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//
    
    //This method draws a vector on the specified graphics
    // context, with the tail of the vector located at a
    // specified point, and with a small circle at the
    // head.
    public void draw(Graphics2D g2D,GM01.Point3D tail){
      
      //Get a 2D projection of the tail
      GM01.ColMatrix2D tail2D = convert3Dto2D(tail.point);
      
      //Get the 3D location of the head
      GM01.ColMatrix3D head = 
                      tail.point.add(this.getColMatrix());
      
      //Get a 2D projection of the head
      GM01.ColMatrix2D head2D = convert3Dto2D(head);
      drawLine(g2D,tail2D.getData(0),
                   tail2D.getData(1),
                   head2D.getData(0),
                   head2D.getData(1));      

      //Draw a small filled circle to identify the head.
      fillOval(g2D,head2D.getData(0)-3,
                   head2D.getData(1)+3,
                   6,
                   6);

    }//end draw
    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix3D object that
    // defines this Vector3D object.
    public GM01.ColMatrix3D getColMatrix(){
      return vector;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix3D objects that define two
    // Vector3D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(vector.equals((
                     (GM01.Vector3D)obj).getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//
    
    //Adds this vector to a vector received as an incoming
    // parameter and returns the sum as a vector.
    public GM01.Vector3D add(GM01.Vector3D vec){
      return new GM01.Vector3D(new ColMatrix3D(
                       vec.getData(0)+vector.getData(0),
                       vec.getData(1)+vector.getData(1),
                       vec.getData(2)+vector.getData(2)));
    }//end add
    //--------------------------------------------------//
    
    //Returns the length of a Vector3D object.
    public double getLength(){
      return Math.sqrt(getData(0)*getData(0) + 
                       getData(1)*getData(1) + 
                       getData(2)*getData(2));
    }//end getLength
    //--------------------------------------------------//
    
    //Multiplies this vector by a scale factor received as
    // an incoming parameter and returns the scaled
    // vector.
    public GM01.Vector3D scale(Double factor){
      return new GM01.Vector3D(new ColMatrix3D(
                                    getData(0) * factor,
                                    getData(1) * factor,
                                    getData(2) * factor));
    }//end scale
    //--------------------------------------------------//
    
    //Changes the sign on each of the vector components
    // and returns the negated vector.
    public GM01.Vector3D negate(){
      return new GM01.Vector3D(new ColMatrix3D(
                                            -getData(0),
                                            -getData(1),
                                            -getData(2)));
    }//end negate
    //--------------------------------------------------//
    
    //Returns a new vector that points in the same
    // direction but has a length of one unit.
    public GM01.Vector3D normalize(){
      double length = getLength();
      return new GM01.Vector3D(new ColMatrix3D(
                                      getData(0)/length,
                                      getData(1)/length,
                                      getData(2)/length));
    }//end normalize
    //--------------------------------------------------//
  }//end class Vector3D
  //====================================================//
  //====================================================//

  
  //A line is defined by two points. One is called the
  // tail and the other is called the head. Note that this
  // class has the same name as one of the classes in
  // the Graphics2D class. Therefore, if the class from
  // the Graphics2D class is used in some future upgrade
  // to this program, it will have to be fully qualified.
  public static class Line2D{
    GM01.Point2D[] line = new GM01.Point2D[2];
    
    public Line2D(GM01.Point2D tail,GM01.Point2D head){
      //Create and save clones of the points used to
      // define the line to prevent the line from being 
      // corrupted by a later change in the coordinate
      // values of the points.
      this.line[0] = new Point2D(new GM01.ColMatrix2D(
                        tail.getData(0),tail.getData(1)));
      this.line[1] = new Point2D(new GM01.ColMatrix2D(
                        head.getData(0),head.getData(1)));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return "Tail = " + line[0].getData(0) + "," 
             + line[0].getData(1) + "\nHead = " 
             + line[1].getData(0) + "," 
             + line[1].getData(1);
    }//end toString
    //--------------------------------------------------//

    public GM01.Point2D getTail(){
      return line[0];
    }//end getTail
    //--------------------------------------------------//
    
    public GM01.Point2D getHead(){
      return line[1];
    }//end getHead
    //--------------------------------------------------//
    
    public void setTail(GM01.Point2D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[0] = new Point2D(new GM01.ColMatrix2D(
                newPoint.getData(0),newPoint.getData(1)));
    }//end setTail
    //--------------------------------------------------//
    
    public void setHead(GM01.Point2D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[1] = new Point2D(new GM01.ColMatrix2D(
                newPoint.getData(0),newPoint.getData(1)));
    }//end setHead
    //--------------------------------------------------//
    
    public void draw(Graphics2D g2D){
      drawLine(g2D,getTail().getData(0),
                   getTail().getData(1),
                   getHead().getData(0),
                   getHead().getData(1));
    }//end draw
    //--------------------------------------------------//
  }//end class Line2D
  //====================================================//


  //A line is defined by two points. One is called the
  // tail and the other is called the head.
  public static class Line3D{
    GM01.Point3D[] line = new GM01.Point3D[2];
    
    public Line3D(GM01.Point3D tail,GM01.Point3D head){
      //Create and save clones of the points used to
      // define the line to prevent the line from being 
      // corrupted by a later change in the coordinate
      // values of the points.
      this.line[0] = new Point3D(new GM01.ColMatrix3D(
                                        tail.getData(0),
                                        tail.getData(1),
                                        tail.getData(2)));
      this.line[1] = new Point3D(new GM01.ColMatrix3D(
                                        head.getData(0),
                                        head.getData(1),
                                        head.getData(2)));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return "Tail = " + line[0].getData(0) + "," 
                       + line[0].getData(1)  + "," 
                       + line[0].getData(2) 
                       + "\nHead = " 
                       + line[1].getData(0) + "," 
                       + line[1].getData(1) + ","      
                       + line[1].getData(2);
    }//end toString
    //--------------------------------------------------//

    public GM01.Point3D getTail(){
      return line[0];
    }//end getTail
    //--------------------------------------------------//
    
    public GM01.Point3D getHead(){
      return line[1];
    }//end getHead
    //--------------------------------------------------//

    public void setTail(GM01.Point3D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[0] = new Point3D(new GM01.ColMatrix3D(
                                    newPoint.getData(0),
                                    newPoint.getData(1),
                                    newPoint.getData(2)));
    }//end setTail
    //--------------------------------------------------//
    
    public void setHead(GM01.Point3D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[1] = new Point3D(new GM01.ColMatrix3D(
                                    newPoint.getData(0),
                                    newPoint.getData(1),
                                    newPoint.getData(2)));
    }//end setHead
    //--------------------------------------------------//

    public void draw(Graphics2D g2D){
      
      //Get 2D projection coordinates.
      GM01.ColMatrix2D tail = 
                           convert3Dto2D(getTail().point);
      GM01.ColMatrix2D head = 
                           convert3Dto2D(getHead().point);

      drawLine(g2D,tail.getData(0),
                   tail.getData(1),
                   head.getData(0),
                   head.getData(1));
    }//end draw
    //--------------------------------------------------//
  }//end class Line3D
  //====================================================//

}//end class GM01
//======================================================//
</code>



	


<para id="p1336">
<emphasis id="strong1299" effect="bold">
<emphasis id="Listing_27" effect="bold">

Listing 27

</emphasis>

. Source code for the program named GM01test02.

</emphasis>
</para>





<code id="pre1029" display="block">/*GM01test02.java 
Copyright 2008, R.G.Baldwin
Revised 02/18/08

This program tests many 2D aspects of the GM01 library
using both text and graphics.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;

class GM01test02{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test02
//======================================================//

class GUI extends JFrame{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 400;
  int vSize = 400;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas
  
  GUI(){//constructor
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
    //Create a new drawing canvas and add it to the
    // center of the JFrame.
    myCanvas = new MyCanvas();
    this.getContentPane().add(myCanvas);
    
    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    Graphics2D g2D = (Graphics2D)(osi.getGraphics());
    
    //Perform tests using text.
    testUsingText();
    
    //Perform tests using graphics.
    drawOffScreen(g2D);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();

  }//end constructor
  //----------------------------------------------------//
  
  //The purpose of this method is to test various
  // 2D aspects of the library using text.
  public void testUsingText(){
    System.out.println(
               "Test overridden toString of ColMatrix2D");
    GM01.ColMatrix2D tempA = 
                            new GM01.ColMatrix2D(1.5,2.5);
    System.out.println(tempA);
    System.out.println();
    
    System.out.println(
               "Test setData and getData of ColMatrix2D");
    tempA.setData(0,4.5);
    System.out.println(tempA.getData(0));
    tempA.setData(1,5.5);
    System.out.println(tempA.getData(1));
    System.out.println();
    
    System.out.println(
                     "Test equals method of ColMatrix2D");
    GM01.ColMatrix2D tempB = 
                            new GM01.ColMatrix2D(1.5,2.5);
    System.out.println(tempA.equals(tempB));
    tempB.setData(0,4.5);
    tempB.setData(1,5.5);
    System.out.println(tempA.equals(tempB));
    System.out.println();
    
    System.out.println("Test add method of ColMatrix2D");
    System.out.println(tempA.add(tempB));
    System.out.println();
    
    System.out.println(
                   "Test subtract method of ColMatrix2D");
    System.out.println(tempA.subtract(tempB));
    System.out.println();
    
    System.out.println("Test toString method of Point2D");
    GM01.Point2D pointA = new GM01.Point2D(tempA);
    System.out.println(pointA);
    System.out.println();
    
    System.out.println(
                   "Test setData and getData of Point2D");
    pointA.setData(0,1.1);
    System.out.println(pointA.getData(0));
    pointA.setData(1,2.2);
    System.out.println(pointA.getData(1));
    System.out.println();
    
    System.out.println(
                   "Test getColMatrix method of Point2D");
    System.out.println(pointA.getColMatrix());
    System.out.println();
    
    System.out.println("Test equals method of Point2D");
    GM01.Point2D pointB = new GM01.Point2D(tempB);
    System.out.println(pointA.equals(pointB));
    pointA = new GM01.Point2D(tempB);
    System.out.println(pointA.equals(pointB));
    System.out.println();
    
    System.out.println(
          "Test getDisplacementVector method of Point2D");
    pointA = 
          new GM01.Point2D(new GM01.ColMatrix2D(1.5,2.5));
    System.out.println(pointA);
    System.out.println(pointB);
    System.out.println(
                    pointA.getDisplacementVector(pointB));
    System.out.println();
    
    System.out.println(
               "Test addVectorToPoint method of Point2D");
    System.out.println(pointA);
    System.out.println(pointA.addVectorToPoint(
      new GM01.Vector2D(new GM01.ColMatrix2D(5.5,6.5))));
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Point2D class.
    
    System.out.println(
                      "Test toString method of Vector2D");
    GM01.Vector2D vecA = 
         new GM01.Vector2D(new GM01.ColMatrix2D(1.5,2.5));
    System.out.println(vecA);
    System.out.println();
    
    System.out.println(
          "Test setData and getData methods of Vector2D");
    vecA.setData(0,4.5);
    System.out.println(vecA.getData(0));
    vecA.setData(1,5.5);
    System.out.println(vecA.getData(1));
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Vector2D class.
    
    System.out.println(
                  "Test getColMatrix method of Vector2D");
    System.out.println(vecA.getColMatrix());
    System.out.println();
    
    System.out.println("Test equals method of Vector2D");
    GM01.Vector2D vecB = 
         new GM01.Vector2D(new GM01.ColMatrix2D(1.5,2.5));
    System.out.println(vecA.equals(vecB));
    vecB.setData(0,4.5);
    vecB.setData(1,5.5);
    System.out.println(vecA.equals(vecB));
    
    System.out.println("Test add method of Vector2D");
    System.out.println(vecA);
    vecB = 
        new GM01.Vector2D(new GM01.ColMatrix2D(-1.5,3.5));
    System.out.println(vecB);
    System.out.println(vecA.add(vecB));
    System.out.println();

    
    System.out.println(
                     "Test getLength method of Vector2D");
    vecA = 
         new GM01.Vector2D(new GM01.ColMatrix2D(3.0,4.0));
    System.out.println(vecA);
    System.out.println(vecA.getLength());
    System.out.println();

    System.out.println("Test toString method of Line2D");
    GM01.Line2D lineA = new GM01.Line2D(pointA,pointB);
    System.out.println(lineA);
    System.out.println();
    
    System.out.println("Test setTail, setHead, getTail, "
                     + "\nand getHead methods of Line2D");
    lineA.setTail(pointB);
    lineA.setHead(pointA);
    System.out.println(lineA.getTail());
    System.out.println(lineA.getHead());
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Line2D class.
    
  }//end testUsingText
  //----------------------------------------------------//
  
  //The purpose of this method is test various 2D aspects
  // of the game-math library using graphics.
  void drawOffScreen(Graphics2D g2D){
    
    //Translate the origin on the off-screen
    // image and draw a pair of orthogonal axes on it.
    setCoordinateFrame(g2D);

    //Define the corners of a square in 2D that is
    // centered on the origin.
    GM01.Point2D pointA = 
           new GM01.Point2D(new GM01.ColMatrix2D(75,-75));
    GM01.Point2D pointB = 
          new GM01.Point2D(new GM01.ColMatrix2D(-75,-75));
    GM01.Point2D pointC = 
           new GM01.Point2D(new GM01.ColMatrix2D(-75,75));
    GM01.Point2D pointD = 
            new GM01.Point2D(new GM01.ColMatrix2D(75,75));

    //Draw three of the points in BLACK. Draw the fourth
    // point in RED to identify it.
    g2D.setColor(Color.BLACK);
    pointA.draw(g2D);
    pointB.draw(g2D);
    pointC.draw(g2D);
    g2D.setColor(Color.RED);
    pointD.draw(g2D);
    g2D.setColor(Color.BLACK);
    
    
    //Draw four lines connecting the points to produce
    // the outline of a square.
    GM01.Line2D lineAB = new GM01.Line2D(pointA,pointB);
    lineAB.draw(g2D);
    
    GM01.Line2D lineBC = new GM01.Line2D(pointB,pointC);
    lineBC.draw(g2D);
    
    GM01.Line2D lineCD = new GM01.Line2D(pointC,pointD);
    lineCD.draw(g2D);
    
    GM01.Line2D lineDA = new GM01.Line2D(pointD,pointA);
    lineDA.draw(g2D);    
    
    //Define a vector.
    GM01.Vector2D vecA = new GM01.Vector2D(
                            new GM01.ColMatrix2D(75,75));

    //Draw the vector with its tail at pointB. The length
    // and direction of the vector will cause its head
    // to be at the origin.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,pointB);

  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to set the origin of the
  // off-screen image and to draw orthogonal 2D axes on
  // the image that intersect at the origin.
  private void setCoordinateFrame(Graphics2D g2D){

    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.drawLine(g2D,-75,0,75,0);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    GM01.drawLine(g2D,0,75,0,-75);

  }//end setCoordinateFrame method
  //====================================================//
  
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the paint() method. This method will be
    // called when the JFrame and the Canvas appear on the
    // screen or when the repaint method is called on the
    // Canvas object.
    //The purpose of this method is to display the
    // off-screen image on the screen.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
    
  }//end inner class MyCanvas
    
}//end class GUI
//======================================================//
</code>






<para id="p1337">
<emphasis id="strong1300" effect="bold">
<emphasis id="Listing_28" effect="bold">

Listing 28

</emphasis>

. Source code for the program named GM01test01.

</emphasis>
</para>





<code id="pre1030" display="block">/*GM01test01.java 
Copyright 2008, R.G.Baldwin
Revised 02/18/08

This program tests many 3D aspects of the GM01 library
using both text and graphics.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;

class GM01test01{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test01
//======================================================//

class GUI extends JFrame{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 400;
  int vSize = 400;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas
  
  GUI(){//constructor
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
    //Create a new drawing canvas and add it to the
    // center of the JFrame.
    myCanvas = new MyCanvas();
    this.getContentPane().add(myCanvas);
    
    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    Graphics2D g2D = (Graphics2D)(osi.getGraphics());
    
    //Test many 3D library features using text.
    testUsingText();
    
    //Test many 3D library features using graphics.
    drawOffScreen(g2D);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();

  }//end constructor
  //----------------------------------------------------//

    //The purpose of this method is to test various
    // 3D aspects of the library using text.
  public void testUsingText(){
    System.out.println(
               "Test overridden toString of ColMatrix3D");
    GM01.ColMatrix3D tempA = 
                        new GM01.ColMatrix3D(1.5,2.5,3.5);
    System.out.println(tempA);
    System.out.println();
    
    System.out.println(
               "Test setData and getData of ColMatrix3D");
    tempA.setData(0,4.5);
    System.out.println(tempA.getData(0));
    tempA.setData(1,5.5);
    System.out.println(tempA.getData(1));
    tempA.setData(2,6.5);
    System.out.println(tempA.getData(2));
    System.out.println();
    
    System.out.println(
                     "Test equals method of ColMatrix3D");
    GM01.ColMatrix3D tempB = 
                        new GM01.ColMatrix3D(1.5,2.5,3.5);
    System.out.println(tempA.equals(tempB));
    tempB.setData(0,4.5);
    tempB.setData(1,5.5);
    tempB.setData(2,6.5);
    System.out.println(tempA.equals(tempB));
    System.out.println();
    
    System.out.println("Test add method of ColMatrix3D");
    System.out.println(tempA.add(tempB));
    System.out.println();
    
    System.out.println(
                   "Test subtract method of ColMatrix3D");
    System.out.println(tempA.subtract(tempB));
    System.out.println();
    
    System.out.println("Test toString method of Point3D");
    GM01.Point3D pointA = new GM01.Point3D(tempA);
    System.out.println(pointA);
    System.out.println();
    
    System.out.println(
                   "Test setData and getData of Point3D");
    pointA.setData(0,1.1);
    System.out.println(pointA.getData(0));
    pointA.setData(1,2.2);
    System.out.println(pointA.getData(1));
    pointA.setData(2,3.3);
    System.out.println(pointA.getData(2));
    System.out.println();
    
    System.out.println("Test getColMatrix of Point3D");
    System.out.println(pointA.getColMatrix());
    System.out.println();
    
    System.out.println("Test equals method of Point3D");
    GM01.Point3D pointB = new GM01.Point3D(tempB);
    System.out.println(pointA.equals(pointB));
    pointA = new GM01.Point3D(tempB);
    System.out.println(pointA.equals(pointB));
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Point3D class.
    
    System.out.println(
          "Test getDisplacementVector method of Point3D");
    pointA = 
      new GM01.Point3D(new GM01.ColMatrix3D(1.5,2.5,3.5));
    System.out.println(pointA);
    System.out.println(pointB);
    System.out.println(
                    pointA.getDisplacementVector(pointB));
    System.out.println();
    
    System.out.println(
               "Test addVectorToPoint method of Point3D");
    System.out.println(pointA);
    System.out.println(pointA.addVectorToPoint(
                   new GM01.Vector3D(
                     new GM01.ColMatrix3D(5.5,6.5,7.5))));
    System.out.println();
    
    System.out.println(
                      "Test toString method of Vector3D");
    GM01.Vector3D vecA = new GM01.Vector3D(
                       new GM01.ColMatrix3D(1.5,2.5,3.5));
    System.out.println(vecA);
    System.out.println();
    
    System.out.println(
          "Test setData and getData methods of Vector3D");
    vecA.setData(0,4.5);
    System.out.println(vecA.getData(0));
    vecA.setData(1,5.5);
    System.out.println(vecA.getData(1));
    vecA.setData(2,6.5);
    System.out.println(vecA.getData(2));
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Vector3D class.
    
    System.out.println(
                  "Test getColMatrix method of Vector3D");
    System.out.println(vecA.getColMatrix());
    System.out.println();
    
    System.out.println("Test equals method of Vector3D");
    GM01.Vector3D vecB = new GM01.Vector3D(
                       new GM01.ColMatrix3D(1.5,2.5,3.5));
    System.out.println(vecA.equals(vecB));
    vecB.setData(0,4.5);
    vecB.setData(1,5.5);
    vecB.setData(2,6.5);
    System.out.println(vecA.equals(vecB));
    
    System.out.println("Test add method of Vector3D");
    System.out.println(vecA);
    vecB = new GM01.Vector3D(
                      new GM01.ColMatrix3D(-1.5,2.5,3.5));
    System.out.println(vecB);
    System.out.println(vecA.add(vecB));
    System.out.println();
    
    System.out.println(
                     "Test getLength method of Vector3D");
    vecA = new GM01.Vector3D(
                       new GM01.ColMatrix3D(3.0,4.0,5.0));
    System.out.println(vecA);
    System.out.println(vecA.getLength());
    System.out.println();
    
    System.out.println("Test toString method of Line3D");
    GM01.Line3D lineA = new GM01.Line3D(pointA,pointB);
    System.out.println(lineA);
    System.out.println();
    
    System.out.println("Test setTail, setHead, getTail, "
                     + "\nand getHead methods of Line3D");
    lineA.setTail(pointB);
    lineA.setHead(pointA);
    System.out.println(lineA.getTail());
    System.out.println(lineA.getHead());
    System.out.println();
  }//end testUsingText
  //----------------------------------------------------//
  
  //The purpose of this method is to test various
  // 3D aspects of the library using graphics.
  void drawOffScreen(Graphics2D g2D){
    
    //Translate the origin on the off-screen
    // image and draw a pair of orthogonal axes on it.
    setCoordinateFrame(g2D);

    //Define eight points that define the corners of
    // a box in 3D that is centered on the origin.
    
    GM01.Point3D[] points = new GM01.Point3D[8];
    //Right side
    points[0] = 
         new GM01.Point3D(new GM01.ColMatrix3D(75,75,75));
    points[1] = 
        new GM01.Point3D(new GM01.ColMatrix3D(75,75,-75));
    points[2] = 
       new GM01.Point3D(new GM01.ColMatrix3D(75,-75,-75));
    points[3] = 
        new GM01.Point3D(new GM01.ColMatrix3D(75,-75,75));
    //Left side
    points[4] = 
        new GM01.Point3D(new GM01.ColMatrix3D(-75,75,75));
    points[5] = 
       new GM01.Point3D(new GM01.ColMatrix3D(-75,75,-75));
    points[6] = 
      new GM01.Point3D(new GM01.ColMatrix3D(-75,-75,-75));
    points[7] = 
       new GM01.Point3D(new GM01.ColMatrix3D(-75,-75,75));
    
    //Draw seven of the points in BLACK
    g2D.setColor(Color.BLACK);
    for(int cnt = 1;cnt &lt; points.length;cnt++){
      points[cnt].draw(g2D);
    }//end for loop
    
    //Draw the right top front point in RED to identify
    // it.
    g2D.setColor(Color.RED);
    points[0].draw(g2D);
    g2D.setColor(Color.BLACK);
    
    //Draw lines that connect the points to define the
    // twelve edges of the box.
    //Right side
    new GM01.Line3D(points[0],points[1]).draw(g2D);
    new GM01.Line3D(points[1],points[2]).draw(g2D);
    new GM01.Line3D(points[2],points[3]).draw(g2D);
    new GM01.Line3D(points[3],points[0]).draw(g2D);
    
    //Left side
    new GM01.Line3D(points[4],points[5]).draw(g2D);
    new GM01.Line3D(points[5],points[6]).draw(g2D);
    new GM01.Line3D(points[6],points[7]).draw(g2D);
    new GM01.Line3D(points[7],points[4]).draw(g2D);
    
    //Front
    new GM01.Line3D(points[0],points[4]).draw(g2D);
    new GM01.Line3D(points[3],points[7]).draw(g2D);
    
    //Back
    new GM01.Line3D(points[1],points[5]).draw(g2D);
    new GM01.Line3D(points[2],points[6]).draw(g2D);

    
    //Define a vector.
    GM01.Vector3D vecA = new GM01.Vector3D(
                        new GM01.ColMatrix3D(75,-75,-75));
                        
    //Draw the vector with its tail at the upper-left
    // corner of the box. The length and direction of the
    // vector will cause its head to be at the origin.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,points[4]);

  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to set the origin of the
  // off-screen image and to draw orthogonal 3D axes on
  // the off-screen image that intersect at the origin.
  // The lengths of the axes are set so as to match the
  // interior dimensions of the box and points are drawn
  // where the axes intersect the surfaces of the box.
  private void setCoordinateFrame(Graphics2D g2D){

    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.Point3D pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(-75,0,0));
    GM01.Point3D pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(75,0,0));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,-75,0));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,75,0));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw z-axis in BLUE
    g2D.setColor(Color.BLUE);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,0,-75));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,0,75));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
  //====================================================//
  
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the paint() method. This method will be
    // called when the JFrame and the Canvas appear on the
    // screen or when the repaint method is called on the
    // Canvas object.
    //The purpose of this method is to display the
    // off-screen image on the screen.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
    
  }//end inner class MyCanvas
    
}//end class GUI
//======================================================//
</code>




	



<para id="p1338">
<emphasis id="strong1301" effect="bold">
<emphasis id="Listing_29" effect="bold">

Listing 29

</emphasis>

. Source code for the program named GM01test05.

</emphasis>
</para>





<code id="pre1031" display="block">/*GM01test05.java 
Copyright 2008, R.G.Baldwin
Revised 02/24/08

This program illustrates vector addition in 3D.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;

class GM01test05{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test05
//======================================================//

class GUI extends JFrame{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 300;
  int vSize = 200;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas
  
  GUI(){//constructor
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
    //Create a new drawing canvas and add it to the
    // center of the JFrame.
    myCanvas = new MyCanvas();
    this.getContentPane().add(myCanvas);
    
    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    Graphics2D g2D = (Graphics2D)(osi.getGraphics());
    
    //Draw on the off-screen image.
    drawOffScreen(g2D);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();

  }//end constructor
  //----------------------------------------------------//

  //The purpose of this method is to illustrate vector
  // addition in 3D
  void drawOffScreen(Graphics2D g2D){
    
    //Translate the origin on the off-screen image, draw a
    // pair of orthogonal axes on it that intersect at the
    // origin, and paint the background white.
    setCoordinateFrame(g2D);
    
    //Define two vectors that will be added.
    GM01.Vector3D vecA = new GM01.Vector3D(
                         new GM01.ColMatrix3D(75,75,75));
                        
    GM01.Vector3D vecB = new GM01.Vector3D(
                        new GM01.ColMatrix3D(-15,10,-50));
                        
    //Create a ref point at the origin for convenience.
    GM01.Point3D zeroPoint = new GM01.Point3D(
                             new GM01.ColMatrix3D(0,0,0));
                        
    //Draw vecA in MAGENTA with its tail at the origin.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,zeroPoint);
    
    //Draw vecB in LIGHT_GRAY with its tail at the head
    // of vecA.
    g2D.setColor(Color.LIGHT_GRAY);
    GM01.Point3D temp = 
                    new GM01.Point3D(vecA.getColMatrix());
    vecB.draw(g2D,temp);
    
    //Draw vecB in LIGHT_GRAY with its tail at the origin.
    vecB.draw(g2D,zeroPoint);
    
    //Draw vecA in MAGENTA with its tail at the head
    // of vecB. This completes a trapezoid.
    g2D.setColor(Color.MAGENTA);
    vecA.draw(g2D,new GM01.Point3D(vecB.getColMatrix()));
    
    //Add the two vectors.
    GM01.Vector3D sum = vecA.add(vecB);
    //Draw sum in BLACK with its tail at the origin.
    g2D.setColor(Color.BLACK);
    sum.draw(g2D,zeroPoint);

  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to set the origin of the
  // off-screen image, set the background color to WHITE,
  // and draw orthogonal 3D axes on the off-screen image
  // that intersect at the origin.
  private void setCoordinateFrame(Graphics2D g2D){

    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    
    //Set background color to WHITE.
    g2D.setColor(Color.WHITE);
    GM01.fillRect(
          g2D,-osiWidth/2,osiHeight/2,osiWidth,osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.Point3D pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(-75,0,0));
    GM01.Point3D pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(75,0,0));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,-75,0));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,75,0));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw z-axis in BLUE
    g2D.setColor(Color.BLUE);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,0,-75));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,0,75));
    pointA.draw(g2D);
    pointB.draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
  //====================================================//
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the paint() method. This method will be
    // called when the JFrame and the Canvas appear on the
    // screen or when the repaint method is called on the
    // Canvas object.
    //The purpose of this method is to display the
    // off-screen image on the screen.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
    
  }//end inner class MyCanvas
    
}//end class GUI
//======================================================//
</code>






<para id="p1339">
<emphasis id="strong1302" effect="bold">
<emphasis id="Listing_30" effect="bold">

Listing 30

</emphasis>

. Source code for the program named GM01test06.

</emphasis>
</para>





<code id="pre1032" display="block">/*GM01test06.java 
Copyright 2008, R.G.Baldwin
Revised 02/24/08

This program is an update of the program named GM01test01.
The purpose is to illustrate scaling a geometric object
by calling the method named GM01.Point3D.scale for each
point that makes up the object.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;

class GM01test06{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test06
//======================================================//

class GUI extends JFrame{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 400;
  int vSize = 400;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas
  
  GUI(){//constructor
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
    //Create a new drawing canvas and add it to the
    // center of the JFrame.
    myCanvas = new MyCanvas();
    this.getContentPane().add(myCanvas);
    
    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    Graphics2D g2D = (Graphics2D)(osi.getGraphics());
    
    //Test many 3D library features using text.
    testUsingText();
    
    //Test many 3D library features using graphics.
    drawOffScreen(g2D);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();

  }//end constructor
  //----------------------------------------------------//

    //The purpose of this method is to test various
    // 3D aspects of the library using text.
  public void testUsingText(){
    System.out.println(
               "Test overridden toString of ColMatrix3D");
    GM01.ColMatrix3D tempA = 
                        new GM01.ColMatrix3D(1.5,2.5,3.5);
    System.out.println(tempA);
    System.out.println();
    
    System.out.println(
               "Test setData and getData of ColMatrix3D");
    tempA.setData(0,4.5);
    System.out.println(tempA.getData(0));
    tempA.setData(1,5.5);
    System.out.println(tempA.getData(1));
    tempA.setData(2,6.5);
    System.out.println(tempA.getData(2));
    System.out.println();
    
    System.out.println(
                     "Test equals method of ColMatrix3D");
    GM01.ColMatrix3D tempB = 
                        new GM01.ColMatrix3D(1.5,2.5,3.5);
    System.out.println(tempA.equals(tempB));
    tempB.setData(0,4.5);
    tempB.setData(1,5.5);
    tempB.setData(2,6.5);
    System.out.println(tempA.equals(tempB));
    System.out.println();
    
    System.out.println("Test add method of ColMatrix3D");
    System.out.println(tempA.add(tempB));
    System.out.println();
    
    System.out.println(
                   "Test subtract method of ColMatrix3D");
    System.out.println(tempA.subtract(tempB));
    System.out.println();
    
    System.out.println("Test toString method of Point3D");
    GM01.Point3D pointA = new GM01.Point3D(tempA);
    System.out.println(pointA);
    System.out.println();
    
    System.out.println(
                   "Test setData and getData of Point3D");
    pointA.setData(0,1.1);
    System.out.println(pointA.getData(0));
    pointA.setData(1,2.2);
    System.out.println(pointA.getData(1));
    pointA.setData(2,3.3);
    System.out.println(pointA.getData(2));
    System.out.println();
    
    System.out.println("Test getColMatrix of Point3D");
    System.out.println(pointA.getColMatrix());
    System.out.println();
    
    System.out.println("Test equals method of Point3D");
    GM01.Point3D pointB = new GM01.Point3D(tempB);
    System.out.println(pointA.equals(pointB));
    pointA = new GM01.Point3D(tempB);
    System.out.println(pointA.equals(pointB));
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Point3D class.
    
    System.out.println(
          "Test getDisplacementVector method of Point3D");
    pointA = 
      new GM01.Point3D(new GM01.ColMatrix3D(1.5,2.5,3.5));
    System.out.println(pointA);
    System.out.println(pointB);
    System.out.println(
                    pointA.getDisplacementVector(pointB));
    System.out.println();
    
    System.out.println(
               "Test addVectorToPoint method of Point3D");
    System.out.println(pointA);
    System.out.println(pointA.addVectorToPoint(
                   new GM01.Vector3D(
                     new GM01.ColMatrix3D(5.5,6.5,7.5))));
    System.out.println();
    
    System.out.println(
                      "Test toString method of Vector3D");
    GM01.Vector3D vecA = new GM01.Vector3D(
                       new GM01.ColMatrix3D(1.5,2.5,3.5));
    System.out.println(vecA);
    System.out.println();
    
    System.out.println(
          "Test setData and getData methods of Vector3D");
    vecA.setData(0,4.5);
    System.out.println(vecA.getData(0));
    vecA.setData(1,5.5);
    System.out.println(vecA.getData(1));
    vecA.setData(2,6.5);
    System.out.println(vecA.getData(2));
    System.out.println();
    
    //See the method named drawOffScreen for a test of
    // the draw method of the Vector3D class.
    
    System.out.println(
                  "Test getColMatrix method of Vector3D");
    System.out.println(vecA.getColMatrix());
    System.out.println();
    
    System.out.println("Test equals method of Vector3D");
    GM01.Vector3D vecB = new GM01.Vector3D(
                       new GM01.ColMatrix3D(1.5,2.5,3.5));
    System.out.println(vecA.equals(vecB));
    vecB.setData(0,4.5);
    vecB.setData(1,5.5);
    vecB.setData(2,6.5);
    System.out.println(vecA.equals(vecB));
    
    System.out.println("Test add method of Vector3D");
    System.out.println(vecA);
    vecB = new GM01.Vector3D(
                      new GM01.ColMatrix3D(-1.5,2.5,3.5));
    System.out.println(vecB);
    System.out.println(vecA.add(vecB));
    System.out.println();
    
    System.out.println(
                     "Test getLength method of Vector3D");
    vecA = new GM01.Vector3D(
                       new GM01.ColMatrix3D(3.0,4.0,5.0));
    System.out.println(vecA);
    System.out.println(vecA.getLength());
    System.out.println();
    
    System.out.println("Test toString method of Line3D");
    GM01.Line3D lineA = new GM01.Line3D(pointA,pointB);
    System.out.println(lineA);
    System.out.println();
    
    System.out.println("Test setTail, setHead, getTail, "
                     + "\nand getHead methods of Line3D");
    lineA.setTail(pointB);
    lineA.setHead(pointA);
    System.out.println(lineA.getTail());
    System.out.println(lineA.getHead());
    System.out.println();
  }//end testUsingText
  //----------------------------------------------------//
  
  //The purpose of this method is to test various
  // 3D aspects of the library using graphics.
  void drawOffScreen(Graphics2D g2D){
    
    //Translate the origin on the off-screen
    // image and draw a pair of orthogonal axes on it.
    setCoordinateFrame(g2D);

    //Define eight points that define the corners of
    // a box in 3D that is centered on the origin.
    
    GM01.Point3D[] points = new GM01.Point3D[8];
    //Right side
    points[0] = 
         new GM01.Point3D(new GM01.ColMatrix3D(75,75,75));
    points[1] = 
        new GM01.Point3D(new GM01.ColMatrix3D(75,75,-75));
    points[2] = 
       new GM01.Point3D(new GM01.ColMatrix3D(75,-75,-75));
    points[3] = 
        new GM01.Point3D(new GM01.ColMatrix3D(75,-75,75));
    //Left side
    points[4] = 
        new GM01.Point3D(new GM01.ColMatrix3D(-75,75,75));
    points[5] = 
       new GM01.Point3D(new GM01.ColMatrix3D(-75,75,-75));
    points[6] = 
      new GM01.Point3D(new GM01.ColMatrix3D(-75,-75,-75));
    points[7] = 
       new GM01.Point3D(new GM01.ColMatrix3D(-75,-75,75));
       
    //Scale each of the points that define the corners of
    // the box.
    for(int cnt = 0;cnt &lt; points.length;cnt++){
      points[cnt] = points[cnt].scale(
                     new GM01.ColMatrix3D(0.25,0.5,0.75));
    }//end for loop
    
    //Draw seven of the points in BLACK
    g2D.setColor(Color.BLACK);
    for(int cnt = 1;cnt &lt; points.length;cnt++){
      points[cnt].draw(g2D);
    }//end for loop
    
    //Draw the right top front point in RED to identify
    // it.
    g2D.setColor(Color.RED);
    points[0].draw(g2D);
    g2D.setColor(Color.BLACK);
    
    //Draw lines that connect the points to define the
    // twelve edges of the box.
    //Right side
    new GM01.Line3D(points[0],points[1]).draw(g2D);
    new GM01.Line3D(points[1],points[2]).draw(g2D);
    new GM01.Line3D(points[2],points[3]).draw(g2D);
    new GM01.Line3D(points[3],points[0]).draw(g2D);
    
    //Left side
    new GM01.Line3D(points[4],points[5]).draw(g2D);
    new GM01.Line3D(points[5],points[6]).draw(g2D);
    new GM01.Line3D(points[6],points[7]).draw(g2D);
    new GM01.Line3D(points[7],points[4]).draw(g2D);
    
    //Front
    new GM01.Line3D(points[0],points[4]).draw(g2D);
    new GM01.Line3D(points[3],points[7]).draw(g2D);
    
    //Back
    new GM01.Line3D(points[1],points[5]).draw(g2D);
    new GM01.Line3D(points[2],points[6]).draw(g2D);

  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to set the origin of the
  // off-screen image and to draw orthogonal 3D axes on
  // the off-screen image that intersect at the origin.
  // Points are drawn where the axes intersect the
  // surfaces of the box.
  private void setCoordinateFrame(Graphics2D g2D){

    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);

    //Draw x-axis in RED. Scale the points before
    // drawing them so that they will identify the
    // locations where the axes intersect the surface
    // of the box.
    g2D.setColor(Color.RED);
    GM01.Point3D pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(-75,0,0));
    GM01.Point3D pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(75,0,0));
    pointA.scale(
            new GM01.ColMatrix3D(0.25,0.0,0.0)).draw(g2D);
    pointB.scale(
            new GM01.ColMatrix3D(0.25,0.0,0.0)).draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,-75,0));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,75,0));
    pointA.scale(
             new GM01.ColMatrix3D(0.0,0.5,0.0)).draw(g2D);
    pointB.scale(
             new GM01.ColMatrix3D(0.0,0.5,0.0)).draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw z-axis in BLUE
    g2D.setColor(Color.BLUE);
    pointA = 
          new GM01.Point3D(new GM01.ColMatrix3D(0,0,-75));
    pointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(0,0,75));
    pointA.scale(
            new GM01.ColMatrix3D(0.0,0.0,0.75)).draw(g2D);
    pointB.scale(
            new GM01.ColMatrix3D(0.0,0.0,0.75)).draw(g2D);
    new GM01.Line3D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
  //====================================================//
  
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the paint() method. This method will be
    // called when the JFrame and the Canvas appear on the
    // screen or when the repaint method is called on the
    // Canvas object.
    //The purpose of this method is to display the
    // off-screen image on the screen.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
    
  }//end inner class MyCanvas
    
}//end class GUI
//======================================================//
</code>






<para id="p1340">
<emphasis id="strong1303" effect="bold">
<emphasis id="Listing_31" effect="bold">

Listing 31

</emphasis>

. Source code for the program named StringArt02.

</emphasis>
</para>





<code id="pre1033" display="block">/*StringArt02.java 
Copyright 2008, R.G.Baldwin
Revised 02/22/08

This is a 2D version of a string art program that supports
rotation in two dimensions.

This program produces a 2D string art image by connecting
various points that are equally spaced on the 
circumference of a circle.

Initially, the circle is centered on the origin. There are
six points on the circle connected by lines forming a 
hexagon, The lines that connect the points are different 
colors. The radius of the circle is 50 units. The points 
at the vertices of the hexagon are not drawn, but the 
lines that connect the vertices are drawn.

A GUI is provided that allows the user to specify the 
following items and click a Replot button to cause the 
drawing to change:

Number Points
Number Loops
Rotation angle (deg)
X anchor point
Y anchor point


Changing the number of points causes the number of 
vertices that describe the geometric object to change.

Changing the number of loops causes the number of lines
that are drawn to connect the vertices to change. For a
value of 1, each vertex is connected to the one next to
it. For a value of 2, additional lines are drawn 
connecting every other vertex. For a value of 3, 
additional lines are drawn connecting every third vertex,
etc.

The image can be rotated around an anchor point. Entering 
a non-zero value in the Rotation field causes the image 
to be rotated by the specified angle around the anchor 
point.

The anchor point is initially located at the origin, but 
the location of the anchor point can be changed by the 
user. If the anchor point is at the origin, the image is 
rotated around the origin. Otherwise, the image is rotated
around the point in 2D space specified by the anchor 
point. The anchor point is drawn in black.

The rotation angle is specified in degrees with a positive
angle being counter-clockwise.

The number of points is initially set to six and the 
number of loops is initially set to one.  Making the 
number of points larger and making the number of loops 
larger produces many interesting patterns.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;

class StringArt02{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class StringArt02
//======================================================//

class GUI extends JFrame implements ActionListener{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 300;
  int vSize = 470;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas 
  Graphics2D g2D;//off-screen graphics context.

  JTextField numberPointsField;//User input field.
  JTextField loopsField;//User input field.
  int numberPoints = 6;//Can be modified by the user.
  int loopLim = 1;//Can be modified by the user.
  
  JTextField rotationField;//User input field
  double rotation;//Rotation angle in degrees clockwise.
  
  JTextField xAnchorPointField;//User input field
  JTextField yAnchorPointField;//User input field
  double xAnchorPoint;//Rotation anchor point.
  double yAnchorPoint;//Rotation anchor point.
  
  //The following variable is used to refer to an array
  // object containing the points that define the
  // vertices of a geometric object.
  GM01.Point2D[] points;
  
  //----------------------------------------------------//
  
  GUI(){//constructor
    //Instantiate the array object that will be used to
    // store the points that define the vertices of the
    // geometric object.
    points = new GM01.Point2D[numberPoints];
  
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
    //Instantiate the user input components.
    numberPointsField =new JTextField("6");
    loopsField = new JTextField("1");
    rotationField = new JTextField("0");
    xAnchorPointField = new JTextField("0");
    yAnchorPointField = new JTextField("0");
    JButton button = new JButton("Replot");

    //Instantiate a JPanel that will house the user input
    // components and set its layout manager.
    JPanel controlPanel = new JPanel();
    controlPanel.setLayout(new GridLayout(0,2));

    //Add the user input components and appropriate labels
    // to the control panel.
    controlPanel.add(new JLabel(" Number Points"));    
    controlPanel.add(numberPointsField);
    controlPanel.add(new JLabel(" Number Loops"));
    controlPanel.add(loopsField);
    controlPanel.add(new JLabel(
                               " Rotation angle (deg)"));
    controlPanel.add(rotationField);
    controlPanel.add(new JLabel(" X anchor point"));
    controlPanel.add(xAnchorPointField);
    controlPanel.add(new JLabel(" Y anchor point"));
    controlPanel.add(yAnchorPointField);
    controlPanel.add(button);

    //Add the control panel to the SOUTH position in the
    // JFrame.
    this.getContentPane().add(
                         BorderLayout.SOUTH,controlPanel);
    
    //Create a new drawing canvas and add it to the
    // CENTER of the JFrame above the control panel.
    myCanvas = new MyCanvas();
    this.getContentPane().add(
                            BorderLayout.CENTER,myCanvas);

    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    
    //Make the size of the off-screen image match the
    // size of the canvas.
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();
    
    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    g2D = (Graphics2D)(osi.getGraphics());
    
    //Erase the off-screen image, establish the origin,
    // and draw the axes
    setCoordinateFrame(g2D,true);

    //Create the Point2D objects that define the geometric
    // object and manipulate them to produce the desired
    // results.
    drawOffScreen(g2D);
    
    //Register this object as an action listener on the
    // button.
    button.addActionListener(this);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();
    
  }//end constructor
  //----------------------------------------------------//
  
  //The purpose of this method is to Create the Point2D
  // objects that define the vertices of a geometric
  // object and manipulate them to produce the desired
  // results.
  void drawOffScreen(Graphics2D g2D){
    //Erase the off-screen image and draw new axes, but
    // don't move the origin.
    setCoordinateFrame(g2D,false);

    //Create a set of Point2D objects that specify
    // locations on the circumference of a circle that
    // is in the x-y plane with a radius of 50 units. Save
    // references to the Point2D objects in an array.
    for(int cnt = 0;cnt &lt; numberPoints;cnt++){
      points[cnt] = new GM01.Point2D(new GM01.ColMatrix2D(
        50*Math.cos((cnt*360/numberPoints)*Math.PI/180),
        50*Math.sin((cnt*360/numberPoints)*Math.PI/180)));
     
      //The following object is populated with the 2D 
      // coordinates of the point around which the 
      //rotations will take place.
      GM01.Point2D anchorPoint = new GM01.Point2D(
                            new GM01.ColMatrix2D(
                              xAnchorPoint,yAnchorPoint));
      //Draw the anchorPoint in BLACK.
      g2D.setColor(Color.BLACK);
      anchorPoint.draw(g2D);
      
      //The following statement causes the rotation to be 
      //performed.
      points[cnt] = 
                 points[cnt].rotate(anchorPoint,rotation);

    }//end for loop
    
    //Implement the algorithm that draws lines connecting
    // points on the geometric object.
    GM01.Line2D line;
    
    //Begin the outer loop.
    for(int loop = 1;loop &lt;= loopLim;loop++){
      //The following variable specifies the array
      // element containing a point on which a line will
      // start.
      int start = -1;
      
      //The following variable specifies the number of
      // points that will be skipped between the starting
      // point and the ending point for a line.
      int skip = loop;
      //The following logic causes the element number to
      // wrap around when it reaches the end of the
      // array.
      while(skip &gt;= 2*numberPoints-1){
        skip -= numberPoints;
      }//end while loop
      
      //The following variable specifies the array
      // element containing a point on which a line will
      // end.
      int end = start + skip;

      //Begin inner loop. This loop actually constructs
      // the GM01.Line2D objects and causes visual
      // manifestations of those objects to be drawn on
      // the off-screen image. Note the requirement to
      // wrap around when the element numbers exceed the
      // length of the array.
      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        if(start &lt; numberPoints-1){
          start++;
        }else{
          //Wrap around
          start -= (numberPoints-1);
        }//end else
        
        if(end &lt; numberPoints-1){
          end++;
        }else{
          //Wrap around.
          end -= (numberPoints-1);
        }//end else
        
        //Create some interesting colors.
        g2D.setColor(new Color(cnt*255/numberPoints,
                               127+cnt*64/numberPoints,
                               255-cnt*255/numberPoints));
        
        //Create a line that connects points on the
        // geometric object.
        line = new GM01.Line2D(points[start],points[end]);
        line.draw(g2D);
      }//end inner loop
    }//end outer loop

  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to set the origin of the
  // off-screen image to the center and to draw orthogonal
  // 2D axes on the image that intersect at the origin.
  //The second parameter is used to determine if the
  // origin should be translated to the center.
  private void setCoordinateFrame(
                        Graphics2D g2D,boolean translate){

    //Translate the origin to the center if translate is
    // true.
    if(translate){
      GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    }//end if
    
    //Erase the screen
    g2D.setColor(Color.WHITE);
    GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.Point2D pointA = new GM01.Point2D(
                   new GM01.ColMatrix2D(-osiWidth/2,0));
    GM01.Point2D pointB = new GM01.Point2D(
                    new GM01.ColMatrix2D(osiWidth/2,0));
    new GM01.Line2D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = new GM01.Point2D(
                  new GM01.ColMatrix2D(0,-osiHeight/2));
    pointB = new GM01.Point2D(
                   new GM01.ColMatrix2D(0,osiHeight/2));
    new GM01.Line2D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
  //----------------------------------------------------//
  
  //This method is called to respond to a click on the
  // button.
  public void actionPerformed(ActionEvent e){
    //Get user input values and use them to modify several
    // values that control the drawing.
    numberPoints = Integer.parseInt(
                             numberPointsField.getText());

    loopLim = Integer.parseInt(loopsField.getText());
    
    //Rotation angle in degrees.
    rotation = 
             Double.parseDouble(rotationField.getText());

    //Rotation anchor points
    xAnchorPoint = 
          Double.parseDouble(xAnchorPointField.getText());
    yAnchorPoint = 
          Double.parseDouble(yAnchorPointField.getText());

    //Instantiate a new array object with a length
    // that matches the new value for numberPoints.    
    points = new GM01.Point2D[numberPoints];

    //Draw a new off-screen image based on user inputs.
    drawOffScreen(g2D);
    myCanvas.repaint();//Copy off-screen image to canvas.
  }//end actionPerformed
  //====================================================//
  
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the paint() method. This method will be
    // called when the JFrame and the Canvas appear on the
    // screen or when the repaint method is called on the
    // Canvas object.
    //The purpose of this method is to display the
    // off-screen image on the screen.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
    
  }//end inner class MyCanvas
    
}//end class GUI
//======================================================//
</code>






<para id="p1341">
<emphasis id="strong1304" effect="bold">
<emphasis id="Listing_32" effect="bold">

Listing 32

</emphasis>

. Source code for the program named StringArt03.

</emphasis>
</para>





<code id="pre1034" display="block">/*StringArt03.java 
Copyright 2008, R.G.Baldwin
Revised 02/22/08

This is a 3D version of a string art program that supports
rotation in three dimensions.

This program produces a 3D string art image by connecting
various points that are equally spaced on the 
circumference of a circle.

Initially, the circle is on the x-y plane centered on the 
origin. There are six points on the circle connected by
lines forming a hexagon, The lines that connect the points
are different colors. The radius of the circle is 50 
units. The points at the vertices of the hexagon are not 
drawn, but the lines that connect the vertices are drawn.

A GUI is provided that allows the user to specify the 
following items and click a Replot button to cause the 
drawing to change:

Number Points
Number Loops
Rotate around Z (deg)
Rotate around X (deg)
Rotate around Y (deg)
X Anchor point
Y Anchor point
Z Anchor point

Changing the number of points causes the number of 
vertices that describe the geometric object to change.

Changing the number of loops causes the number of lines
that are drawn to connect the vertices to change. For a
value of 1, each vertex is connected to the one next to
it. For a value of 2, additional lines are drawn 
connecting every other vertex. For a value of 3, 
additional lines are drawn connecting every third vertex,
etc.

The image can be rotated in any or all of three 
dimensions around an anchor point. Entering a non-zero 
value in one or more of the Rotate fields causes the 
image to be rotated by the specified angle or angles 
around the anchor point. The anchor point is initially
specified to be at the origin, but the location of the
anchor point can be changed by the user. If the anchor 
point is at the origin, the image is rotated around the 
origin. Otherwise, the image is rotated around the point
in 3D space specified by the anchor point. The anchor 
point is drawn in black.

The rotation angle is specified in degrees with a positive
angle being given by the right-hand rule as applied to the
axis around which the image is being rotated.

The rotational effects are cumulative. The image is first 
rotated around the anchor point in a direction consistent 
with rotation around the z-axis (rotation in the x-y 
plane). Then that rotated image is rotated in a direction 
consistent with rotation around the x-axis (rotation in 
the y-z plane). Finally, the previously rotated image is 
rotated in a direction consistent with rotation around the
y-axis (rotation in the x-z plane). It is important
to note, however, that the actual rotation is around the 
anchor point and not around the origin unless the anchor
point is at the origin.

The number of points is initially set to six and the 
number of loops is initially set to one.  Making the 
number of points larger and making the number of loops 
larger produces many interesting patterns.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;

class StringArt03{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class StringArt03
//======================================================//

class GUI extends JFrame implements ActionListener{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 300;
  int vSize = 470;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas 
  Graphics2D g2D;//Off-screen graphics context.

  JTextField numberPointsField;//User input field.
  JTextField loopsField;//User input field.
  int numberPoints = 6;//Can be modified by the user.
  int loopLim = 1;//Can be modified by the user.
  
  JTextField zRotationField;//User input field
  JTextField xRotationField;//User input field
  JTextField yRotationField;//User input field
  double zRotation;//Rotation around z in degrees.
  double xRotation;//Rotation around x in degrees.
  double yRotation;//Rotation around y in degrees
  
  JTextField xAnchorPointField;//User input field
  JTextField yAnchorPointField;//User input field
  JTextField zAnchorPointField;//User input field
  double xAnchorPoint;//Rotation anchor point.
  double yAnchorPoint;//Rotation anchor point.
  double zAnchorPoint;//Rotation anchor point.
  
  
  //The following variable is used to refer to an array
  // object containing the points that define the
  // vertices of a geometric object.
  GM01.Point3D[] points;
  
  //----------------------------------------------------//
  
  GUI(){//constructor
    //Instantiate the array object that will be used to
    // store the points that define the vertices of the
    // geometric object.
    points = new GM01.Point3D[numberPoints];
  
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
    //Instantiate the user input components.
    numberPointsField =new JTextField("6");
    loopsField = new JTextField("1");
    zRotationField = new JTextField("0");
    xRotationField = new JTextField("0");
    yRotationField = new JTextField("0");
    xAnchorPointField = new JTextField("0");
    yAnchorPointField = new JTextField("0");
    zAnchorPointField = new JTextField("0");
    JButton button = new JButton("Replot");

    //Instantiate a JPanel that will house the user input
    // components and set its layout manager.
    JPanel controlPanel = new JPanel();
    controlPanel.setLayout(new GridLayout(0,2));

    //Add the user input components and appropriate labels
    // to the control panel.
    controlPanel.add(new JLabel(" Number Points"));    
    controlPanel.add(numberPointsField);
    controlPanel.add(new JLabel(" Number Loops"));
    controlPanel.add(loopsField);
    controlPanel.add(new JLabel(
                               " Rotate around Z (deg)"));
    controlPanel.add(zRotationField);
    controlPanel.add(new JLabel(
                               " Rotate around X (deg)"));
    controlPanel.add(xRotationField);
    controlPanel.add(new JLabel(
                               " Rotate around Y (deg)"));
    controlPanel.add(yRotationField);
    controlPanel.add(new JLabel(" X anchor point"));
    controlPanel.add(xAnchorPointField);
    controlPanel.add(new JLabel(" Y anchor point"));
    controlPanel.add(yAnchorPointField);
    controlPanel.add(new JLabel(" Z anchor point"));
    controlPanel.add(zAnchorPointField);
    controlPanel.add(button);

    //Add the control panel to the SOUTH position in the
    // JFrame.
    this.getContentPane().add(
                         BorderLayout.SOUTH,controlPanel);
    
    //Create a new drawing canvas and add it to the
    // CENTER of the JFrame above the control panel.
    myCanvas = new MyCanvas();
    this.getContentPane().add(
                            BorderLayout.CENTER,myCanvas);

    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    
    //Make the size of the off-screen image match the
    // size of the canvas.
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();
    
    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    g2D = (Graphics2D)(osi.getGraphics());
    
    //Erase the off-screen image, establish the origin,
    // and draw the axes
    setCoordinateFrame(g2D,true);

    //Create the Point3D objects that define the geometric
    // object and manipulate them to produce the desired
    // results.
    drawOffScreen(g2D);
    
    //Register this object as an action listener on the
    // button.
    button.addActionListener(this);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();
    
  }//end constructor
  //----------------------------------------------------//
  
  //The purpose of this method is to Create the Point3D
  // objects that define the vertices of a geometric
  // object and manipulate them to produce the desired
  // results.
  void drawOffScreen(Graphics2D g2D){
    //Erase the off-screen image and draw new axes, but
    // don't move the origin.
    setCoordinateFrame(g2D,false);


    //Create a set of Point3D objects that specify
    // locations on the circumference of a circle that
    // is in the x-y plane with a radius of 50 units. Save
    // references to the Point3D objects in an array.
    for(int cnt = 0;cnt &lt; numberPoints;cnt++){
      points[cnt] = new GM01.Point3D(
        new GM01.ColMatrix3D(
          50*Math.cos((cnt*360/numberPoints)*Math.PI/180),
          50*Math.sin((cnt*360/numberPoints)*Math.PI/180),
          0.0));

      //The following ColMatrix3D object must be populated
      // with three rotation angles in degrees that
      // specify the following rotational angles in order
      // according to the right-hand rule as applied to 
      // the indicated axis.
      // Rotate around z
      // Rotate around x
      // Rotate around y
      GM01.ColMatrix3D angles = new GM01.ColMatrix3D(
                           zRotation,xRotation,yRotation);
      
      //The following object contains the 3D coordinates
      // of the point around which the rotations will
      // take place.
      GM01.Point3D anchorPoint = new GM01.Point3D(
               new GM01.ColMatrix3D(
                 xAnchorPoint,yAnchorPoint,zAnchorPoint));
      //Draw the anchorPoint in BLACK.
      g2D.setColor(Color.BLACK);
      anchorPoint.draw(g2D);
      
      //The following statement causes the rotation to be 
      //performed.
      points[cnt] = 
                   points[cnt].rotate(anchorPoint,angles);

    }//end for loop
    
    //Implement the algorithm that draws lines connecting
    // points on the geometric object.
    GM01.Line3D line;
    
    //Begin the outer loop.
    for(int loop = 1;loop &lt;= loopLim;loop++){
      //The following variable specifies the array
      // element containing a point on which a line will
      // start.
      int start = -1;
      
      //The following variable specifies the number of
      // points that will be skipped between the starting
      // point and the ending point for a line.
      int skip = loop;
      //The following logic causes the element number to
      // wrap around when it reaches the end of the
      // array.
      while(skip &gt;:= 2*numberPoints-1){
        skip -= numberPoints;
      }//end while loop
      
      //The following variable specifies the array
      // element containing a point on which a line will
      // end.
      int end = start + skip;

      //Begin inner loop. This loop actually constructs
      // the GM01.Line3D objects and causes visual
      // manifestations of those objects to be drawn on
      // the off-screen image. Note the requirement to
      // wrap around when the element numbers exceed the
      // length of the array.
      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        if(start &lt; numberPoints-1){
          start++;
        }else{
          //Wrap around
          start -= (numberPoints-1);
        }//end else
        
        if(end &lt; numberPoints-1){
          end++;
        }else{
          //Wrap around.
          end -= (numberPoints-1);
        }//end else
        
        //Create some interesting colors.
        g2D.setColor(new Color(cnt*255/numberPoints,
                               127+cnt*64/numberPoints,
                               255-cnt*255/numberPoints));
        
        //Create a line that connects points on the
        // geometric object.
        line = new GM01.Line3D(points[start],points[end]);
        line.draw(g2D);
      }//end inner loop
    }//end outer loop

  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to set the origin of the
  // off-screen image to the center and to draw orthogonal
  // 3D axes on the image that intersect at the origin.
  //The second parameter is used to determine if the
  // origin should be translated to the center.
  private void setCoordinateFrame(
                        Graphics2D g2D,boolean translate){

    //Translate the origin to the center if translate is
    // true.
    if(translate){
      GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    }//end if
    
    //Erase the screen
    g2D.setColor(Color.WHITE);
    GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.Point3D pointA = new GM01.Point3D(
                   new GM01.ColMatrix3D(-osiWidth/2,0,0));
    GM01.Point3D pointB = new GM01.Point3D(
                    new GM01.ColMatrix3D(osiWidth/2,0,0));
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = new GM01.Point3D(
                  new GM01.ColMatrix3D(0,-osiHeight/2,0));
    pointB = new GM01.Point3D(
                   new GM01.ColMatrix3D(0,osiHeight/2,0));
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw z-axis in BLUE. Make its length the same as the
    // length of the x-axis.
    g2D.setColor(Color.BLUE);
    pointA = new GM01.Point3D(
                   new GM01.ColMatrix3D(0,0,-osiWidth/2));
    pointB = new GM01.Point3D(
                    new GM01.ColMatrix3D(0,0,osiWidth/2));
    new GM01.Line3D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
  //----------------------------------------------------//
  
  //This method is called to respond to a click on the
  // button.
  public void actionPerformed(ActionEvent e){
    //Get user input values and use them to modify several
    // values that control the drawing.
    numberPoints = Integer.parseInt(
                             numberPointsField.getText());

    loopLim = Integer.parseInt(loopsField.getText());
    
    //Rotation around z in degrees.
    zRotation = 
             Double.parseDouble(zRotationField.getText());
    //Rotation around x in degrees.
    xRotation = 
             Double.parseDouble(xRotationField.getText());
    //Rotation around y in degrees
    yRotation = 
             Double.parseDouble(yRotationField.getText());

    //Rotation anchor points
    xAnchorPoint = 
          Double.parseDouble(xAnchorPointField.getText());
    yAnchorPoint = 
          Double.parseDouble(yAnchorPointField.getText());
    zAnchorPoint = 
          Double.parseDouble(zAnchorPointField.getText());

    //Instantiate a new array object with a length
    // that matches the new value for numberPoints.    
    points = new GM01.Point3D[numberPoints];

    //Draw a new off-screen image based on user inputs.
    drawOffScreen(g2D);
    myCanvas.repaint();//Copy off-screen image to canvas.
  }//end actionPerformed
  //====================================================//
  
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the paint() method. This method will be
    // called when the JFrame and the Canvas appear on the
    // screen or when the repaint method is called on the
    // Canvas object.
    //The purpose of this method is to display the
    // off-screen image on the screen.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
    
  }//end inner class MyCanvas
    
}//end class GUI
//======================================================//
</code>






</section>
<section id="h11012">
<title>
<emphasis id="Exercises" effect="bold">

Exercises

</emphasis>


</title>




<section id="h21008">
<title>
<emphasis id="Exercise_1" effect="bold">

Exercise 1

</emphasis>


</title>




<para id="p1342">
Using Java and the game-math library named 

<emphasis id="strong1305" effect="bold">
GM01

</emphasis>
, or using a 
different programming environment of your choice, write a program that creates and draws a 
20-level stepped pyramid as shown in 

<link id="a1264" target-id="Figure_20">

Figure 20

</link>

.

</para>




<para id="p1343">
Each level is a box.

The dimensions of the bottom box are:

</para>




<list id="ul1023" list-type="bulleted">

	

<item id="li1167">
width = 100 pixels

</item>


	

<item id="li1168">
height = 200/20 pixels

</item>


	

<item id="li1169">
depth = 100 pixels

</item>




</list>




<para id="p1344">
The height of each box is the same. The decrease in the width and 
depth dimensions of the boxes is linear going from the largest 
box at the bottom to the smallest box at the top.

</para>




<para id="p1345">
The sides of the pyramid may be transparent or opaque - 
your choice.



</para>




<para id="p1346">
The bottom box sits on the x-z plane, is centered on
the vertical axis, and the sides are parallel with the
x and z axes. 

</para>




<para id="p1347">
Draw the axes in the approximate location shown in 

<link id="a1265" target-id="Figure_20">

Figure 20

</link>

 in red, green, and blue.

</para>




<para id="p1348">
The positive direction for x is to the right. The positive direction for y is 
up, and the positive direction for z protrudes from the screen (down and to the 
left).

</para>




<para id="p1349">
Display your name in the drawing in some manner.

</para>




<para id="p1350">
<emphasis id="Figure_20" effect="bold">


<emphasis id="strong1306" effect="bold">
Figure 20

</emphasis>
</emphasis>


<emphasis id="strong1307" effect="bold">
 Screen output from Exercise 1.

</emphasis>
</para>




<para id="p1351">
<media id="media1016" alt="Missing image." display="block">
<image id="img1016" mime-type="image/jpeg" src="../../media/0135ex01.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21009">
<title>
<emphasis id="Exercise_2" effect="bold">

Exercise 2

</emphasis>


</title>




<para id="p1352">
Beginning with the pyramid that you created in 

<link id="a1266" target-id="Exercise_1">

Exercise 
1

</link>

, create a replica of that pyramid positioned at a point that is twice the 
width of the bottom box from the origin in the positive x direction.

</para>




<para id="p1353">
Draw that pyramid in red as shown in 

<link id="a1267" target-id="Figure_21">

Figure 21

</link>

.

</para>




<para id="p1354">
<emphasis id="Figure_21" effect="bold">


<emphasis id="strong1308" effect="bold">
Figure 21

</emphasis>
</emphasis>


<emphasis id="strong1309" effect="bold">
 Screen output from Exercise 2.

</emphasis>
</para>




<para id="p1355">
<media id="media1017" alt="Missing image." display="block">
<image id="img1017" mime-type="image/jpeg" src="../../media/0135ex02.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21010">
<title>
<emphasis id="Exercise_3" effect="bold">

Exercise 3

</emphasis>


</title>








<para id="p1356">
Beginning with the two pyramids that you created in 

<link id="a1268" target-id="Exercise_2">

Exercise 
2

</link>

, rotate the red pyramid by -30 degrees around an imaginary vertical line 
at the center of the pyramid as shown in 

<link id="a1269" target-id="Figure_22">

Figure 22

</link>

.

</para>




<para id="p1357">
<emphasis id="Figure_22" effect="bold">


<emphasis id="strong1310" effect="bold">
Figure 22

</emphasis>
</emphasis>


<emphasis id="strong1311" effect="bold">
 Screen output from Exercise 3.

</emphasis>
</para>




<para id="p1358">
<media id="media1018" alt="Missing image." display="block">
<image id="img1018" mime-type="image/jpeg" src="../../media/0135ex03.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21011">
<title>
<emphasis id="Exercise_4" effect="bold">

Exercise 4

</emphasis>


</title>








<para id="p1359">
Beginning with the two pyramids that you created in 

<link id="a1270" target-id="Exercise_2">

Exercise 
2

</link>

, rotate each box around an imaginary vertical line at the center of the 
pyramid by a negative angle with a progressively greater 
magnitude so that the rotation of the bottom box is zero and the rotation of the 
top box is approximately -85 degrees as shown in 

<link id="a1271" target-id="Figure_23">

Figure 23

</link>

. 
This produces a 3D object similar to a spiral staircase with the length of each 
step being less than the length of the step below it.

</para>




<para id="p1360">
<emphasis id="Figure_23" effect="bold">


<emphasis id="strong1312" effect="bold">
Figure 23

</emphasis>
</emphasis>


<emphasis id="strong1313" effect="bold">
 Screen output from Exercise 4.

</emphasis>
</para>




<para id="p1361">
<media id="media1019" alt="Missing image." display="block">
<image id="img1019" mime-type="image/jpeg" src="../../media/0135ex04.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21012">
<title>
<emphasis id="Exercise_5" effect="bold">

Exercise 5

</emphasis>


</title>








<para id="p1362">
Beginning with the two pyramids that you created in 

<link id="a1272" target-id="Exercise_2">

Exercise 
2

</link>

, rotate each box in the red pyramid around an imaginary line that is parallel to the 
z-axis and lies in the x-z plane at the center of the bottom box as shown in


<link id="a1273" target-id="Figure_24">

Figure 24

</link>

.

</para>




<para id="p1363">
Make the rotation angles for each box progressively larger in such a way that 
the rotation of the bottom box is zero and the rotation of the top box is 
approximately 28 degrees.

</para>




<para id="p1364">
<emphasis id="Figure_24" effect="bold">


<emphasis id="strong1314" effect="bold">
Figure 24

</emphasis>
</emphasis>


<emphasis id="strong1315" effect="bold">
 Screen output from Exercise 5.

</emphasis>
</para>




<para id="p1365">
<media id="media1020" alt="Missing image." display="block">
<image id="img1020" mime-type="image/jpeg" src="../../media/0135ex05.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21013">
<title>
<emphasis id="Exercise_6" effect="bold">

Exercise 6

</emphasis>


</title>








<para id="p1366">
Beginning with the two pyramids that you created in 

<link id="a1274" target-id="Exercise_2">

Exercise 
2

</link>

, rotate each box in the red pyramid around the 
z-axis as shown in 

<link id="a1275" target-id="Figure_25">

Figure 25

</link>

.

</para>




<para id="p1367">
Make the rotation angles for each box progressively larger in such a way that 
the rotation of the bottom box is zero and the rotation of the top box is 
approximately 28 degrees.

</para>




<para id="p1368">
<emphasis id="Figure_25" effect="bold">


<emphasis id="strong1316" effect="bold">
Figure 25

</emphasis>
</emphasis>


<emphasis id="strong1317" effect="bold">
 Screen output from Exercise 6.

</emphasis>
</para>




<para id="p1369">
<media id="media1021" alt="Missing image." display="block">
<image id="img1021" mime-type="image/jpeg" src="../../media/0135ex06.jpg" width="451" height="451"/>
</media>


</para>


	

<para id="p1370">
-end- 

</para>






</section>
</section>
</content>




</document>