<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>GAME 2302-0140: Our First 3D Game Program</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m45017</md:content-id>
  <md:title>GAME 2302-0140: Our First 3D Game Program</md:title>
  <md:abstract>Learn how to write your first interactive 3D game using the game-math library.  Also learn how to write a Java program that simulates flocking behavior such as that exhibited by birds and fish and how to incorporate that behavior in a game.</md:abstract>
  <md:uuid>f8ad0391-9b3a-4918-a15b-bf7c49b81111</md:uuid>
</metadata>

<content>

















<section id="h11000">
<title>
Table of Contents

</title>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" target-id="Preface">

Preface

</link>


	

<list id="ul1001" list-type="bulleted">

		

<item id="li1001">
<link id="a1001" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1002" list-type="bulleted">

			

<item id="li1002">
<link id="a1002" target-id="Figures">

Figures

</link>


</item>


			

<item id="li1003">
<link id="a1003" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>


	

<item id="li1004">
<link id="a1004" target-id="Preview">

Preview

</link>

 

</item>


	

<item id="li1005">
<link id="a1005" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


<list id="ul1003" list-type="bulleted">

		

<item id="li1006">
<link id="a1006" target-id="The_game-math_library_named_GM01">

The game-math library named GM01

</link>




</item>


		

<item id="li1007">
<link id="a1007" target-id="The_program_named_GM01test08">

The game program named GM01test08
		

</link>




</item>


		

<item id="li1008">
<link id="a1008" target-id="The_program_named_GM01test04">

The program named GM01test04

</link>




</item>


		

<item id="li1009">
<link id="a1009" target-id="The_program_named_GM01test03">

The program named GM01test03
		

</link>




</item>


		

<item id="li1010">
<link id="a1010" target-id="The_program_namedStringArt04">

The program namedStringArt04

</link>


</item>


	

</list>


	

</item>


	

<item id="li1011">
<link id="a1011" target-id="Homework_assignment">

Homework assignment

</link>


</item>


	

<item id="li1012">
<link id="a1012" target-id="Run_the_program">

Run the programs

</link>


</item>


	

<item id="li1013">
<link id="a1013" target-id="Summary">

Summary

</link>

 

</item>


	

<item id="li1014">
<link id="a1014" target-id="Whats_next">

What's next?

</link>


</item>


	

<item id="li1015">
<link id="a1015" target-id="Miscellaneous">

Miscellaneous

</link>


</item>


	

<item id="li1016">
<link id="a1016" target-id="Complete_program_listing">

Complete program listings

</link>


</item>


	

<item id="li1017">
<link id="a1017" target-id="Exercises">

Exercises

</link>


<list id="ul1004" list-type="bulleted">

		

<item id="li1018">
<link id="a1018" target-id="Exercise_1">

Exercise 1

</link>


</item>


		

<item id="li1019">
<link id="a1019" target-id="Exercise_2">

Exercise 2

</link>


</item>


		

<item id="li1020">
<link id="a1020" target-id="Exercise_3">

Exercise 3

</link>


</item>


		

<item id="li1021">
<link id="a1021" target-id="Exercise_4">

Exercise 4

</link>


</item>


		

<item id="li1022">
<link id="a1022" target-id="Exercise_5">

Exercise 5

</link>


</item>


	

</list>


	

</item>




</list>


	

	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	

	

<para id="p1000">
This module is one in a collection of modules designed for teaching 

<emphasis id="em1000" effect="italics">

	GAME2302 Mathematical Applications for Game Development

</emphasis>
 at Austin 
	Community College in Austin, TX. 

</para>




<para id="p1001">
<emphasis id="strong1000" effect="bold">
What you have learned

</emphasis>
</para>




<para id="p1002">
In the previous module, you learned how to update the game-math library to 
support 3D math, how to program the equations for projecting a 3D world onto a 
2D plane, how to add vectors in 3D, about scaling, translation, and rotation of 
a point in both 2D and 3D, about the rotation equations and how to implement 
them in both 2D and 3D, and much more.

</para>




<para id="p1003">
<emphasis id="strong1001" effect="bold">
What you will learn

</emphasis>
</para>




<para id="p1004">
In this module, you will learn how to write your first interactive 3D game 
using the game-math library named 

<emphasis id="strong1002" effect="bold">
GM01

</emphasis>
. You will also learn how to write 
a Java program that simulates flocking behavior such as that exhibited by birds 
and fish and how to incorporate that behavior into a game. Finally, you will 
examine three other programs that illustrate various aspects of both 2D and 3D 
animation using the game-math library.

</para>


	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1005">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and Listings while you are reading about them.

</para>


	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1005" list-type="bulleted">

		

<item id="li1023">
<link id="a1023" target-id="Figure_1">

Figure 1

</link>

. A school of red prey fish being attacked by a blue predator. 

</item>


		

<item id="li1024">
<link id="a1024" target-id="Figure_2">

Figure 2

</link>

. Screen shot of the graphic output from GM01test04. 

</item>


		

<item id="li1025">
<link id="a1025" target-id="Figure_3">

Figure 3

</link>

. Screen shot of the graphic output from GM01test03.

</item>


		

<item id="li1026">
<link id="a1026" target-id="Figure_4">

Figure 4

</link>

. Screen shot of the graphic output from StringArt04.

</item>


		

<item id="li1027">
<link id="a1027" target-id="Figure_5">

Figure 5

</link>

. Prey fish in a large swirling cluster. 

</item>


		

<item id="li1028">
<link id="a1028" target-id="Figure_6">

Figure 6

</link>

. Formation starting to break up due to closeness of the predator. 

</item>


		

<item id="li1029">
<link id="a1029" target-id="Figure_7">

Figure 7

</link>

. 100 prey fish trying to occupy the same location in 3D space. 

</item>


		

<item id="li1030">
<link id="a1030" target-id="Figure_8">

Figure 8

</link>

. 100 prey fish maintaining a reasonable separation in 3D space. 

</item>


		

<item id="li1031">
<link id="a1031" target-id="Figure_9">

Figure 9

</link>

. Twelve predators swimming in a hexagon formation in GM01test04. 

</item>


		

<item id="li1032">
<link id="a1032" target-id="Figure_10">

Figure 10

</link>

. Six predators swimming in a diamond formation. 

</item>


		

<item id="li1033">
<link id="a1033" target-id="Figure_11">

Figure 11

</link>

. Screen output from Exercise 1.

</item>


		

<item id="li1034">
<link id="a1034" target-id="Figure_12">

Figure 12.

</link>

 Screen output from Exercise 4.

</item>


		

<item id="li1035">
<link id="a1035" target-id="Figure_13">

Figure 13

</link>

. Screen output from Exercise 5.

</item>



	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1006" list-type="bulleted">

		

<item id="li1036">
<link id="a1036" target-id="Listing_1">

Listing 1

</link>

. Abbreviated constructor for the GUI class in GM01test08. 

</item>


		

<item id="li1037">
<link id="a1037" target-id="Listing_2">

Listing 2

</link>

. Beginning of the actionPerformed method in GM01test08. 

</item>


		

<item id="li1038">
<link id="a1038" target-id="Listing_3">

Listing 3

</link>

. Code that services the Attack button. 

</item>


		

<item id="li1039">
<link id="a1039" target-id="Listing_4">

Listing 4

</link>

. Code that services the Stop button.

</item>


		

<item id="li1040">
<link id="a1040" target-id="Listing_5">

Listing 5

</link>

. Beginning of the Animate class and the run method. 

</item>


		

<item id="li1041">
<link id="a1041" target-id="Listing_6">

Listing 6

</link>

. Create the population of prey fish. 

</item>


		

<item id="li1042">
<link id="a1042" target-id="Listing_7">

Listing 7

</link>

. Create and position the predator object. 

</item>


		

<item id="li1043">
<link id="a1043" target-id="Listing_8">

Listing 8

</link>

. A few more housekeeping details. 

</item>


		

<item id="li1044">
<link id="a1044" target-id="Listing_9">

Listing 9

</link>

. Beginning of the animation loop. 

</item>


		

<item id="li1045">
<link id="a1045" target-id="Listing_10">

Listing 10

</link>

. Cause all of the prey fish to spiral toward the center. 

</item>


		

<item id="li1046">
<link id="a1046" target-id="Listing_11">

Listing 11

</link>

. Create a rotated vector. 

</item>


		

<item id="li1047">
<link id="a1047" target-id="Listing_12">

Listing 12

</link>

. Move the prey fish object based on the sum of the vectors. 

</item>


		

<item id="li1048">
<link id="a1048" target-id="Listing_13">

Listing 13

</link>

. Save a clone of the relocated prey fish object. 

</item>


		

<item id="li1049">
<link id="a1049" target-id="Listing_14">

Listing 14

</link>

. Save a normalized direction vector. 

</item>


		

<item id="li1050">
<link id="a1050" target-id="Listing_15">

Listing 15

</link>

. Code for when the population contains only one prey fish. 

</item>


		

<item id="li1051">
<link id="a1051" target-id="Listing_16">

Listing 16

</link>

. Separate the prey fish. 

</item>


		

<item id="li1052">
<link id="a1052" target-id="Listing_17">

Listing 17

</link>

. The remainder of the inner loop. 

</item>


		

<item id="li1053">
<link id="a1053" target-id="Listing_18">

Listing 18

</link>

. Save the primary prey fish object and do another iteration. 

</item>


		

<item id="li1054">
<link id="a1054" target-id="Listing_19">

Listing 19

</link>

. Prey fish objects react to the predator. 

</item>


		

<item id="li1055">
<link id="a1055" target-id="Listing_20">

Listing 20

</link>

. Prey fish object takes evasive action. 

</item>


		

<item id="li1056">
<link id="a1056" target-id="Listing_21">

Listing 21

</link>

. Test the separation again. 

</item>


		

<item id="li1057">
<link id="a1057" target-id="Listing_22">

Listing 22

</link>

. Restore the prey fish to the population. 

</item>


		

<item id="li1058">
<link id="a1058" target-id="Listing_23">

Listing 23

</link>

. Keep the prey fish in the playing field. 

</item>


		

<item id="li1059">
<link id="a1059" target-id="Listing_24">

Listing 24

</link>

. Erase the off-screen image and draw the large circle. 

</item>


		

<item id="li1060">
<link id="a1060" target-id="Listing_25">

Listing 25

</link>

. Draw the prey fish on the off-screen image. 

</item>


		

<item id="li1061">
<link id="a1061" target-id="Listing_26">

Listing 26

</link>

. Cause the predator to slowly circle the cluster of prey fish. 

</item>


		

<item id="li1062">
<link id="a1062" target-id="Listing_27">

Listing 27

</link>

. Execute the attack. 

</item>


		

<item id="li1063">
<link id="a1063" target-id="Listing_28">

Listing 28

</link>

. Draw the predator on the off-screen image.

</item>


		

<item id="li1064">
<link id="a1064" target-id="Listing_29">

Listing 29

</link>

. Copy off-screen image, insert time delay, etc. 

</item>


		

<item id="li1065">
<link id="a1065" target-id="Listing_30">

Listing 30

</link>

. Source code for the game-math library named GM01. 

</item>


		

<item id="li1066">
<link id="a1066" target-id="Listing_31">

Listing 31

</link>

. Source code for the game program named GM01test08.

</item>


		

<item id="li1067">
<link id="a1067" target-id="Listing_32">

Listing 32

</link>

. Source code for the program named GM01test04.

</item>


		

<item id="li1068">
<link id="a1068" target-id="Listing_33">

Listing 33

</link>

. Source code for the program named GM01test03. 

</item>


		

<item id="li1069">
<link id="a1069" target-id="Listing_34">

Listing 34

</link>

. Source code for the program named StringArt04.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>


	

<para id="p1006">
It's time to kick back and have a little fun with what you have learned. 
	In this module, I will present four programs, 

<emphasis id="em1001" effect="italics">
(one of which is an 
	interactive 3D game)

</emphasis>
, that use the current capabilities of the 
	game-math library to produce some fairly serious animation. The programs are 
	named:

</para>




<list id="ul1007" list-type="bulleted">

	

<item id="li1070">
GM01test08

</item>


	

<item id="li1071">
GM01test04

</item>


	

<item id="li1072">
GM01test03

</item>


	

<item id="li1073">
StringArt04

</item>




</list>




<para id="p1007">
I will explain the game program in detail and will provide a brief 
description of the other three programs. 

</para>




<para id="p1008">
<emphasis id="strong1003" effect="bold">
GM01test08

</emphasis>
</para>




<para id="p1009">
The first three programs are based on an 

<emphasis id="em1002" effect="italics">



<link id="a1070" url="http://en.wikipedia.org/wiki/Artificial_life">

artificial life

</link>

 

</emphasis>

concept frequently referred to as 

<emphasis id="em1003" effect="italics">
<link id="a1071" url="http://www.red3d.com/cwr/boids/">


boids

</link>


</emphasis>
, which is 

<emphasis id="em1004" effect="italics">
"a computer model of coordinated animal motion such 
as bird flocks and fish schools."

</emphasis>
</para>







	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1004" effect="bold">
Flocking fish:

</emphasis>

				

<para id="p1010">
I got the idea for this game while watching a segment of a documentary series named Blue Earth on one of the cable channels. I even surprised myself as to how well I was able to simulate some of the scenes in that TV program using programming concepts similar to those used by Reynolds in boids.

</para>


				

</note>

			


		



	



	

<para id="p1011">
<emphasis id="strong1005" effect="bold">
A flocking game program

</emphasis>
</para>




<para id="p1012">
Although the flocking algorithms won't be the same as those used in the 
original boids program written by Reynolds, the general concepts will be 
similar.

</para>




<para id="p1013">
The first program named 

<emphasis id="strong1006" effect="bold">
GM01test08

</emphasis>
 is an interactive 3D game program 
based on the flocking behavior of fish. This game simulates a school of prey 
fish being attacked and eaten by a predator. The objective for the player is to 
cause the predator to catch and eat all of the prey fish in a minimum amount of 
time.

</para>




<para id="p1014">
<emphasis id="strong1007" effect="bold">
A preview

</emphasis>
</para>




<para id="p1015">
I will get into a lot more detail about the game aspects of the program 
later. For a preview, 

<link id="a1072" target-id="Figure_1">

Figure 1

</link>

 shows the instant in time when a school of 500 
prey fish 

<emphasis id="em1005" effect="italics">
(shown in red)

</emphasis>
 have just been attacked by the blue predator 
shown near the center right.

</para>




<para id="p1016">
<emphasis id="Figure_1" effect="bold">


<emphasis id="strong1008" effect="bold">
Figure 1

</emphasis>
</emphasis>


<emphasis id="strong1009" effect="bold">
 A school of red prey fish being attacked by a blue predator.

</emphasis>
</para>




<para id="p1017">
<media id="media1000" alt="Missing image." display="block">
<image id="img1000" mime-type="image/jpeg" src="../../media/java1712a4.jpg" width="401" height="451"/>
</media>


</para>





<para id="p1018">
The predator in 

<link id="a1073" target-id="Figure_1">

Figure 1

</link>

 has penetrated the school of fish by swimming from 
left to right, eating fish all along the way, and has emerged from the right 
side of the school. The prey fish, which were originally in a small tight 
cluster, have reacted to the presence of the predator by scattering in an 
attempt to avoid being eaten.

</para>




<para id="p1019">
<emphasis id="strong1010" effect="bold">
Fully three-dimensional

</emphasis>
</para>




<para id="p1020">
This game program is fully three-dimensional. Any or all of the fish are 
capable of swimming in any direction at any time in the 3D world. This is 
evidenced by the prey fish near the center that appear to have very short or 
non-existent tails. The fish that appear to have no tails actually have tails 
that are the same length as the tails on all of the other fish. These fish 
appear to have no tails because they are swimming either directly toward or 
directly away from the viewer. I will have more to say about this later.

</para>




<para id="p1021">
<emphasis id="strong1011" effect="bold">
GM01test04 and GM01test03

</emphasis>
</para>




<para id="p1022">
These two programs provide essentially the same behavior 

<emphasis id="em1006" effect="italics">
(as one another)

</emphasis>
, 
except that one is a 2D program and the other is a 3D program. They are not game 
programs. Rather, they are demonstration programs that show another aspect of 
flocking behavior. In these two programs, a large number of predators pursue a 
single prey object.

</para>




<para id="p1023">
A screen shot of the animated output from the 2D version is shown in 

<link id="a1074" target-id="Figure_2">

Figure 2

</link>

 
and a screen shot of the output from the 3D version is shown in 

<link id="a1075" target-id="Figure_3">

Figure 3

</link>

.

</para>




<para id="p1024">
<emphasis id="Figure_2" effect="bold">


<emphasis id="strong1012" effect="bold">
Figure 2

</emphasis>
</emphasis>


<emphasis id="strong1013" effect="bold">
 Screen shot of the graphic output from GM01test04.

</emphasis>
</para>




<para id="p1025">
<media id="media1001" alt="Missing image." display="block">
<image id="img1001" mime-type="image/jpeg" src="../../media/java1712a1.jpg" width="401" height="401"/>
</media>


</para>




<para id="p1026">
<emphasis id="Figure_3" effect="bold">


<emphasis id="strong1014" effect="bold">
Figure 3

</emphasis>
</emphasis>


<emphasis id="strong1015" effect="bold">
 Screen shot of the graphic output from GM01test03.

</emphasis>
</para>




<para id="p1027">
<media id="media1002" alt="Missing image." display="block">
<image id="img1002" mime-type="image/jpeg" src="../../media/java1712a2.jpg" width="401" height="401"/>
</media>


</para>




<para id="p1028">
I included these two programs in this module primarily to provide a good 
comparison between 2D and 3D, both from a programming viewpoint and a behavior 
viewpoint.

</para>




<para id="p1029">
<emphasis id="strong1016" effect="bold">
Eight predator objects and one prey object

</emphasis>
</para>




<para id="p1030">
In both versions shown in 

<link id="a1076" target-id="Figure_2">

Figure 2

</link>

 and 

<link id="a1077" target-id="Figure_3">

Figure 3

</link>

, you see eight predator 
objects 

<emphasis id="em1007" effect="italics">
(colored black)

</emphasis>
 pursuing a red prey object. The actual length of 
every predator object is the same as the length of every other predator object 
and the length of the prey object is the same as the length of the predator 
objects.

</para>




<para id="p1031">
<emphasis id="strong1017" effect="bold">
Some significant differences

</emphasis>
</para>




<para id="p1032">
At first glance, the two versions may look the same. However, they are 
significantly different. In 

<link id="a1078" target-id="Figure_2">

Figure 2

</link>

, the prey and the predators are constrained 
to move in a single plane. Hence, the apparent length of each predator is the 
same as the length of every other predator and is also the same as the length of 
the prey regardless of the direction in which the object is moving.

</para>




<para id="p1033">
However, in 

<link id="a1079" target-id="Figure_3">

Figure 3

</link>

, the predators and the prey are free to move in any 
direction in a 3D world. As a result, at any point in time, the objects may be 
moving parallel to or at an angle to the x-y plane. When the 3D world is 
projected onto the viewing plane, those objects that are moving at an angle to 
the viewing plane will be foreshortened. In the extreme case, 

<emphasis id="em1008" effect="italics">
(as shown 
earlier in 

<link id="a1080" target-id="Figure_1">

Figure 1

</link>

)

</emphasis>
, when an object is moving directly toward or directly 
away from the viewer, its apparent length will go to zero. 

<emphasis id="em1009" effect="italics">
(At least one 
predator is almost in that state in 

<link id="a1081" target-id="Figure_3">

Figure 3

</link>

.)

</emphasis>
</para>




<para id="p1034">
In 

<link id="a1082" target-id="Figure_3">

Figure 3

</link>

 the apparent lengths of the predator and prey objects are all 
different indicating that they are all moving in slightly different directions 
in the 3D world.

</para>




<para id="p1035">
The flocking algorithms in these two programs are much simpler than the 
algorithm used in 

<link id="a1083" target-id="Figure_1">

Figure 1

</link>

. I encourage you to experiment with the flocking 
algorithms for these two programs to see what you can produce that is new and 
different from my version of the two programs.

</para>




<para id="p1036">
<emphasis id="strong1018" effect="bold">
StringArt04

</emphasis>
</para>




<para id="p1037">
The fourth program named 

<emphasis id="strong1019" effect="bold">
StringArt04

</emphasis>
 is completely different from the 
other three programs. In a previous module, I presented and explained a program 
that rotates a disk around an arbitrary anchor point in 3D space with the 
ability to rotate by different angles around each of the three axes. It can be 
very difficult to visualize exactly what is happening with such complex 
rotations. This program animates the rotation process and runs it in slow motion 
so that you can see exactly what is happening as the disk moves and rotates from 
its initial position and orientation to its final position and orientation.

</para>




<para id="p1038">
For example. set the values as follows, click the 

<emphasis id="strong1020" effect="bold">
Animate

</emphasis>
 
button, and watch the rotations take place.

</para>




<list id="ul1008" list-type="bulleted">

	

<item id="li1074">
Number Points = 24

</item>


	

<item id="li1075">
Number Loops = 10

</item>


	

<item id="li1076">
Rotate around Z (deg) = 360

</item>


	

<item id="li1077">
Rotate around X (deg) = 360

</item>


	

<item id="li1078">
Rotate around Y (deg) = 360

</item>


	

<item id="li1079">
X anchor point = 50

</item>


	

<item id="li1080">
Y anchor point = 0

</item>


	

<item id="li1081">
Z anchor point = 0

</item>




</list>




<para id="p1039">
This should give you a good idea as to the process. Then change the 
parameters to other values, click the button, and observe the results.

</para>




<para id="p1040">
It is also useful to set only one of the rotation angles to a non-zero value 
and watch the rotation around a line parallel to that axis take place.

</para>




<para id="p1041">
<emphasis id="strong1021" effect="bold">
A stop-action screen shot

</emphasis>
</para>




<para id="p1042">
<link id="a1084" target-id="Figure_4">

Figure 4

</link>

 shows a screen shot of the disk in motion 
somewhere between the beginning and the end of its very complex trajectory for 
one particular set of rotation and anchor point parameters.

</para>




<para id="p1043">
<emphasis id="Figure_4" effect="bold">


<emphasis id="strong1022" effect="bold">
Figure 4

</emphasis>
</emphasis>


<emphasis id="strong1023" effect="bold">
 Screen shot of the graphic output from StringArt04.

</emphasis>
</para>




<para id="p1044">
<media id="media1003" alt="Missing image." display="block">
<image id="img1003" mime-type="image/jpeg" src="../../media/java1712a3.jpg" width="301" height="471"/>
</media>


</para>




<para id="p1045">
<emphasis id="strong1024" effect="bold">
Exercises

</emphasis>
</para>




<para id="p1046">
I will also provide exercises for you to complete on your own at the end of 
the module. The exercises will concentrate on the material that you have learned 
in this and previous modules.

</para>


	

	

</section>
<section id="h11003">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	

	

<section id="h21001">
<title>
<emphasis id="The_game-math_library_named_GM01" effect="bold">

The game-math library named 
	GM01

</emphasis>


</title>




<para id="p1047">
The game-math library named 

<emphasis id="strong1025" effect="bold">
GM01

</emphasis>
 has not been modified since I 
presented and explained it in an earlier module titled 


<link id="a1085" url="http://cnx.org/content/m45016/latest/">

GAME 2302-0135: Venturing into a 3D World

</link>

. A copy of the source code for 
the library is provided in 

<link id="a1086" target-id="Listing_30">

Listing 30

</link>

 for your convenience. 
Since I 
have explained the code in the library in earlier modules, I won't repeat those 
explanations here. 

</para>




<para id="p1048">
A link to a zip file containing documentation for the library was provided in 
the 

<link id="a1087" url="http://cnx.org/content/m45016/latest/">

earlier

</link>

 module.

</para>




</section>
<section id="h21002">
<title>
<emphasis id="The_program_named_GM01test08" effect="bold">

The game program named GM01test08

</emphasis>


</title>




<para id="p1049">
This is an interactive 3D game program. In fact, this is the first game 
program that I have presented in this collection on game math. This game 
simulates a school of prey fish being attacked and eaten by a predator. The 
objective for the player is to cause the predator to eat all of the prey fish in 
a minimum amount of time. Although the story line of the game is rather simple, 
the math involved is not simple at all.

</para>




<para id="p1050">
<emphasis id="strong1026" effect="bold">
Player initiates attacks

</emphasis>
</para>




<para id="p1051">
The player in this game initiates a series of attacks by the predator by 
clicking the 

<emphasis id="strong1027" effect="bold">
Attack

</emphasis>
 button shown in 

<link id="a1088" target-id="Figure_5">

Figure 5

</link>

. The winning strategy for 
the player is to time the attacks in such a way as to minimize the elapsed time 
required for the predator to eat all of the prey fish. The final elapsed time 
depends on both strategy and chance. In other words, as is the case in many 
games, this game is part strategy and part chance.

</para>




<para id="p1052">
<emphasis id="strong1028" effect="bold">
A swirling cluster of prey fish

</emphasis>
</para>




<para id="p1053">
The prey fish, 

<emphasis id="em1010" effect="italics">
(shown in red)

</emphasis>
, tend to swim in a large swirling 
cluster as shown in 

<link id="a1089" target-id="Figure_5">

Figure 5

</link>

 when they aren't being harassed by the predator.

</para>




<para id="p1054">
<emphasis id="Figure_5" effect="bold">


<emphasis id="strong1029" effect="bold">
Figure 5

</emphasis>
</emphasis>


<emphasis id="strong1030" effect="bold">
 Prey fish in a large swirling cluster.

</emphasis>
</para>




<para id="p1055">
<media id="media1004" alt="Missing image." display="block">
<image id="img1004" mime-type="image/jpeg" src="../../media/java1712a5.jpg" width="401" height="451"/>
</media>


</para>




<para id="p1056">
<emphasis id="strong1031" effect="bold">
Predator behavior

</emphasis>
</para>




<para id="p1057">
The predator, 

<emphasis id="em1011" effect="italics">
(shown in blue in 

<link id="a1090" target-id="Figure_5">

Figure 5

</link>

)

</emphasis>
, swims around the cluster, 
darting into and through the cluster when the user clicks the 

<emphasis id="strong1032" effect="bold">
Attack

</emphasis>
 
button. During an attack, the predator attempts to eat as many prey fish as 
possible. When the predator attacks, the prey fish tend to scatter 

<emphasis id="em1012" effect="italics">
(as shown 
in 

<link id="a1091" target-id="Figure_1">

Figure 1

</link>

)

</emphasis>
, breaking up their tight formation and making it more difficult 
for the predator to catch them. If the predator is allowed to swim around them 
again for a short period following an attack, they will form back into a 
cluster.

</para>




<para id="p1058">
<emphasis id="strong1033" effect="bold">
Proper timing is important

</emphasis>
</para>




<para id="p1059">
The attacks should be timed so that the prey fish are in a reasonably tight 
cluster at the beginning of each attack so that multiple prey fish will be eaten 
during the attack. However, allowing too much time between attacks is 
detrimental because it increases the total elapsed time. Thus, the player must 
make a tradeoff between elapsed time between attacks and the tightness of the 
cluster at the beginning of each attack. Another 

<emphasis id="disadvantage" effect="bold">


disadvantage

</emphasis>

 of waiting too long between attacks will be explained later.

</para>




<para id="p1060">
<emphasis id="strong1034" effect="bold">
The graphical user interface

</emphasis>
</para>




<para id="p1061">
In addition to some other controls, the GUI provides an 

<emphasis id="strong1035" effect="bold">
Attack

</emphasis>
 button 
and an 

<emphasis id="em1013" effect="italics">
elapsed-time/kill-count

</emphasis>
 indicator, shown in the bottom right in 


<link id="a1092" target-id="Figure_5">

Figure 5

</link>

. At any point in time, this indicator displays the elapsed time in 
milliseconds when the most recent prey fish was eaten along with the total 
number of prey fish that have been eaten. The two values are separated by a "/" 
character.

</para>




<para id="p1062">
When all of the prey fish have been eaten by the predator, the elapsed time 
indicator shows the time in milliseconds required for the predator to catch and 
eat all of the prey fish. It also shows the number of prey fish that were eaten, 
which should match the value that the player entered into the upper-right text 
field before starting the game. 

<emphasis id="em1014" effect="italics">
(This field contains 500 in 

<link id="a1093" target-id="Figure_1">

Figure 1

</link>

 and 200 
in 

<link id="a1094" target-id="Figure_5">

Figure 5

</link>

)

</emphasis>
.

</para>




<para id="p1063">
<emphasis id="strong1036" effect="bold">
Not initially in attack mode

</emphasis>
</para>




<para id="p1064">
When the player clicks the 

<emphasis id="strong1037" effect="bold">
Start

</emphasis>
 button and the game begins, the 
predator is not in attack mode. Rather, the predator swims around the school of 
prey fish encouraging them to bunch up into a smaller and tighter cluster as 
shown in 

<link id="a1095" target-id="Figure_5">

Figure 5

</link>

. The purpose of this behavior is to increase the number of 
fish that will be eaten when an attack is made.

</para>




<para id="p1065">
<emphasis id="strong1038" effect="bold">
The attack will be more or less successful

</emphasis>
</para>




<para id="p1066">
This circling behavior on the part of the predator continues until the player 
clicks the 

<emphasis id="strong1039" effect="bold">
Attack

</emphasis>
 button, at which time the predator enters the attack 
mode and makes an attack on the cluster as shown in 

<link id="a1096" target-id="Figure_1">

Figure 1

</link>

. If the player 
clicks the 

<emphasis id="strong1040" effect="bold">
Attack

</emphasis>
 button too early, or doesn't wait long enough between 
attacks, the prey fish will be in a loose cluster and the predator will eat very 
few fish during the attack.

</para>




<para id="p1067">
<emphasis id="strong1041" effect="bold">
The predator always has an impact

</emphasis>
</para>




<para id="p1068">
Even when the predator is not in attack mode, its presence has a significant 
effect on the behavior of the school of prey fish. As the predator swims around 
the prey fish, they tend to bunch up into a smaller and tighter cluster, but 
when the predator swims too close, the prey fish tend to panic and scatter, 
breaking up the tight cluster as shown in 

<link id="a1097" target-id="Figure_6">

Figure 6

</link>

.

</para>




<para id="p1069">
Therefore, if the player waits too long to click the 

<emphasis id="strong1042" effect="bold">
Attack

</emphasis>
 button or 
waits too long between attacks, the predator will have spiraled in so close to 
the prey fish that they will break formation and begin to scatter, making it 
difficult for the predator to eat a large number of fish during the next attack. 
This is the other disadvantage of waiting too long to attack that I mentioned


<link id="a1098" target-id="disadvantage">

earlier

</link>

. 

</para>




<para id="p1070">
<emphasis id="strong1043" effect="bold">
Formation starting to break up due to closeness of the predator

</emphasis>
</para>




<para id="p1071">
<link id="a1099" target-id="Figure_6">

Figure 6

</link>

 shows the formation starting to break up because the predator has 
strayed too close to the cluster of prey fish. 

<emphasis id="em1015" effect="italics">
(The fish in the upper right 
of the formation have pulled out of the cluster and have started to flee the 
predator.)

</emphasis>
</para>




<para id="p1072">
<emphasis id="Figure_6" effect="bold">


<emphasis id="strong1044" effect="bold">
Figure 6

</emphasis>
</emphasis>


<emphasis id="strong1045" effect="bold">
 Formation starting to break up due to closeness of the predator.

</emphasis>
</para>




<para id="p1073">
<media id="media1005" alt="Missing image." display="block">
<image id="img1005" mime-type="image/jpeg" src="../../media/java1712a6.jpg" width="401" height="451"/>
</media>


</para>




<para id="p1074">
<emphasis id="strong1046" effect="bold">
An effective defense mechanism

</emphasis>
</para>




<para id="p1075">
The prey fish have a fairly effective defense mechanism and can do a 
reasonably good job of escaping the predator. The predator can increase the odds 
of catching the prey fish by attacking very fast. 

<emphasis id="em1016" effect="italics">
(You can modify the code 
that controls the speed of the attack.)

</emphasis>
 If the predator goes into the 
formation slowly, the prey fish will simply run away as is starting to be the 
case in 

<link id="a1100" target-id="Figure_6">

Figure 6

</link>

.

</para>







	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1047" effect="bold">
Cleaning up the leftovers:

</emphasis>

				

<para id="p1076">
The final three or four prey fish are often the most difficult to catch because they have more room to run without colliding with another fish.

</para>


				

</note>

			


		



	



	


<para id="p1077">
<emphasis id="strong1048" effect="bold">
Captured fish are removed from the population

</emphasis>
</para>




<para id="p1078">
When the predator is successful in eating a prey fish, that fish is removed 
from the prey-fish population causing the prey-fish population to decrease over 
time. Also, each time the predator eats a prey fish, the program emits an 
audible beep to provide feedback to the player.

</para>




<para id="p1079">
<emphasis id="strong1049" effect="bold">
The other GUI components

</emphasis>
</para>




<para id="p1080">
In addition to the elapsed time indicator and the 

<emphasis id="strong1050" effect="bold">
Attack

</emphasis>
 button, the 
GUI contains an input text field by which the player can specify the number of 
prey fish that will be in the population when the game begins. The GUI also 
contains a 

<emphasis id="strong1051" effect="bold">
Start

</emphasis>
 button and a 

<emphasis id="strong1052" effect="bold">
Stop

</emphasis>
 button. Finally, the GUI 
contains check boxes that allow the player to display points only, direction 
vectors only, or both for the prey fish. 

<emphasis id="em1017" effect="italics">
(Only the direction vector is 
displayed for the predator.)

</emphasis>
</para>




<para id="p1081">
<emphasis id="strong1053" effect="bold">
Playing the game

</emphasis>
</para>




<para id="p1082">
In practice, the player specifies the number of randomly-placed prey fish 
that will be in the population and clicks the 

<emphasis id="strong1054" effect="bold">
Start

</emphasis>
 button to start the 
game. At this point, the prey fish swim in a large swirling cluster and the 
predator swims around them encouraging them to form a tighter cluster as shown 
in 

<link id="a1101" target-id="Figure_5">

Figure 5

</link>

.

</para>




<para id="p1083">
Prey fish motion is random but each prey fish generally tends to spiral 
toward the center of the cluster. When the user clicks the 

<emphasis id="strong1055" effect="bold">
Attack

</emphasis>
 button, 
the predator turns and swims rapidly into and through the center of the cluster 
of prey fish. If the predator manages to get to within a specified distance from 
a prey fish, that prey fish will be deemed to have been eaten, and will be 
removed from the population. However, each prey fish will sense that the 
predator is coming and will try to escape. Whether or not an individual prey 
fish manages to escape the predator when an encounter between the two occurs is 
based on a random number generator.

</para>




<para id="p1084">
<emphasis id="strong1056" effect="bold">
The Start and Stop buttons

</emphasis>
</para>




<para id="p1085">
The animation continues until all of the fish have been eaten or the user 
clicks the 

<emphasis id="strong1057" effect="bold">
Stop

</emphasis>
 button. The user can click the 

<emphasis id="strong1058" effect="bold">
Stop

</emphasis>
 button at any 
time, change any of the parameters, and then click the 

<emphasis id="strong1059" effect="bold">
Start

</emphasis>
 button again 
to re-start the game with zero elapsed time and different parameters.

</para>




<para id="p1086">
<emphasis id="strong1060" effect="bold">
Displaying the vectors

</emphasis>
</para>




<para id="p1087">
The animation is most impressive when the direction vectors are displayed for 
the prey fish because the vectors provide a lot of visual information about how 
the prey fish are reacting to the predator.

</para>




<para id="p1088">
<emphasis id="strong1061" effect="bold">
A spherical playing-field boundary

</emphasis>
</para>




<para id="p1089">
In addition to the school of prey fish and the predator, the graphical output 
also shows a large circle drawn with broken lines, as shown in 

<link id="a1102" target-id="Figure_5">

Figure 5

</link>

. This 
circle represents the intersection of a sphere and the x-y plane.

</para>




<para id="p1090">
The purpose of the sphere, which is centered on the origin, is to provide a 
soft boundary for keeping the prey fish and the predator inside the 3D playing 
field. The prey fish and the predator all have a tendency to remain inside the 
sphere, but they may occasionally stray outside the sphere. If they do, the 
program code will encourage them to return to the 3D playing field inside the 
sphere.

</para>




<para id="p1091">
<emphasis id="strong1062" effect="bold">
A 3D display

</emphasis>
</para>




<para id="p1092">
As mentioned earlier, this game is fully three dimensional. The prey fish and 
the predator are free to swim in any direction in 3D space. The tails on the 
prey fish and the predator appear longest when they are swimming parallel to the 
x-y plane. As they change their angle relative to the x-y plane, the tails 
appear to become shorter or longer and in some cases, they appear not to have a 
tail at all. The fish that appear to have no tails are either swimming directly 
toward the viewer or swimming directly away from the viewer.

</para>




<para id="p1093">
This can best be observed by clicking the 

<emphasis id="strong1063" effect="bold">
Stop

</emphasis>
 button just as the fish 
scatter during an attack and freezing the state of the fish in the 3D world as 
shown in 

<link id="a1103" target-id="Figure_1">

Figure 1

</link>

. If you examine the image at that point, you are likely to see 
some fish with shorter tails than other fish. This is evident by some of the 
prey fish near the center of 

<link id="a1104" target-id="Figure_1">

Figure 1

</link>

 that appear to have no tails at all. 

</para>




<para id="p1094">
<emphasis id="strong1064" effect="bold">
Enough talk, let's see some code

</emphasis>
</para>




<para id="p1095">
A complete listing of this program is provided in 

<link id="a1105" target-id="Listing_31">

Listing 31

</link>

 near the end of 
the module.

</para>




<para id="p1096">
Portions of this program are very similar to programs that I have explained 
in earlier modules in this series. I won't repeat those explanations here. 
Rather, I will concentrate mostly on the code that is new and different in this 
module.

</para>




<para id="p1097">
<emphasis id="strong1065" effect="bold">
Abbreviated constructor for the GUI class

</emphasis>
</para>




<para id="p1098">
<link id="a1106" target-id="Listing_1">

Listing 1

</link>

 shows an abbreviated constructor for the GUI class. 

<emphasis id="em1018" effect="italics">
(Much of the 
code in the constructor has been explained before, and was deleted from Listing 
1 for brevity.)

</emphasis>
</para>




	

<table id="table1000" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1000">

			

<row id="tr1000">

				

<entry id="th1000">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Abbreviated constructor for the GUI class in GM01test08. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1000">

			

<row id="tr1001">

				

<entry id="td1000">



<code id="pre1000" display="block">  GUI(){//constructor
  
//Code deleted for brevity

    //Register this object as an action listener on all
    // three buttons.
    startButton.addActionListener(this);
    attackButton.addActionListener(this);
    stopButton.addActionListener(this);
    
    //Make the drawing color RED at startup.
    g2D.setColor(Color.RED);

  }//end constructor
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1099">
If you examine 

<link id="a1107" target-id="Listing_31">

Listing 31

</link>

, you will see that the 

<emphasis id="strong1066" effect="bold">
GUI

</emphasis>
 class 
	implements the 

<emphasis id="strong1067" effect="bold">
ActionListener

</emphasis>
 interface. Therefore, an object of the
	

<emphasis id="strong1068" effect="bold">
GUI

</emphasis>
 class can be registered as an action listener on a button. 
	

<link id="a1108" target-id="Listing_1">

Listing 1

</link>

 registers the object of the 

<emphasis id="strong1069" effect="bold">
GUI

</emphasis>
 class as a listener on all 
	three of the buttons shown in 

<link id="a1109" target-id="Figure_6">

Figure 6

</link>

.

</para>




<para id="p1100">
<emphasis id="strong1070" effect="bold">
Beginning of the actionPerformed method

</emphasis>
</para>




<para id="p1101">
The 

<emphasis id="strong1071" effect="bold">
actionPerformed

</emphasis>
 method that begins in 

<link id="a1110" target-id="Listing_2">

Listing 2

</link>

 is called whenever 
the player clicks any of the three buttons shown in 

<link id="a1111" target-id="Figure_6">

Figure 6

</link>

.

</para>




	

<table id="table1001" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1001">

			

<row id="tr1002">

				

<entry id="th1001">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. Beginning of the actionPerformed method in GM01test08. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1001">

			

<row id="tr1003">

				

<entry id="td1001">



<code id="pre1001" display="block">  public void actionPerformed(ActionEvent e){

    if(e.getActionCommand().equals("Start") &amp;&amp; !animate){
      //Service the Start button.
      
      //Get several user input values.
      numberPoints = Integer.parseInt(
                             numberPointsField.getText());

      if(drawPointsBox.getState()){
        drawPoints = true;
      }else{
        drawPoints = false;
      }//end else
      
      if(drawVectorsBox.getState()){
        drawVectors = true;
      }else{
        drawVectors = false;
      }//end else

      //Initialize some working variables used in the
      // animation process.
      animate = true;
      baseTime = new Date().getTime();
      killCount = 0;
      
      //Enable the Attack button.
      attackButton.setEnabled(true);
      
      //Initialize the text in the timer field.
      timer.setText("0 / 0");
      
      //Cause the run method belonging to the animation
      // thread object to be executed.
      new Animate().start();
    }//end if
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1102">
<emphasis id="strong1072" effect="bold">
Servicing the Start button

</emphasis>
</para>




<para id="p1103">
The code in 

<link id="a1112" target-id="Listing_2">

Listing 2

</link>

 is executed when the user clicks the 

<emphasis id="strong1073" effect="bold">
Start

</emphasis>
 
button. All of this code is also very similar to code that I have explained in 
previous modules, so further explanation beyond the embedded comments should not 
be necessary. However, I will emphasize two statements in 

<link id="a1113" target-id="Listing_2">

Listing 2

</link>

.

</para>




<para id="p1104">
The first statement that I will emphasize 

<emphasis id="em1019" effect="italics">
(about two-thirds of the way 
down)

</emphasis>
 enables the 

<emphasis id="strong1074" effect="bold">
Attack

</emphasis>
 button. The second 
statement 

<emphasis id="em1020" effect="italics">
(at the end)

</emphasis>
 instantiates a new object of the 

<emphasis id="strong1075" effect="bold">
Thread

</emphasis>
 
class named 

<emphasis id="strong1076" effect="bold">
Animate

</emphasis>
 and causes the 

<emphasis id="strong1077" effect="bold">
run

</emphasis>
 method of the animation 
thread to be executed. I will explain the animation thread later.

</para>




<para id="p1105">
<emphasis id="strong1078" effect="bold">
Code that services the Attack button

</emphasis>
</para>




<para id="p1106">
The code in 

<link id="a1114" target-id="Listing_3">

Listing 3

</link>

 is executed when the player clicks the 

<emphasis id="strong1079" effect="bold">
Attack

</emphasis>
 
button after it is enabled by the code in 

<link id="a1115" target-id="Listing_2">

Listing 2

</link>

.

</para>




	

<table id="table1002" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1002">

			

<row id="tr1004">

				

<entry id="th1002">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Code that services the Attack button. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1002">

			

<row id="tr1005">

				

<entry id="td1002">



<code id="pre1002" display="block">    if(e.getActionCommand().equals("Attack") &amp;&amp; animate){

      attack = true;

      predatorVec = 
               predator.getDisplacementVector(preyCenter).
                                               scale(1.0);
               
      //Disable the Attack button. It will be enabled
      // again when the attack is finished.
      attackButton.setEnabled(false);
    }//end if
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1107">
<link id="a1116" target-id="Listing_3">

Listing 3

</link>

 begins by setting the value of the variable named 

<emphasis id="strong1080" effect="bold">
attack

</emphasis>
 
	to true. As you will see later, this causes the predator to attack the prey 
	fish in the animation loop.

</para>




<para id="p1108">
<emphasis id="strong1081" effect="bold">
Control the speed and direction of the predator attack

</emphasis>
</para>




<para id="p1109">
Then 

<link id="a1117" target-id="Listing_3">

Listing 3

</link>

 calls the 

<emphasis id="strong1082" effect="bold">
getDisplacementVector

</emphasis>
 method and the 

<emphasis id="strong1083" effect="bold">
scale

</emphasis>
 
method of the game-math library to set the value of the variable named 

<emphasis id="strong1084" effect="bold">

predatorVec

</emphasis>
 to a direction that will be used to point the predator toward 
the center of the prey-fish cluster. In 

<link id="a1118" target-id="Listing_3">

Listing 3

</link>

, the scale factor is 1.0, so 
the application of the scale factor does nothing. However, you can modify this 
value to control the speed of the predator during the upcoming attack. If you 
increase the scale factor, the predator will move faster. If you decrease the 
scale factor, the predator will move more slowly.

</para>




<para id="p1110">
<emphasis id="strong1085" effect="bold">
Temporarily disable the Attack button

</emphasis>
</para>




<para id="p1111">
Finally, 

<link id="a1119" target-id="Listing_3">

Listing 3

</link>

 temporarily disables the 

<emphasis id="strong1086" effect="bold">
Attack

</emphasis>
 button so that it 
will have no effect if the player clicks it again during the attack. You could 
also remove this statement, slow down the attack, and experiment with multiple 
clicks on the 

<emphasis id="strong1087" effect="bold">
Attack

</emphasis>
 button during the course of an attack to see what 
happens.

</para>




<para id="p1112">
<emphasis id="strong1088" effect="bold">
Code that services the Stop button

</emphasis>
</para>




<para id="p1113">
The code in 

<link id="a1120" target-id="Listing_4">

Listing 4

</link>

 is executed when the player clicks the 

<emphasis id="strong1089" effect="bold">
Stop

</emphasis>
 
button.

</para>




	

<table id="table1003" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">

				

<entry id="th1003">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Code that services the Stop button.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">



<code id="pre1003" display="block">    if(e.getActionCommand().equals("Stop") &amp;&amp; animate){
      
      //This will cause the run method to terminate and
      // stop the animation. It will also clear the
      // attack flag so that the next time the animation
      // is started, the predator won't be in the 
      // attack mode.
      animate = false;
      attack = false;
    }//end if

  }//end actionPerformed
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1114">
No explanation beyond the embedded comment should be required for this 
	code.

</para>




<para id="p1115">
<emphasis id="strong1090" effect="bold">
Beginning of the Animate class and the run method

</emphasis>
</para>




<para id="p1116">
When the 

<emphasis id="strong1091" effect="bold">
Start

</emphasis>
 button is clicked, the code in 

<link id="a1121" target-id="Listing_2">

Listing 2

</link>

 instantiates a 
new object of the 

<emphasis id="strong1092" effect="bold">
Thread

</emphasis>
 class named 

<emphasis id="strong1093" effect="bold">
Animate

</emphasis>
 and causes the 

<emphasis id="strong1094" effect="bold">
run

</emphasis>
 
method belonging to that object to be executed. 

<link id="a1122" target-id="Listing_5">

Listing 5

</link>

 shows the beginning of 
the 

<emphasis id="strong1095" effect="bold">
Animate

</emphasis>
 class and its 

<emphasis id="strong1096" effect="bold">
run

</emphasis>
 method.

</para>




	

<table id="table1004" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">

				

<entry id="th1004">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. Beginning of the Animate class and the run method. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">



<code id="pre1004" display="block">  class Animate extends Thread{
    //Declare a general purpose variable of type Point3D.
    // It will be used for a variety of purposes.
    GM01.Point3D tempPrey;
    
    //Declare two general purpose variables of type
    // Vector3D. They will be used for a variety of
    // purposes.
    GM01.Vector3D tempVectorA;
    GM01.Vector3D tempVectorB;
    //--------------------------------------------------//
    
    public void run(){
      //This method is executed when start is called on
      // this Thread object.
      //Create a new empty container for the prey objects.
      //Note the use of "Generics" syntax.
      preyObjects = new ArrayList&lt;GM01.Point3D&gt;();
      
      //Create a new empty container for the vectors. The
      // only reason the vectors are saved is so that they
      // can be displayed later
      displayVectors = new ArrayList&lt;GM01.Vector3D&gt;();
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1117">
<emphasis id="strong1097" effect="bold">
Importance of the game-math library named GM01

</emphasis>
</para>




<para id="p1118">
The code in 

<link id="a1123" target-id="Listing_5">

Listing 5

</link>

 is straightforward and shouldn't require an explanation 
beyond the embedded comments. However, I will emphasize the heavy use of the 
game-math library classes named 

<emphasis id="strong1098" effect="bold">
GM01.Point3D 

</emphasis>
and

<emphasis id="strong1099" effect="bold">
 GM01.Vector3D

</emphasis>
 in 
the code in 

<link id="a1124" target-id="Listing_5">

Listing 5

</link>

.

</para>




<para id="p1119">
This entire game program is heavily dependent on the use of the 

<emphasis id="strong1100" effect="bold">

ColMatrix3D

</emphasis>
, 

<emphasis id="strong1101" effect="bold">
Point3D

</emphasis>
, 

<emphasis id="strong1102" effect="bold">
Vector3D

</emphasis>
, and 

<emphasis id="strong1103" effect="bold">
Line3D

</emphasis>
 classes 
along with some of the static methods in the game-math library named 

<emphasis id="strong1104" effect="bold">
GM01

</emphasis>
. 
If you were to start from scratch and write this game program without the 
availability of the game-math library, the program would be much longer and 
would be much more complex.

</para>




<para id="p1120">
<emphasis id="strong1105" effect="bold">
Create the population of prey fish

</emphasis>
</para>




<para id="p1121">
<link id="a1125" target-id="Listing_6">

Listing 6

</link>

 creates the population of prey fish and positions them at random 
locations in 3D space. 

<link id="a1126" target-id="Listing_6">

Listing 6

</link>

 also stores references to the prey fish objects 
in the 

<emphasis id="strong1106" effect="bold">
preyObjects

</emphasis>
 container, which was created in 

<link id="a1127" target-id="Listing_5">

Listing 5

</link>

.

</para>


	


	

<table id="table1005" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1005">

			

<row id="tr1010">

				

<entry id="th1005">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. Create the population of prey fish. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1005">

			

<row id="tr1011">

				

<entry id="td1005">



<code id="pre1005" display="block">      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        preyObjects.add(new GM01.Point3D(
          new GM01.ColMatrix3D(
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5))));
                         
        //Populate the displayVectors collection with
        // dummy vectors.
        displayVectors.add(tempVectorA);
      }//end for loop
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1122">
In addition, 

<link id="a1128" target-id="Listing_6">

Listing 6

</link>

 populates a container named 

<emphasis id="strong1107" effect="bold">
displayVectors

</emphasis>
 
	that was also created in 

<link id="a1129" target-id="Listing_5">

Listing 5

</link>

 to store a direction vector belonging to 
	each prey fish. This container is populated with dummy vectors in 

<link id="a1130" target-id="Listing_6">

Listing 6

</link>

, 
	simply to set the size of the container to be the same as the size of the 
	container containing references to the prey fish objects. 

<emphasis id="em1021" effect="italics">
(There is 
	probably a more efficient way to set the size of that container.)

</emphasis>
</para>




<para id="p1123">
Note that each prey fish object is actually represented by an object of the 
game-math library class named 

<emphasis id="strong1108" effect="bold">
GM01.Point3D

</emphasis>
.

</para>




<para id="p1124">
<emphasis id="strong1109" effect="bold">
Create and position the predator object

</emphasis>
</para>




<para id="p1125">
<link id="a1131" target-id="Listing_7">

Listing 7

</link>

 creates an object of the 

<emphasis id="strong1110" effect="bold">
GM01.Point3D

</emphasis>
 class that will 
represent the predator in the game.

</para>




	

<table id="table1006" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1006">

			

<row id="tr1012">

				

<entry id="th1006">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

. Create and position the predator object. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1006">

			

<row id="tr1013">

				

<entry id="td1006">



<code id="pre1006" display="block">      predator = new GM01.Point3D(
                     new GM01.ColMatrix3D(-100,100,-100));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1126">
The initial position given to the predator in 

<link id="a1132" target-id="Listing_7">

Listing 7

</link>

 causes it to 
	appear in the game near the top center of the screen when the user clicks 
	the 

<emphasis id="strong1111" effect="bold">
Start

</emphasis>
 button. You could also make the initial position of the 
	predator random if you think that would improve the game.

</para>




<para id="p1127">
<emphasis id="strong1112" effect="bold">
A few more housekeeping details

</emphasis>
</para>




<para id="p1128">
<link id="a1133" target-id="Listing_8">

Listing 8

</link>

 takes care of a few more housekeeping details before the animation 
actually begins.

</para>




	

<table id="table1007" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1007">

			

<row id="tr1014">

				

<entry id="th1007">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

. A few more housekeeping details. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1007">

			

<row id="tr1015">

				

<entry id="td1007">



<code id="pre1007" display="block">      //Create a reference point to mark the origin. Among
      // other things, it will be used as the center of a
      // sphere, which in turn will be used to attempt to
      // keep the prey and predator objects from leaving
      // the playing field.
      GM01.Point3D origin = 
            new GM01.Point3D(new GM01.ColMatrix3D(0,0,0));
      
      //Declare some variables that will be used to
      // compute and save the average position of all of
      // the prey objects.
      double xSum = 0;
      double ySum = 0;
      double zSum = 0;</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1129">
<emphasis id="strong1113" effect="bold">
Let the show begin

</emphasis>
</para>




<para id="p1130">
<link id="a1134" target-id="Listing_9">

Listing 9

</link>

 shows the beginning of the animation loop, which will continue to 
execute for as long as the value of the variable named 

<emphasis id="strong1114" effect="bold">
animate

</emphasis>
 is true.

</para>




	

<table id="table1008" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1008">

			

<row id="tr1016">

				

<entry id="th1008">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

. Beginning of the animation loop. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1008">

			

<row id="tr1017">

				

<entry id="td1008">



<code id="pre1008" display="block">      while(animate){
        //Compute and save the average position of all the
        // prey objects at the beginning of the loop. Save
        // the average position in the Point3D object
        // referred to by preyCenter.
        xSum = 0;
        ySum = 0;
        zSum = 0;

        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          xSum += tempPrey.getData(0);
          ySum += tempPrey.getData(1);
          zSum += tempPrey.getData(2);
        }//end for loop
        
        //Construct a reference point at the average
        // position of all the prey objects.
        preyCenter = new GM01.Point3D(
           new GM01.ColMatrix3D(xSum/preyObjects.size(),
                                ySum/preyObjects.size(),
                                zSum/preyObjects.size()));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1131">
The value of 

<emphasis id="strong1115" effect="bold">
animate

</emphasis>
 is set to true by clicking the 

<emphasis id="strong1116" effect="bold">
Start

</emphasis>
 
	button and is set to false by clicking the 

<emphasis id="strong1117" effect="bold">
Stop

</emphasis>
 button. Setting the 
	value to false causes the 

<emphasis id="strong1118" effect="bold">
run

</emphasis>
 method to terminate, thereby stopping 
	the animation.

</para>




<para id="p1132">
<emphasis id="strong1119" effect="bold">
Attack toward the geometric center

</emphasis>
</para>




<para id="p1133">
When the predator attacks, it will move to and through the geometric center 
of the cluster of prey fish, eating prey fish all along the way. The geometric 
center of the cluster of prey fish is computed and saved by the code in 

<link id="a1135" target-id="Listing_9">

Listing 9

</link>

 as the average location of all the prey fish in the population.

</para>




<para id="p1134">
Note that a vector that points to the geometric center may or may not be a 
good indicator of the best direction for eating large numbers of prey fish 
during an attack. In 

<link id="a1136" target-id="Figure_1">

Figure 1

</link>

, for example, a predator attacking from the 11:00 
o'clock position and heading toward the center would encounter quite a few prey 
fish. However, a predator attacking from the 8:00 o'clock position and heading 
toward the center would encounter far fewer prey fish.

</para>




<para id="p1135">
You will also learn that although the predator will always attack in a 
direction pointing toward this geometric center, the positions of the prey fish 
can change after the center is computed and before the attack begins, causing 
the position of the actual geometric center to change, before the predator has 
an opportunity to attack. That can decrease the probability of a successful 
attack by the predator.

</para>




<para id="p1136">
These issues form part of the strategy of the game that must be mastered by 
the player in order to earn a good score.

</para>




<para id="p1137">
<emphasis id="strong1120" effect="bold">
Cause all of the prey fish to spiral toward the center

</emphasis>
</para>




<para id="p1138">
<link id="a1137" target-id="Listing_10">

Listing 10

</link>

 shows the beginning of a fairly complicated algorithm that causes 
all of the prey fish to have a tendency to spiral toward the center of the 
cluster of prey fish.

</para>




	

<table id="table1009" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1009">

			

<row id="tr1018">

				

<entry id="th1009">
<emphasis id="Listing_10" effect="bold">

Listing 10

</emphasis>

. Cause all of the prey fish to spiral toward the center. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1009">

			

<row id="tr1019">

				

<entry id="td1009">



<code id="pre1009" display="block">        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          if(preyObjects.size() &gt; 1){
            //Get the next prey object
            tempPrey = preyObjects.get(cnt);
            //Find the displacement vector from this prey
            // object to the preyCenter
            tempVectorA = tempPrey.getDisplacementVector(
                                              preyCenter);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1139">
The code in the body of the 

<emphasis id="strong1121" effect="bold">
for

</emphasis>
 loop that begins in 

<link id="a1138" target-id="Listing_10">

Listing 10

</link>

 is 
	executed once during each animation cycle for each of the prey fish in the 
	population of prey fish.

</para>




<para id="p1140">
To begin with, the 

<emphasis id="strong1122" effect="bold">
if

</emphasis>
 statement prevents the tendency to spiral toward 
the geometric center from being applied when there is only one prey fish 
remaining in the population. I will leave it as an exercise for the student to 
think about this and to decide whether or not this is a good decision.

</para>




<para id="p1141">
The code in 

<link id="a1139" target-id="Listing_10">

Listing 10

</link>

 gets a reference to the next prey fish object in the 
population and then gets and saves a reference to a displacement vector pointing 
from the prey fish to the geometric center.

</para>




<para id="p1142">
<emphasis id="strong1123" effect="bold">
Create a rotated vector.

</emphasis>
</para>




<para id="p1143">
<link id="a1140" target-id="Listing_11">

Listing 11

</link>

 creates, scales, and saves a new 

<emphasis id="strong1124" effect="bold">
GM01.Vector3D

</emphasis>
 object 
having the same component values as the displacement vector from 

<link id="a1141" target-id="Listing_11">

Listing 11

</link>

, but 
assigning those values to different axes.

</para>



	


	

<table id="table1010" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1010">

			

<row id="tr1020">

				

<entry id="th1010">
<emphasis id="Listing_11" effect="bold">

Listing 11

</emphasis>

. Create a rotated vector. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1010">

			

<row id="tr1021">

				

<entry id="td1010">



<code id="pre1010" display="block">            tempVectorB = new GM01.Vector3D(
              new GM01.ColMatrix3D(
                      tempVectorA.getData(1),
                      tempVectorA.getData(2),
                      tempVectorA.getData(0))).scale(1.2);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1144">
Once again, I will leave it as an exercise for the student to think about 
	the length and direction of such a vector in relation to the original 
	displacement vector. It might help to begin by drawing some vectors in 2D 
	that swap components and then extending the same thinking to 3D. One thing 
	is for certain, unless all of the components have the same value, the new 
	vector created in 

<link id="a1142" target-id="Listing_11">

Listing 11

</link>

 has a different length and direction than the 
	displacement vector created in 

<link id="a1143" target-id="Listing_10">

Listing 10

</link>

, and that would be true even if 
	the vector from 

<link id="a1144" target-id="Listing_11">

Listing 11

</link>

 had not been scaled.

</para>




<para id="p1145">
<emphasis id="strong1125" effect="bold">
Move the prey fish object based on the sum of the vectors

</emphasis>
</para>




<para id="p1146">
<link id="a1145" target-id="Listing_12">

Listing 12

</link>

 begins by adding the two vectors that were created in 

<link id="a1146" target-id="Listing_10">

Listing 10

</link>

 
and 

<link id="a1147" target-id="Listing_11">

Listing 11

</link>

, scaling the vector from 

<link id="a1148" target-id="Listing_10">

Listing 10

</link>

 before performing the 
addition. Note that the scale factors applied to the rotated vector in Listing 
11 is different from the scale factor applied to the original displacement 
vector in 

<link id="a1149" target-id="Listing_12">

Listing 12

</link>

. The ratio of these two scale factors influences the 
tendency of the prey fish object to move toward the center relative to its 
tendency to move around the center.

</para>





	

<table id="table1011" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1011">

			

<row id="tr1022">

				

<entry id="th1011">
<emphasis id="Listing_12" effect="bold">

Listing 12

</emphasis>

. Move the prey fish object based on the sum of the vectors. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1011">

			

<row id="tr1023">

				

<entry id="td1011">



<code id="pre1011" display="block">            tempVectorA = 
                  tempVectorA.scale(0.9).add(tempVectorB);

            tempPrey = tempPrey.addVectorToPoint(
                                  tempVectorA.scale(0.1));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1147">
Then 

<link id="a1150" target-id="Listing_12">

Listing 12

</link>

 calls the 

<emphasis id="strong1126" effect="bold">
GM01.Point3D.addVectorToPoint

</emphasis>
 method to 
	relocate the prey fish object to a new position based on the scaled sum of 
	the two vectors. The bottom line is that this will cause the prey fish 
	object to spiral toward the geometric center that was computed in 

<link id="a1151" target-id="Listing_9">

Listing 9

</link>

 
	as the animation progresses.

</para>




<para id="p1148">
Another scale factor is applied to the sum vector before using it to relocate 
the prey fish object. This scale factor controls the overall speed of the prey 
fish. Increasing the scale factor causes the prey fish to spiral faster. 

<emphasis id="em1022" effect="italics">

(Increasing the scale factor also causes some interesting patterns to appear and 
if you increase it too much, the prey fish will all leave the playing field.)

</emphasis>
</para>




<para id="p1149">
<emphasis id="strong1127" effect="bold">
Save a clone of the relocated prey fish object

</emphasis>
</para>




<para id="p1150">
<link id="a1152" target-id="Listing_13">

Listing 13

</link>

 creates a clone of the relocated prey fish object and uses it to 
replace the original prey fish object in the container.

</para>





	

<table id="table1012" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1012">

			

<row id="tr1024">

				

<entry id="th1012">
<emphasis id="Listing_13" effect="bold">

Listing 13

</emphasis>

. Save a clone of the relocated prey fish object. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1012">

			

<row id="tr1025">

				

<entry id="td1012">



<code id="pre1012" display="block">            preyObjects.set(cnt,tempPrey.clone());
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1151">
Creating and saving a reference to a clone instead of saving a reference 
	to the relocated prey fish object may be overkill. However, I simply wanted 
	to guard against the possibility of ending up with a corrupted object later 
	due to the repeated use of the reference variable. I will leave it up to the 
	student to think about this and to decide if this was a good or a bad 
	decision.

</para>




<para id="p1152">
<emphasis id="strong1128" effect="bold">
Save a normalized direction vector

</emphasis>
</para>




<para id="p1153">
<link id="a1153" target-id="Listing_14">

Listing 14

</link>

 calls the 

<emphasis id="strong1129" effect="bold">
GM01.Vector3D.normalize

</emphasis>
 method to create a vector 
having a length of 15 units and the same direction as the vector that was used 
to relocate the prey fish object.

</para>





	

<table id="table1013" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1013">

			

<row id="tr1026">

				

<entry id="th1013">
<emphasis id="Listing_14" effect="bold">

Listing 14

</emphasis>

. Save a normalized 
				direction vector. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1013">

			

<row id="tr1027">

				

<entry id="td1013">



<code id="pre1013" display="block">            displayVectors.set(
                 cnt,tempVectorA.normalize().scale(15.0));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1154">
This vector is saved and used for drawing later. Drawing this vector in 
	conjunction with the point that represents the prey fish object produces the 
	tails shown on the prey fish objects in 

<link id="a1154" target-id="Figure_1">

Figure 1

</link>

.

</para>




<para id="p1155">
<emphasis id="strong1130" effect="bold">
Code for when the population contains only one prey fish

</emphasis>
</para>




<para id="p1156">
<link id="a1155" target-id="Listing_15">

Listing 15

</link>

 shows the 

<emphasis id="strong1131" effect="bold">
else

</emphasis>
 clause that matches up with the 

<emphasis id="strong1132" effect="bold">
if

</emphasis>
 
statement in 

<link id="a1156" target-id="Listing_10">

Listing 10

</link>

. This code is executed when the population has been 
reduced to only one prey fish object.

</para>





	

<table id="table1014" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1014">

			

<row id="tr1028">

				

<entry id="th1014">
<emphasis id="Listing_15" effect="bold">

Listing 15

</emphasis>

. Code for when the population contains only one prey fish. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1014">

			

<row id="tr1029">

				

<entry id="td1014">



<code id="pre1014" display="block">          }else{
            displayVectors.set(
                   cnt,new GM01.Vector3D(
                          new GM01.ColMatrix3D(10,10,0)));
          }//end else
                 
        }//end loop to spiral prey objects toward center.
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1157">
<link id="a1157" target-id="Listing_15">

Listing 15

</link>

 saves a dummy direction vector for drawing later. This is 
	necessary to prevent a null pointer exception when the user specifies only 
	one prey fish object and then clicks the 

<emphasis id="strong1133" effect="bold">
Start

</emphasis>
 button.

</para>




<para id="p1158">
<emphasis id="strong1134" effect="bold">
Not the end of the story

</emphasis>
</para>




<para id="p1159">
<link id="a1158" target-id="Listing_15">

Listing 15

</link>

 also signals the end of the 

<emphasis id="strong1135" effect="bold">
for

</emphasis>
 loop that causes the prey 
fish to spiral toward the center. The code in this 

<emphasis id="strong1136" effect="bold">
for

</emphasis>
 loop is sometimes 
referred to as a 

<emphasis id="em1023" effect="italics">
cohesion

</emphasis>
 algorithm in flocking terminology. It causes 
the prey fish to stay together as a group.

</para>




<para id="p1160">
This is not the end of the story, however. If the code in this cohesion 
algorithm were the only code controlling the behavior of the prey fish in this 
animation, they would simply continue spiraling toward the center, eventually 
producing a cluster that looks something like that shown in 

<link id="a1159" target-id="Figure_7">

Figure 7

</link>

 where 100 
prey fish are trying to occupy the same location in 3D space.

</para>




<para id="p1161">
<emphasis id="Figure_7" effect="bold">


<emphasis id="strong1137" effect="bold">
Figure 7

</emphasis>
</emphasis>


<emphasis id="strong1138" effect="bold">
 100 prey fish trying to occupy the same location in 3D space.

</emphasis>
</para>




<para id="p1162">
<media id="media1006" alt="Missing image." display="block">
<image id="img1006" mime-type="image/jpeg" src="../../media/java1712a7.jpg" width="401" height="451"/>
</media>


</para>




<para id="p1163">
<emphasis id="strong1139" effect="bold">
Interesting but also boring

</emphasis>
</para>




<para id="p1164">
While it may be interesting to watch the animation progress to this point, 
the animation becomes very boring when all of the prey fish cluster at the 
center. What we need is an additional algorithm that will cause each prey fish 
to attempt to maintain a respectable distance between itself and the other prey 
fish.

</para>




<para id="p1165">
<emphasis id="strong1140" effect="bold">
Prey fish maintaining a reasonable separation

</emphasis>
</para>




<para id="p1166">
For example, 

<link id="a1160" target-id="Figure_8">

Figure 8

</link>

 shows the result of temporarily making each prey fish 
immune to the presence of the predator, telling each prey fish to spiral toward 
the center, and also telling each prey fish to maintain a separation of ten 
units 

<emphasis id="em1024" effect="italics">
(pixels)

</emphasis>
 between itself and all of the other prey fish.

</para>




<para id="p1167">
<emphasis id="Figure_8" effect="bold">


<emphasis id="strong1141" effect="bold">
Figure 8

</emphasis>
</emphasis>


<emphasis id="strong1142" effect="bold">
 100 prey fish maintaining a reasonable separation in 3D space.

</emphasis>
</para>




<para id="p1168">
<media id="media1007" alt="Missing image." display="block">
<image id="img1007" mime-type="image/jpeg" src="../../media/java1712a8.jpg" width="401" height="451"/>
</media>


</para>




<para id="p1169">
<emphasis id="strong1143" effect="bold">
A 3D world

</emphasis>
</para>




<para id="p1170">
Remember, 

<link id="a1161" target-id="Figure_8">

Figure 8

</link>

 is a 3D world projected onto on a 2D screen display. Even 
if every prey fish is separated from every other prey fish by at least ten 
pixels 

<emphasis id="em1025" effect="italics">
(which is probably not the case as I will explain later)

</emphasis>
, the 
projection of the 3D world onto the 2D display can make it appear that two or 
more prey fish occupy the same location.

</para>




<para id="p1171">
<emphasis id="strong1144" effect="bold">
Separate the prey fish

</emphasis>
</para>




<para id="p1172">
<link id="a1162" target-id="Listing_16">

Listing 16

</link>

 shows the beginning of a pair of nested 

<emphasis id="strong1145" effect="bold">
for

</emphasis>
 loops that 
attempt to keep the prey fish from colliding with one another by moving each 
prey fish object away from its close neighbors if necessary. In flocking 
terminology, this is often referred to as a 

<emphasis id="em1026" effect="italics">
separation

</emphasis>
 algorithm.

</para>





	

<table id="table1015" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1015">

			

<row id="tr1030">

				

<entry id="th1015">
<emphasis id="Listing_16" effect="bold">

Listing 16

</emphasis>

. Separate the prey fish. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1015">

			

<row id="tr1031">

				

<entry id="td1015">



<code id="pre1015" display="block">        GM01.Point3D refPrey = null;
        GM01.Point3D testPrey= null;
        for(int row = 0;row &lt; preyObjects.size();row++){
          refPrey = preyObjects.get(row);
          //Compare the position of the reference prey
          // object with the positions of each of the
          // other prey objects.
          for(int col = 0;col &lt; preyObjects.size();col++){
            //Get another prey object for  proximity test.
            testPrey = preyObjects.get(col);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1173">
This algorithm gets a reference to each prey fish object 

<emphasis id="em1027" effect="italics">
(primary 
	object)

</emphasis>
 and compares its position with the positions of all the other 
	prey fish objects 

<emphasis id="em1028" effect="italics">
(secondary objects)

</emphasis>
. If the primary object is too 
	close to a secondary object, the primary object is moved away from the 
	secondary object.

</para>




<para id="p1174">
<emphasis id="strong1146" effect="bold">
Not a perfect algorithm

</emphasis>
</para>




<para id="p1175">
This is not a perfect algorithm however. A primary object can be moved away 
from all of its neighbors early in the execution of the algorithm, but a 
neighbor could be moved closer to the primary object later in the execution of 
the algorithm. While not perfect, the algorithm does a pretty respectable job of 
keeping the prey fish separated as evidenced by comparing the positions of the 
prey fish in 

<link id="a1163" target-id="Figure_7">

Figure 7

</link>

 with the positions of the prey fish in 

<link id="a1164" target-id="Figure_8">

Figure 8

</link>

. This 

<emphasis id="em1029" effect="italics">

separation

</emphasis>
 algorithm was disabled in 

<link id="a1165" target-id="Figure_7">

Figure 7

</link>

 and was enabled in 

<link id="a1166" target-id="Figure_8">

Figure 8

</link>

.

</para>




<para id="p1176">
<emphasis id="strong1147" effect="bold">
Gets two objects that will be compared

</emphasis>
</para>




<para id="p1177">
<link id="a1167" target-id="Listing_16">

Listing 16

</link>

 gets a reference to a primary prey fish object in the outer loop 
that iterates on the counter named 

<emphasis id="strong1148" effect="bold">
row

</emphasis>
 and gets a reference to one of the 
secondary prey fish objects to which it will be compared in the inner loop that 
iterates on the counter named 

<emphasis id="strong1149" effect="bold">
col

</emphasis>
.

</para>




<para id="p1178">
<emphasis id="strong1150" effect="bold">
The remainder of the inner loop

</emphasis>
</para>




<para id="p1179">
<link id="a1168" target-id="Listing_17">

Listing 17

</link>

 shows the remainder of the inner loop.

</para>





	

<table id="table1016" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1016">

			

<row id="tr1032">

				

<entry id="th1016">
<emphasis id="Listing_17" effect="bold">

Listing 17

</emphasis>

. The remainder of the inner loop. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1016">

			

<row id="tr1033">

				

<entry id="td1016">



<code id="pre1016" display="block">            //Don't test a prey object against itself.
            if(col != row){
              //Get the vector from the refPrey object to
              // the testPrey object.
              tempVectorA = refPrey.
                          getDisplacementVector(testPrey);
              
              //If refPrey is too close to testPrey, move
              // it away from the testPrey object.
              if(tempVectorA.getLength() &lt; 10){
                //Move refPrey away from testPrey by a
                // small amount in the opposite direction.
                refPrey = refPrey.addVectorToPoint(
                         tempVectorA.scale(0.2).negate());

              }//end if on proximity test
            }//end if col != row
          }//end loop on col
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1180">
It wouldn't make any sense to compare the position of a prey fish with 
	itself, so the 

<emphasis id="strong1151" effect="bold">
if

</emphasis>
 statement in 

<link id="a1169" target-id="Listing_17">

Listing 17

</link>

 prevents that from 
	happening.

</para>




<para id="p1181">
<emphasis id="strong1152" effect="bold">
Code is relatively straightforward

</emphasis>
</para>




<para id="p1182">
Since you already know how to use most of the methods in the game-math 
library, you should have no difficulty understanding the code in 

<link id="a1170" target-id="Listing_17">

Listing 17

</link>

. 
This code:

</para>




<list id="ul1009" list-type="bulleted">

	

<item id="li1082">
gets the displacement vector that defines the separation between the 
	primary object and the secondary object,

</item>


	

<item id="li1083">
compares the length of that vector with 10 units, and

</item>


	

<item id="li1084">
moves the primary prey fish object in the opposite direction by 
	20-percent of the length of the separation vector if the separation is less 
	than 10 units.

</item>




</list>




<para id="p1183">
As mentioned earlier, however, moving the primary fish object away from one 
prey fish could cause it to be moved closer to a different prey fish object, so 
the separation algorithm is far from perfect.

</para>




<para id="p1184">
<link id="a1171" target-id="Listing_17">

Listing 17

</link>

 signals the end of the inner loop that began in 

<link id="a1172" target-id="Listing_16">

Listing 16

</link>

.

</para>




<para id="p1185">
<emphasis id="strong1153" effect="bold">
Save the primary prey fish object and do another iteration

</emphasis>
</para>




<para id="p1186">
The primary prey fish object may or may not have been moved. Regardless, a 
clone of that object is created and saved in the container that contains the 
prey-fish population in 

<link id="a1173" target-id="Listing_18">

Listing 18

</link>

.

</para>





	

<table id="table1017" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1017">

			

<row id="tr1034">

				

<entry id="th1017">
<emphasis id="Listing_18" effect="bold">

Listing 18

</emphasis>

. Save the primary prey fish object and do another iteration. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1017">

			

<row id="tr1035">

				

<entry id="td1017">



<code id="pre1017" display="block">          preyObjects.set(row,refPrey.clone());
        }//end loop on row
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1187">
After the object is saved in 

<link id="a1174" target-id="Listing_18">

Listing 18

</link>

, control is transferred back to 
	the top of the outer 

<emphasis id="strong1154" effect="bold">
for

</emphasis>
 loop in 

<link id="a1175" target-id="Listing_16">

Listing 16

</link>

 and the next prey fish 
	object in the population is compared with all of the other prey-fish objects 
	in the population, making corrections to the position of the prey fish as 
	necessary.

</para>




<para id="p1188">
<emphasis id="strong1155" effect="bold">
Prey fish objects react to the predator

</emphasis>
</para>




<para id="p1189">
As I mentioned earlier, each prey fish object has a reasonably good defense 
mechanism to avoid being eaten by the predator. However, in the final analysis, 
whether or not a prey fish will escape when it encounters the predator face to 
face is a random process. To some extent, success or failure to escape depends 
on how quickly the prey fish senses the presence of the predator.

</para>




<para id="p1190">
<link id="a1176" target-id="Listing_19">

Listing 19

</link>

 is the beginning of a 

<emphasis id="strong1156" effect="bold">
for

</emphasis>
 loop in which the proximity of 
each prey fish to the predator is tested and evasive action on the part of the 
prey fish is taken if the distance between the two is less than 50 units.

</para>





	

<table id="table1018" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1018">

			

<row id="tr1036">

				

<entry id="th1018">
<emphasis id="Listing_19" effect="bold">

Listing 19

</emphasis>

. Prey fish objects react to the predator. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1018">

			

<row id="tr1037">

				

<entry id="td1018">



<code id="pre1018" display="block">        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          
          //Get a displacement vector from the prey object
          // to the predator.
          tempVectorA = tempPrey.getDisplacementVector(
                                                predator);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1191">
The code in 

<link id="a1177" target-id="Listing_19">

Listing 19

</link>

 gets the next prey fish in the population and gets 
	a displacement vector describing the separation of the prey fish from the 
	predator.

</para>




<para id="p1192">
<emphasis id="strong1157" effect="bold">
Prey fish object takes evasive action

</emphasis>
</para>




<para id="p1193">
If the prey fish is at least 50 units away from the predator, the prey fish 
simply goes on swimming without concern for the predator. However, if the prey 
fish is less than 50 units away from the predator, the prey fish takes evasive 
action in an attempt to escape the predator. The evasive action is accomplished 
in 

<link id="a1178" target-id="Listing_20">

Listing 20

</link>

, and this is where some of the random behavior comes into play.

</para>





	

<table id="table1019" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1019">

			

<row id="tr1038">

				

<entry id="th1019">
<emphasis id="Listing_20" effect="bold">

Listing 20

</emphasis>

. Prey fish object 
				takes evasive action. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1019">

			

<row id="tr1039">

				

<entry id="td1019">



<code id="pre1019" display="block">          if(tempVectorA.getLength() &lt; 50){
            tempVectorA = tempVectorA.negate().scale(
                                     random.nextDouble());
            tempPrey = 
                   tempPrey.addVectorToPoint(tempVectorA);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1194">
<emphasis id="strong1158" effect="bold">
The prey fish moves by a random distance

</emphasis>
</para>




<para id="p1195">
In 

<link id="a1179" target-id="Listing_20">

Listing 20

</link>

, the negative of the displacement vector separating the prey 
fish from the predator is scaled by a random value ranging from 0 to 1. Then the 
prey fish is moved by the distance and direction specified by the resulting 
vector. If the random value is 0, the prey fish won't be moved at all. If the 
random value is 1, the distance between the prey fish and the predator will be 
doubled. For values between 0 and 1, the prey fish will be moved different 
distances away from the predator.

</para>




<para id="p1196">
<emphasis id="strong1159" effect="bold">
Did the prey fish escape?

</emphasis>
</para>




<para id="p1197">
Once the prey fish has taken the evasive action and has 

<emphasis id="em1030" effect="italics">
(possibly)

</emphasis>
 
moved away from the predator, the separation between the prey fish and the 
predator is tested again in 

<link id="a1180" target-id="Listing_21">

Listing 21

</link>

.

</para>





	

<table id="table1020" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1020">

			

<row id="tr1040">

				

<entry id="th1020">
<emphasis id="Listing_21" effect="bold">

Listing 21

</emphasis>

. Test the separation again. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1020">

			

<row id="tr1041">

				

<entry id="td1020">



<code id="pre1020" display="block">            tempVectorA = 
                 tempPrey.getDisplacementVector(predator);

            if(tempVectorA.getLength() &lt; 25){
              tempPrey = preyObjects.remove(cnt);
              displayVectors.remove(cnt);
              Toolkit.getDefaultToolkit().beep();
              killCount++;
              timer.setText(
                       "" 
                       + (new Date().getTime() - baseTime)
                       + " / " 
                       + killCount);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1198">
If the new separation is at least 25 units, the escape attempt is deemed 
	successful and the prey fish will continue to live. 

<emphasis id="em1031" effect="italics">
(You can decrease or 
	increase the threshold distance used in the test in 

<link id="a1181" target-id="Listing_21">

Listing 21

</link>

 to cause the 
	prey fish object to be more or less successful in the escape attempt. If you 
	make the threshold distance small enough, the prey fish will almost always 
	escape.)

</emphasis>
</para>




<para id="p1199">
<emphasis id="strong1160" effect="bold">
When the escape attempt is not successful...

</emphasis>
</para>




<para id="p1200">
When the escape attempt is not successful, the remaining code in 

<link id="a1182" target-id="Listing_21">

Listing 21

</link>

 
is executed. The prey fish is deemed to have been eaten by the predator. 
Therefore, the prey fish and its direction vector are removed from the 
containers that contain them. This causes the prey fish to be removed from the 
population.

</para>




<para id="p1201">
In addition, the program sounds a beep to notify the user of the successful 
attack by the predator and the kill count that is displayed in the bottom right 
of 

<link id="a1183" target-id="Figure_1">

Figure 1

</link>

 is incremented by one.

</para>




<para id="p1202">
<emphasis id="strong1161" effect="bold">
Display elapsed time and number of fish eaten

</emphasis>
</para>




<para id="p1203">
Finally, the code in 

<link id="a1184" target-id="Listing_21">

Listing 21

</link>

 displays the elapsed time in milliseconds 
since the 

<emphasis id="strong1162" effect="bold">
Start

</emphasis>
 button was clicked along with the number of fish that 
have been eaten. Note that the value that is displayed is the elapsed time when 
the most recent prey fish was eaten by the predator and is not the total elapsed 
time since the 

<emphasis id="strong1163" effect="bold">
Start

</emphasis>
 button was clicked. 

<emphasis id="em1032" effect="italics">
(The elapsed time value won't 
change again until another prey fish is eaten.)

</emphasis>
</para>




<para id="p1204">
When all of the prey fish have been eaten, the final time that is displayed 
is the time that was required for the predator to eat all of the fish in the 
population and the final kill count that is displayed is the same of the 
original number of prey fish in the population. 

<emphasis id="em1033" effect="italics">
(Also note that the player 
must click the 

<emphasis id="strong1164" effect="bold">
Stop

</emphasis>
 button before starting a new game. Fixing this 
inconvenience will be a good exercise for the student.)

</emphasis>
</para>




<para id="p1205">
<emphasis id="strong1165" effect="bold">
When the escape attempt is successful...

</emphasis>
</para>




<para id="p1206">
When the escape attempt is successful, a clone of the prey fish in its new 
location is stored in the 

<emphasis id="strong1166" effect="bold">
preyObjects

</emphasis>
 container and a normalized version 
of the fish's direction vector is stored in the 

<emphasis id="strong1167" effect="bold">
displayVectors

</emphasis>
 container 
as shown in 

<link id="a1185" target-id="Listing_22">

Listing 22

</link>

.

</para>





	

<table id="table1021" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1021">

			

<row id="tr1042">

				

<entry id="th1021">
<emphasis id="Listing_22" effect="bold">

Listing 22

</emphasis>

. Restore the prey fish to the population. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1021">

			

<row id="tr1043">

				

<entry id="td1021">



<code id="pre1021" display="block">            }else{
              //The escape attempt was successful. Restore
              // a clone of the prey object in its new
              // location along with its direction vector
              // to the population.
              preyObjects.set(cnt,tempPrey.clone());
              //Save a normalized version of the direction
              // vector for drawing later.  It will
              // overwrite the previously saved vector and
              // if you watch closely it will show the
              // prey object running away from the
              // predator.
              displayVectors.set(
                 cnt,tempVectorA.normalize().scale(15.0));
            }//end else
          }//end if distance &lt; 50
        }//end for loop on population
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1207">
<link id="a1186" target-id="Listing_22">

Listing 22

</link>

 also signals the end of the 

<emphasis id="strong1168" effect="bold">
for

</emphasis>
 loop that began in 
	

<link id="a1187" target-id="Listing_19">

Listing 19

</link>

.

</para>




<para id="p1208">
<emphasis id="strong1169" effect="bold">
Keep the prey fish in the playing field

</emphasis>
</para>




<para id="p1209">
I have one more section of code to explain that deals with the behavior of 
the prey fish during each iteration of the animation loop. The code in 


<link id="a1188" target-id="Listing_23">

Listing 
23

</link>

 causes prey fish that stray outside the playing field to return to the 
playing field.

</para>







	

<table id="table1022" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1022">

			

<row id="tr1044">

				

<entry id="th1022">
<emphasis id="Listing_23" effect="bold">

Listing 23

</emphasis>

. Keep the prey fish in the playing field. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1022">

			

<row id="tr1045">

				

<entry id="td1022">



<code id="pre1022" display="block">        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          
          if(tempPrey.getDisplacementVector(origin).
                             getLength() &gt; 0.5*osiHeight){

            tempVectorA = 
                   tempPrey.getDisplacementVector(origin);
            tempPrey = tempPrey.addVectorToPoint(
                                  tempVectorA.scale(0.1));
            preyObjects.set(cnt,tempPrey.clone());
          }//end if prey object is out of bounds
        }//end for loop to process each prey object
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1210">
<emphasis id="strong1170" effect="bold">
The playing field is the interior of a sphere

</emphasis>
</para>




<para id="p1211">
The playing field is defined to be the interior of a sphere that is centered 
on the origin with a radius that is one-half the height of the off-screen image. 
The 

<emphasis id="strong1171" effect="bold">
for

</emphasis>
 loop in 

<link id="a1189" target-id="Listing_23">

Listing 23

</link>

 iterates once for each prey fish remaining in 
the population. The 

<emphasis id="strong1172" effect="bold">
if

</emphasis>
 statement in 

<link id="a1190" target-id="Listing_23">

Listing 23

</link>

 tests to determine if a 
prey fish is outside of the sphere.

</para>




<para id="p1212">
If the prey fish is outside the sphere, the code in 

<link id="a1191" target-id="Listing_23">

Listing 23

</link>

 gives that 
prey fish a nudge back toward the origin and saves a clone of the prey fish in 
its new location.

</para>




<para id="p1213">
<emphasis id="strong1173" effect="bold">
Erase the off-screen image and draw the large circle

</emphasis>
</para>




<para id="p1214">
<link id="a1192" target-id="Listing_24">

Listing 24

</link>

 erases the off-screen image and draws the large circle that 
defines the playing field shown in 

<link id="a1193" target-id="Figure_1">

Figure 1

</link>

.

</para>





	

<table id="table1023" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1023">

			

<row id="tr1046">

				

<entry id="th1023">
<emphasis id="Listing_24" effect="bold">

Listing 24

</emphasis>

. Erase the off-screen image and draw the large circle. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1023">

			

<row id="tr1047">

				

<entry id="td1023">



<code id="pre1023" display="block">        //Erase the screen
        g2D.setColor(Color.WHITE);
        GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);


        //Draw a broken-line circle that represents the
        // intersection of the spherical boundary with the
        // x-y plane. Although the prey objects and the
        // predator can stray outside this sphere, they
        // prefer to be inside the sphere.
        GM01.Point3D tempPointA = new GM01.Point3D(
                   new GM01.ColMatrix3D(osiHeight/2,0,0));
        GM01.Point3D tempPointB;
        //The circle is defined by 39 points around the
        // circumference.
        g2D.setColor(Color.BLACK);
        for(int cnt = 0;cnt &lt; 39;cnt++){
          tempPointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(
           osiHeight/2*Math.cos((cnt*360/39)*Math.PI/180),
           osiHeight/2*Math.sin((cnt*360/39)*Math.PI/180),
           0));
            
          //Connect every third pair of points with a line
          if(cnt%3 == 0){
            new GM01.Line3D(
                         tempPointA,tempPointB).draw(g2D);
          }//end if
          //Save the old point.
          tempPointA = tempPointB;
        }//end for loop
        
        //Draw the final line required to close the circle
        new GM01.Line3D(tempPointA,new GM01.Point3D(
                           new GM01.ColMatrix3D(
                             osiHeight/2,0,0))).draw(g2D);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1215">
Although somewhat tedious, the code in 

<link id="a1194" target-id="Listing_24">

Listing 24

</link>

 is straightforward and 
	shouldn't require an explanation beyond the embedded comments.

</para>




<para id="p1216">
<emphasis id="strong1174" effect="bold">
Draw the prey fish on the off-screen image

</emphasis>
</para>




<para id="p1217">
Depending on the states of the two check boxes in 

<link id="a1195" target-id="Figure_1">

Figure 1

</link>

, 

<link id="a1196" target-id="Listing_25">

Listing 25

</link>

 draws 
the 

<emphasis id="strong1175" effect="bold">
GM01.Point3D

</emphasis>
 objects that represent the prey fish or 

<emphasis id="strong1176" effect="bold">
GM01.Vector3D


</emphasis>
objects that represent the direction vectors for the prey fish, or both, on 
the off-screen image. 

<emphasis id="em1034" effect="italics">
(Note that only the vectors were drawn on the 
off-screen image in 

<link id="a1197" target-id="Figure_1">

Figure 1

</link>

.)

</emphasis>
</para>





	

<table id="table1024" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1024">

			

<row id="tr1048">

				

<entry id="th1024">
<emphasis id="Listing_25" effect="bold">

Listing 25

</emphasis>

. Draw the prey fish on the off-screen image. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1024">

			

<row id="tr1049">

				

<entry id="td1024">



<code id="pre1024" display="block">        g2D.setColor(Color.RED);
        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          if(drawPoints){
            tempPrey.draw(g2D);//draw circle around point
          }//end if
          
          if(drawVectors){
            //Draw the vector with its tail at the point.
            displayVectors.get(cnt).draw(g2D,tempPrey);
          }//end if
        }//end for loop
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1218">
There is nothing new in 

<link id="a1198" target-id="Listing_25">

Listing 25

</link>

, so I won't bore you with a detailed 
	explanation of the code.

</para>




<para id="p1219">
<emphasis id="strong1177" effect="bold">
It's time to deal with the predator

</emphasis>
</para>




<para id="p1220">
So far, we have been dealing exclusively with code that controls the behavior 
of the prey fish. The time has come to deal with the code that controls the 
behavior of the predator.

</para>




<para id="p1221">
<emphasis id="strong1178" effect="bold">
Cause the predator to slowly circle the cluster of prey fish

</emphasis>
</para>




<para id="p1222">
When the player clicks the 

<emphasis id="strong1179" effect="bold">
Attack

</emphasis>
 button, a 

<emphasis id="strong1180" effect="bold">
boolean

</emphasis>
 variable 
named 

<emphasis id="strong1181" effect="bold">
attack

</emphasis>
 is set to 

<emphasis id="strong1182" effect="bold">
true

</emphasis>
, causing the predator to enter attack 
mode during the next iteration of the animation loop. However, when the value of 
this variable is 

<emphasis id="strong1183" effect="bold">
false

</emphasis>
, the predator is not in attack mode and its 
behavior is to swim slowly around the cluster of prey fish encouraging them to 
bunch up into a smaller and tighter cluster.

</para>




<para id="p1223">
The code that accomplishes this circling behavior is shown in 

<link id="a1199" target-id="Listing_26">

Listing 26

</link>

.

</para>





	

<table id="table1025" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1025">

			

<row id="tr1050">

				

<entry id="th1025">
<emphasis id="Listing_26" effect="bold">

Listing 26

</emphasis>

. Cause the predator to slowly circle the cluster of prey fish. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1025">

			

<row id="tr1051">

				

<entry id="td1025">



<code id="pre1025" display="block">        //When the predator is not in attack mode, cause
        // it to slowly circle the cluster of prey
        // objects.
        if(!attack){
          //Get a displacement vector pointing from the
          // predator to the preyCenter.
          predatorVec = 
               predator.getDisplacementVector(preyCenter);
                  
          //Create a vector that is rotated relative to
          // predatorVec. Note how each component in
          // this new vector is set equal to a different
          // component in predatorVec
          tempVectorB = new GM01.Vector3D(
            new GM01.ColMatrix3D(
                     predatorVec.getData(1),
                     predatorVec.getData(2),
                     predatorVec.getData(0))).scale(0.15);
                                                     
          //Scale predatorVec and add the two vectors.
          // Then move the predator according to the sum
          // of the vectors.
          //Moving the prey object in the direction of
          // the sum of these two vectors produces a
          // motion that causes the predator to
          // spiral toward the preyCenter instead of
          // simply moving in a straight line toward the
          // preyCenter. The scale factors control the
          // relative motion between the two directions,
          // and are fairly sensitive.
          predatorVec = 
                predatorVec.scale(0.095).add(tempVectorB);
          
          predator = predator.addVectorToPoint(
                                  predatorVec.scale(1.0));
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1224">
The code in 

<link id="a1200" target-id="Listing_26">

Listing 26

</link>

 is very similar to code that I explained earlier 
	in conjunction with the behavior of the prey fish. Therefore, no explanation 
	beyond the embedded comments should be required.

</para>




<para id="p1225">
<emphasis id="strong1184" effect="bold">
Execute the attack

</emphasis>
</para>




<para id="p1226">
When the user clicks the 

<emphasis id="strong1185" effect="bold">
Attack

</emphasis>
 button, the value of the variable 
named 

<emphasis id="strong1186" effect="bold">
attack

</emphasis>
 is set to 

<emphasis id="strong1187" effect="bold">
true

</emphasis>
, causing the code in 

<link id="a1201" target-id="Listing_27">

Listing 27

</link>

 to be 
executed during subsequent iterations of the animation loop.

</para>




	

<table id="table1026" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1026">

			

<row id="tr1052">

				

<entry id="th1026">
<emphasis id="Listing_27" effect="bold">

Listing 27

</emphasis>

. Execute the attack. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1026">

			

<row id="tr1053">

				

<entry id="td1026">



<code id="pre1026" display="block">        }else{//attack is true
          predator = predator.addVectorToPoint(
                                 predatorVec.scale(0.25));

          //Check to see if the predator is outside the
          // spherical boundary that defines the playing
          // field.
          if(predator.getDisplacementVector(origin).
                             getLength() &gt; 0.5*osiHeight){
            //Shift out of attack mode and start circling
            // the prey fish again.
            attack = false;
            attackButton.setEnabled(true);
          }//end if
        }//end else
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>








<para id="p1227">
<emphasis id="strong1188" effect="bold">
The predator is in attack mode

</emphasis>
</para>




<para id="p1228">
The predator is in attack mode at the beginning of 

<link id="a1202" target-id="Listing_27">

Listing 27

</link>

, and will 
remain in attack mode using the same displacement vector to control its speed 
and direction until it leaves the spherical playing field. When it leaves the 
playing field, the value of the 

<emphasis id="strong1189" effect="bold">
attack

</emphasis>
 variable will be set to 

<emphasis id="strong1190" effect="bold">
false

</emphasis>
, 
causing the predator to revert to non-attack mode.

</para>




<para id="p1229">
As the predator encounters prey fish along its trip toward the edge of the 
playing field, the code in 

<link id="a1203" target-id="Listing_21">

Listing 21

</link>

 

<emphasis id="em1035" effect="italics">
(explained earlier)

</emphasis>
 will determine 
whether those prey fish escape or get eaten by the predator.

</para>




<para id="p1230">
<emphasis id="strong1191" effect="bold">
Control of speed and direction

</emphasis>
</para>




<para id="p1231">
The displacement vector that controls the speed and direction of the predator


<emphasis id="em1036" effect="italics">
(

<emphasis id="strong1192" effect="bold">
predatorVec

</emphasis>
 in 

<link id="a1204" target-id="Listing_27">

Listing 27

</link>

)

</emphasis>
 is created in the 

<emphasis id="strong1193" effect="bold">
actionPerformed

</emphasis>
 
method in 

<link id="a1205" target-id="Listing_3">

Listing 3

</link>

 in response to a click on the 

<emphasis id="strong1194" effect="bold">
Attack

</emphasis>
 button.

</para>




<para id="p1232">
This vector is constructed to point to the most recently computed geometric 
center of the cluster of prey fish. Note however, that the vector may no longer 
point to the exact center of the cluster because the exact center of the cluster 
may have changed since it was last computed. In other words, the position of the 
geometric center of the prey-fish cluster changes as the predator attacks and 
causes the prey fish to scatter. As programmed, the predator is unable to 
respond to such changes and continues to move in the same direction at the same 
speed until it leaves the playing field. 

</para>




<para id="p1233">
In other words, even though the prey fish scatter, the predator is 
constrained to move in a straight line across the playing field once an attack 
has begun.

</para>







	

<note id="note1002" type="">


		


			


				

<emphasis id="strong1195" effect="bold">
An interesting upgrade:

</emphasis>

				

<para id="p1234">
A program upgrade to cause the predator to accommodate such changes in the geometric center would be an interesting exercise for the student.

</para>


				

</note>

			


		



	





<para id="p1235">
<emphasis id="strong1196" effect="bold">
Draw the predator on the off-screen image

</emphasis>
</para>




<para id="p1236">
<link id="a1206" target-id="Listing_28">

Listing 28

</link>

 sets the drawing color to BLUE and draws the predator's direction 
vector on the off-screen image.

</para>






	

<table id="table1027" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1027">

			

<row id="tr1054">

				

<entry id="th1027">
<emphasis id="Listing_28" effect="bold">

Listing 28

</emphasis>

. Draw the predator on the off-screen image.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1027">

			

<row id="tr1055">

				

<entry id="td1027">



<code id="pre1027" display="block">        g2D.setColor(Color.BLUE);
        //Enable the following statement to draw a circle
        // around the point that represents the predator.
        //predator.draw(g2D);
        
        //Draw the predator's vector.
        predatorVec.normalize().scale(15.0).draw(
                                            g2D,predator);
        g2D.setColor(Color.RED);//restore red color
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1237">
<emphasis id="strong1197" effect="bold">
Copy off-screen image, insert time delay, etc

</emphasis>
</para>




<para id="p1238">
<link id="a1207" target-id="Listing_29">

Listing 29

</link>

 copies the off-screen image to the canvas and then causes the 
animation thread to sleep for 166 milliseconds.

</para>




	

<table id="table1028" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1028">

			

<row id="tr1056">

				

<entry id="th1028">
<emphasis id="Listing_29" effect="bold">

Listing 29

</emphasis>

. Copy off-screen image, insert time delay, etc. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1028">

			

<row id="tr1057">

				

<entry id="td1028">



<code id="pre1028" display="block">        //Copy the off-screen image to the canvas and then
        // do it all again.
        myCanvas.repaint();
        
        //Insert a time delay. Change the sleep time to
        // speed up or slow down the animation. 
        try{
          Thread.currentThread().sleep(166);
        }catch(Exception e){
          e.printStackTrace();
        }//end catch
      }//end animation loop
    }//end run method
  }//end inner class named Animate
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1239">
<link id="a1208" target-id="Listing_29">

Listing 29

</link>

 also signals the end of the animation loop, the end of the 

<emphasis id="strong1198" effect="bold">
run

</emphasis>
 
method, and the end of the inner class named 

<emphasis id="strong1199" effect="bold">
Animate

</emphasis>
.

</para>




<para id="p1240">
That is all of the code that I will explain for this program. You can view 
the remainder of the code in 

<link id="a1209" target-id="Listing_31">

Listing 31

</link>

 near the end of the module.

</para>




<para id="p1241">
<emphasis id="strong1200" effect="bold">
Not a graphics program

</emphasis>
</para>




<para id="p1242">
Even though this program produces quite a lot of 3D graphics, and those 
graphics are important in the playing of the game, this is not a graphics 
program. Rather, it is a 3D data-processing program that produces graphics as a 
side effect. 

</para>




<para id="p1243">
That is not to say that the graphics are unimportant. To the contrary, the 
graphics provide visual feedback to the player, which allows the player to 
implement a strategy for success. Without graphics, the game would be very 
boring. However, the programming effort to produce the graphics represents an 
almost trivial part of the total programming effort for this game.

</para>




<para id="p1244">
<emphasis id="strong1201" effect="bold">
An almost trivial part of the programming effort

</emphasis>
</para>




<para id="p1245">
Exclusive of the code required to draw the large circle shown in 

<link id="a1210" target-id="Figure_1">

Figure 1

</link>

, 
all of the graphics shown in 

<link id="a1211" target-id="Figure_1">

Figure 1

</link>

,


<link id="a1212" target-id="Figure_5">

Figure 5

</link>

, 


<link id="a1213" target-id="Figure_6">

Figure 6

</link>

, 

<link id="a1214" target-id="Figure_7">

Figure 7

</link>

, and 

<link id="a1215" target-id="Figure_8">

Figure 8

</link>

 are produced by only two calls to game-math library methods named 

<emphasis id="strong1202" effect="bold">
draw

</emphasis>
. 
In other words, all of the required graphics are produced by only two statements 
in the program code. 

<emphasis id="em1037" effect="italics">
(One additional statement is required if you want to 
display the small circles that represent the locations of the prey fish.)

</emphasis>
</para>




<para id="p1246">
If those two statements are removed, the program will still compile and run, 
and the game can still be played. However, without visual feedback, the game 
isn't much fun. The lack of visual feedback eliminates the strategy aspect of 
the game, causing it to be solely a game of chance. Be that as it may, with or 
without visual feedback, the player can still click the 

<emphasis id="strong1203" effect="bold">
Start

</emphasis>
 button and 
then repetitively click the 

<emphasis id="strong1204" effect="bold">
Attack

</emphasis>
 button until the display in the 
bottom-right of 

<link id="a1216" target-id="Figure_1">

Figure 1

</link>

 shows that all of the prey fish have been eaten.

</para>




<para id="p1247">
<emphasis id="strong1205" effect="bold">
Why am I telling you this?

</emphasis>
</para>




<para id="p1248">
I'm telling you this to emphasize that the essential skills required to 
program this game 

<emphasis id="em1038" effect="italics">
(and probably most games for that matter)

</emphasis>
 consist of 
skills in mathematics, programming logic, and several other technical areas. The 
ability to produce on-screen graphics is necessary for an enjoyable game, but,


<emphasis id="em1039" effect="italics">
(given a good game-math library that supports graphics)

</emphasis>
, producing 
on-screen graphics is almost a trivial part of the programming effort. In this 
collection of modules, you need to be mainly concentrating on learning 
mathematics and programming logic and treating the production of on-screen 
graphics almost as an afterthought.

</para>




</section>
<section id="h21003">
<title>
<emphasis id="The_program_named_GM01test04" effect="bold">

The program named GM01test04

</emphasis>


</title>




<para id="p1249">
This animation program is designed to exercise many of the 2D features of the


<emphasis id="strong1206" effect="bold">
GM01

</emphasis>
 game-math library. The animation is generally based on the idea of a 
flocking behavior similar to that exhibited by birds and fish. A set of 

<emphasis id="strong1207" effect="bold">

GM01.Point2D

</emphasis>
 objects is created with random locations to act as predators. 
An additional 

<emphasis id="strong1208" effect="bold">
GM01.Point2D

</emphasis>
 object is also created to play the part of a 
prey object.

</para>




<para id="p1250">
The prey object is drawn in red while the predators are drawn in black as 
shown in 

<link id="a1217" target-id="Figure_2">

Figure 2

</link>

. An algorithm is executed that attempts to cause the predators 
to chase the prey object without colliding with one another.

</para>




<para id="p1251">
Even though the algorithm causes the predators to chase the prey object, it 
also tries to keep the predators from colliding with the prey object.

</para>




<para id="p1252">
<emphasis id="strong1209" effect="bold">
The user input GUI

</emphasis>
</para>




<para id="p1253">
A GUI is provided that contains an input text field for the number of 
predators plus a 

<emphasis id="strong1210" effect="bold">
Start

</emphasis>
 button and a 

<emphasis id="strong1211" effect="bold">
Stop

</emphasis>
 button. The GUI also 
contains check boxes that allow the user to elect to display points only, 
direction vectors only, or both. 

<emphasis id="em1040" effect="italics">
(Both the point and the direction vector is 
always displayed for the prey object.)

</emphasis>
</para>




<para id="p1254">
The user specifies the number of randomly-placed predators and clicks the 

<emphasis id="strong1212" effect="bold">

Start

</emphasis>
 button, at which time the animation begins and the predators start 
chasing the prey object. Prey-object motion is random.

</para>




<para id="p1255">
The animation continues until the user clicks the 

<emphasis id="strong1213" effect="bold">
Stop

</emphasis>
 button. The 
user can click the 

<emphasis id="strong1214" effect="bold">
Stop

</emphasis>
 button, change any of the input parameters, and 
then click the 

<emphasis id="strong1215" effect="bold">
Start

</emphasis>
 button again to re-start the animation with 
different parameters such as the number of predator objects.

</para>




<para id="p1256">
<emphasis id="strong1216" effect="bold">
Swimming in formation

</emphasis>
</para>




<para id="p1257">
An unexpected result is that the algorithm seems to cause the predators to 
come together and swim in formation while chasing the prey object. The most 
common formation is hexagonal as shown in 

<link id="a1218" target-id="Figure_9">

Figure 9

</link>

, which shows 12 predators 
swimming in a hexagonal formation.

</para>




<para id="p1258">
<emphasis id="em1041" effect="italics">
(Note that some of the twelve predators are hidden by other predators.)

</emphasis>
</para>




<para id="p1259">
<emphasis id="Figure_9" effect="bold">


<emphasis id="strong1217" effect="bold">
Figure 9

</emphasis>
</emphasis>


<emphasis id="strong1218" effect="bold">
 Twelve predators swimming in a hexagon formation in GM01test04.

</emphasis>
</para>




<para id="p1260">
<media id="media1008" alt="Missing image." display="block">
<image id="img1008" mime-type="image/jpeg" src="../../media/java1712b1.jpg" width="401" height="401"/>
</media>


</para>





<para id="p1261">
<emphasis id="strong1219" effect="bold">
Other formations appear as well

</emphasis>
</para>




<para id="p1262">
Some triangles, diamonds, and incomplete hexagons also appear. For example, 


<link id="a1219" target-id="Figure_10">

Figure 10

</link>

 shows six predators swimming in a diamond formation.

</para>




<para id="p1263">
<emphasis id="Figure_10" effect="bold">


<emphasis id="strong1220" effect="bold">
Figure 10

</emphasis>
</emphasis>


<emphasis id="strong1221" effect="bold">
 Six predators swimming in a diamond formation.

</emphasis>
</para>




<para id="p1264">
<media id="media1009" alt="Missing image." display="block">
<image id="img1009" mime-type="image/jpeg" src="../../media/java1712b2.jpg" width="401" height="401"/>
</media>


</para>





<para id="p1265">
<emphasis id="strong1222" effect="bold">
No explanation for this behavior

</emphasis>
</para>




<para id="p1266">
I haven't given the matter a lot of thought, but at this point, I have no 
explanation for this behavior. Note that the tendency to swim in formation is 
more visually obvious when only the points are displayed. When the vectors are 
displayed, it is more difficult to pick out the formation.

</para>




<para id="p1267">
<emphasis id="strong1223" effect="bold">
Dogged determination

</emphasis>
</para>




<para id="p1268">
On the other hand, the animation is most impressive when the direction 
vectors are displayed, with or without points, because the vectors illustrate 
the dogged determination and undying focus that the predators maintain while 
chasing the prey object.

</para>




<para id="p1269">
<emphasis id="strong1224" effect="bold">
Won't explain the code

</emphasis>
</para>




<para id="p1270">
Once you understand the code in the program named 

<emphasis id="strong1225" effect="bold">
GM01test08

</emphasis>
 that I 
explained earlier in this module, you should have no difficulty understanding 
the code in this program. Therefore, I won't explain the code in this program. I 
included this program in this module mainly to illustrate the differences 
between 2D and 3D from both a visual and programming viewpoint.

</para>




<para id="p1271">
A complete listing of this program is provided in 

<link id="a1220" target-id="Listing_32">

Listing 32

</link>

 near the end of 
the module.

</para>




</section>
<section id="h21004">
<title>
<emphasis id="The_program_named_GM01test03" effect="bold">

The program named GM01test03

</emphasis>


</title>




<para id="p1272">
This is a 3D update of the 2D program named 

<emphasis id="strong1226" effect="bold">
GM01test04

</emphasis>
 discussed 
above. 

</para>




<para id="p1273">
<emphasis id="strong1227" effect="bold">
A comparison of programming requirements

</emphasis>
</para>




<para id="p1274">
Basically all that was required to perform the update was to specify 3D 
classes from the game-math library in place of the 2D classes used in the 2D 
version of the program. In some cases, this in turn required that argument lists 
for constructors and methods be expanded from two dimensions to three 
dimensions. Just about everything else took care of itself.

</para>




<para id="p1275">
A comparison of these two programs illustrates the value of the game-math 
library named 

<emphasis id="strong1228" effect="bold">
GM01

</emphasis>
 and the ease with which you can switch back and forth 
between 2D and 3D programming when using the library.

</para>




<para id="p1276">
<emphasis id="strong1229" effect="bold">
A comparison of visual behavior

</emphasis>
</para>




<para id="p1277">
The visual behavior of this 3D version, as shown in 

<link id="a1221" target-id="Figure_3">

Figure 3

</link>

, is more 
realistic than the 2D version. This is particularly true when the prey object 
gets in the middle of the predators and the display is showing vectors. In the 
2D version, a predator is constrained to swing around only in the plane of the 
screen. However, in this 3D version, a predator is not subject to that 
constraint and is free to swing around in the most appropriate way as the prey 
object passes by.

</para>




<para id="p1278">
This constraint causes the motion in the 2D version to be less fluid than the 
motion in the 3D version. This can best be demonstrated with only one predator 
because that makes it easy to see the behavior of an individual predator as the 
animation is running.

</para>




<para id="p1279">
<emphasis id="strong1230" effect="bold">
No swimming in formation

</emphasis>
</para>




<para id="p1280">
One very interesting thing that I have noticed is that unlike the 2D version, 
the predators in this 3D version don't seem to have a tendency to form up and 
swim in formation while chasing the prey object. This may be because they have 
more options in terms of avoiding collisions while giving chase. However, that 
is pure speculation on my part since I don't know why the predators tend to swim 
in formation in the 2D version anyway. 

<emphasis id="em1042" effect="italics">
(It is also possible that the 
predators form into a 3D formation, which isn't visually obvious in the 2D 
projection.)

</emphasis>
</para>




<para id="p1281">
<emphasis id="strong1231" effect="bold">
Won't explain the code

</emphasis>
</para>




<para id="p1282">
As is the case with the earlier program named 

<emphasis id="strong1232" effect="bold">
GM01test04

</emphasis>
, once you 
understand the code in the program named 

<emphasis id="strong1233" effect="bold">
GM01test08

</emphasis>
, you should have no 
difficulty understanding the code in this program. Therefore, I won't explain 
the code in this program. I included this program and the earlier 2D version in 
this module mainly to illustrate the differences between 2D and 3D from both a 
visual viewpoint and programming viewpoint.

</para>




<para id="p1283">
A complete listing of this program is provided in 

<link id="a1222" target-id="Listing_33">

Listing 33

</link>

 near the end of 
the module.

</para>




</section>
<section id="h21005">
<title>
<emphasis id="The_program_namedStringArt04" effect="bold">

The program namedStringArt04

</emphasis>


</title>




<para id="p1284">
This program animates the behavior of the earlier program named 

<emphasis id="strong1234" effect="bold">

StringArt03

</emphasis>
 that I explained in an earlier module. See the comments at the 
beginning of that program for a description of both programs.

</para>




<para id="p1285">
The only significant difference in the behavior of the two programs is that 
this program slows the rotation process down and animates it so that the user 
can see it happening in slow motion. Of course, quite a few changes were 
required to convert the program from a static program to an animated program.

</para>




<para id="p1286">
However, if you understand the code in the earlier program named 

<emphasis id="strong1235" effect="bold">

StringArt03

</emphasis>
 and you understand the code in the program named 

<emphasis id="strong1236" effect="bold">
GM01test08

</emphasis>
 
that I explained earlier in this module, you should have no difficulty 
understanding the code in the program named 

<emphasis id="strong1237" effect="bold">
StringArt04

</emphasis>
. Therefore, I 
won't explain the code in this program. A screen shot of the program in action 
is shown in 

<link id="a1223" target-id="Figure_4">

Figure 4

</link>

. A complete listing of the program is provided in 


<link id="a1224" target-id="Listing_34">

Listing 
34

</link>

.

</para>




<para id="p1287">
<emphasis id="strong1238" effect="bold">
Visual output

</emphasis>
</para>




<para id="p1288">
When viewing the output, remember that the program executes the rotations 
around the axes sequentially in the following order:

</para>




<list id="ul1010" list-type="bulleted">

	

<item id="li1085">
z-axis

</item>


	

<item id="li1086">
x-axis

</item>


	

<item id="li1087">
y-axis

</item>




</list>


	

</section>
</section>
<section id="h11004">
<title>
<emphasis id="Homework_assignment" effect="bold">

Homework assignment

</emphasis>


</title>




<para id="p1289">
The homework assignment for this module was to study the Kjell tutorial 
through 

<emphasis id="em1043" effect="italics">
Chapter6 - Scaling and Unit Vectors

</emphasis>
.

</para>




<para id="p1290">
The homework assignment for the next module is to study the Kjell tutorial 
through 

<emphasis id="em1044" effect="italics">
Chapter 10, Angle between 3D Vectors

</emphasis>
.

</para>




<para id="p1291">
In addition to studying the Kjell material, you should read at least the next 
two modules in this collection and bring your questions about that material to 
the next classroom session.

</para>




<para id="p1292">
Finally, you should have begun studying the


<link id="a1225" url="http://cnx.org/content/m44992/latest/">

physics material

</link>

 at the 
beginning of the semester and you should continue studying one physics module 
per week thereafter. You should also feel free to bring your questions about 
that material to the classroom for discussion. 

</para>






</section>
<section id="h11005">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the programs

</emphasis>


</title>






<para id="p1293">
I encourage you to copy the code from 

<link id="a1226" target-id="Listing_30">

Listing 30

</link>

 through 

<link id="a1227" target-id="Listing_34">

Listing 34

</link>

. Compile the code and 
execute it in conjunction with the game-math library named 

<emphasis id="strong1239" effect="bold">
GM01

</emphasis>
 provided in


<link id="a1228" target-id="Listing_30">

Listing 30

</link>

. Experiment with the code, 
making changes, and observing the results of your changes. Make certain that you 
can explain why your changes behave as they do.

</para>


	

</section>
<section id="h11006">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1294">
In this module, you learned how to write your first interactive 3D game using 
the game-math library named 

<emphasis id="strong1240" effect="bold">
GM01

</emphasis>
. You also learned how to write a Java 
program that simulates flocking behavior such as that exhibited by birds and 
fish and you learned how to incorporate that behavior into the game. Finally, 
you examined three other programs that illustrate various aspects of both 2D and 
3D animation using the game-math library.

</para>




</section>
<section id="h11007">
<title>
<emphasis id="Whats_next" effect="bold">

What's next?

</emphasis>


</title>




<para id="p1295">
In the next module, you will learn the fundamentals of the 

<emphasis id="em1045" effect="italics">
vector dot product

</emphasis>
 
in both 2D and 3D. You will learn how to update the game-math library to support 
various aspects of the vector dot product, and you will learn how to write 2D 
and 3D programs that use the vector dot product methods in the game-math 
library.

</para>


	

</section>
<section id="h11008">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1296">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1003" type="">


		


			


				

<emphasis id="strong1241" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1011" list-type="bulleted">

					

<item id="li1088">
Module name: GAME 2302-0140: Our First 3D Game Program

</item>


					

<item id="li1089">
File: Game0140.htm


</item>


					

<item id="li1090">
Published: 10/20/12

</item>


					

<item id="li1091">
Revised: 02/01/16

</item>


				

</list>


				

</note>

			


		



	






	

<note id="note1004" type="">


		


			


				

<emphasis id="strong1242" effect="bold">
Disclaimers:

</emphasis>
<para id="p1297">
<emphasis id="strong1243" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>


				

<para id="p1298">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>


				

<para id="p1299">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>


				

<para id="p1300">
<emphasis id="strong1244" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>


				

</note>

			


		



	





</section>
<section id="h11009">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1301">
Complete listings of the programs discussed in this module are shown in 


<link id="a1229" target-id="Listing_30">

Listing 30

</link>

 through 

<link id="a1230" target-id="Listing_34">

Listing 34

</link>

 below.

</para>





<para id="p1302">
<emphasis id="strong1245" effect="bold">
<emphasis id="Listing_30" effect="bold">

Listing 30

</emphasis>

. Source code for the game-math library named GM01.

</emphasis>
</para>





<code id="pre1029" display="block">/*GM01.java 
Copyright 2008, R.G.Baldwin
Revised 02/24/08

This is a major upgrade to the game-math library. This
version upgrades the version named GM2D04 to a new version
named simply GM01.

The primary purpose of the upgrade was to add 3D 
capability for all of the 2D features provided by the
previous version. Because both 2D and 3D capabilities
are included, it is no longer necessary to differentiate
between the two in the name of the class. Therefore, this
version is named GM01.

Adding 3D capability entailed major complexity in one
particular area: drawing the objects. It is difficult to
draw a 3D object on a 2D screen. This requires a 
projection process to project each point in the 3D object
onto the correct location on a 2D plane. There are a 
variety of ways to do this. This 3D library uses an
approach often referred to as an oblique parallel
projection. See the following URL for technical 
information on the projection process:

http://local.wasp.uwa.edu.au/~pbourke/geometry/
classification/


In addition to adding 3D capability, this version also
eliminates the confusion surrounding the fact that the
default direction of the positive y-axis is going down
the screen instead of up the screen as viewers have become
accustomed to. When you use this library, you can program
under the assumption that the positive direction of the
y-axis is up the screen, provided you funnel all of your
drawing tasks through the library and don't draw
directly on the screen.

The name GMnn is an abbreviation for GameMathnn.

See the file named GM2D01.java for a general description 
of the game-math library. The library has been updated
several times. This file is an update of GM2D04.

In addition to the updates mentioned above, this update
cleaned up some lingering areas of code inefficiency,
using the simplest available method to draw on an 
off-screen image. In addition, the following new methods 
were added:

The following methods are new static methods of the class
named GM01. The first method in the list deals with the
problem of displaying a 3D image on a 3D screen.

The last five methods in the list wrap the standard 
graphics methods for the purpose of eliminating the issue 
of the direction of the positive Y-axis.

GM01.convert3Dto2D
GM01.translate
GM01.drawLine
GM01.fillOval
GM01.drawOval
GM01.fillRect

The following methods are new instance methods of the 
indicated static top-level classes belonging to the class
named GM01.

GM01.Vector2D.scale
GM01.Vector2D.negate
GM01.Point2D.clone
GM01.Vector2D.normalize
GM01.Point2D.rotate
GM01.Point2D.scale

GM01.Vector3D.scale
GM01.Vector3D.negate
GM01.Point3D.clone
GM01.Vector3D.normalize
GM01.Point3D.rotate
GM01.Point3D.scale

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.geom.*;
import java.awt.*;

public class GM01{
  //----------------------------------------------------//
  
  //This method converts a ColMatrix3D object to a
  // ColMatrix2D object. The purpose is to accept
  // x, y, and z coordinate values and transform those
  // values into a pair of coordinate values suitable for
  // display in two dimensions.
  //See http://local.wasp.uwa.edu.au/~pbourke/geometry/
  // classification/ for technical background on the
  // transform from 3D to 2D.
  //The transform equations are:
  // x2d = x3d + z3d * cos(theta)/tan(alpha)
  // y2d = y3d + z3d * sin(theta)/tan(alpha);
  //Let theta = 30 degrees and alpha = 45 degrees
  //Then:cos(theta) = 0.866
  //     sin(theta) = 0.5
  //     tan(alpha) = 1;
  //Note that the signs in the above equations depend
  // on the assumed directions of the angles as well as
  // the assumed positive directions of the axes. The
  // signs used in this method assume the following:
  //   Positive x is to the right.
  //   Positive y is up the screen.
  //   Positive z is protruding out the front of the
  //     screen.
  //   The viewing position is above the x axis and to the
  //     right of the z-y plane.
  public static GM01.ColMatrix2D convert3Dto2D(
                                   GM01.ColMatrix3D data){
    return new GM01.ColMatrix2D(
                  data.getData(0) - 0.866*data.getData(2),
                  data.getData(1) - 0.50*data.getData(2));
  }//end convert3Dto2D 
  //----------------------------------------------------//
  
  //This method wraps around the translate method of the
  // Graphics2D class. The purpose is to cause the
  // positive direction for the y-axis to be up the screen
  // instead of down the screen. When you use this method,
  // you should program as though the positive direction
  // for the y-axis is up.
  public static void translate(Graphics2D g2D,
                               double xOffset,
                               double yOffset){
    //Flip the sign on the y-coordinate to change the
    // direction of the positive y-axis to go up the
    // screen.
    g2D.translate(xOffset,-yOffset);
  }//end translate
  //----------------------------------------------------//
  
  //This method wraps around the drawLine method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void drawLine(Graphics2D g2D,
                              double x1,
                              double y1,
                              double x2,
                              double y2){
    //Flip the sign on the y-coordinate value.
    g2D.drawLine((int)x1,-(int)y1,(int)x2,-(int)y2);
  }//end drawLine
  //----------------------------------------------------//
  
  //This method wraps around the fillOval method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void fillOval(Graphics2D g2D,
                              double x,
                              double y,
                              double width,
                              double height){
    //Flip the sign on the y-coordinate value.
    g2D.fillOval((int)x,-(int)y,(int)width,(int)height);
  }//end fillOval
  //----------------------------------------------------//

  //This method wraps around the drawOval method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void drawOval(Graphics2D g2D,
                              double x,
                              double y,
                              double width,
                              double height){
    //Flip the sign on the y-coordinate value.
    g2D.drawOval((int)x,-(int)y,(int)width,(int)height);
  }//end drawOval
  //----------------------------------------------------//
  
  //This method wraps around the fillRect method of the
  // Graphics class. The purpose is to cause the positive
  // direction for the y-axis to be up the screen instead
  // of down the screen. When you use this method, you
  // should program as though the positive direction for
  // the y-axis is up.
  public static void fillRect(Graphics2D g2D,
                              double x,
                              double y,
                              double width,
                              double height){
    //Flip the sign on the y-coordinate value.
    g2D.fillRect((int)x,-(int)y,(int)width,(int)height);
  }//end fillRect
  //----------------------------------------------------//
  
  

  //An object of this class represents a 2D column matrix.
  // An object of this class is the fundamental building
  // block for several of the other classes in the
  // library.
  public static class ColMatrix2D{
    double[] data = new double[2];
    
    public ColMatrix2D(double data0,double data1){
      data[0] = data0;
      data[1] = data1;
    }//end constructor
    //--------------------------------------------------//
    
    //Overridden toString method.
    public String toString(){
      return data[0] + "," + data[1];
    }//end overridden toString method
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return data[index];
      }//end else
    }//end getData method
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        this.data[index] = data;
      }//end else
    }//end setData method
    //--------------------------------------------------//
    
    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in two matrices and returns true if the
    // values are equal or almost equal and returns false
    // otherwise. 
    public boolean equals(Object obj){
      if(obj instanceof GM01.ColMatrix2D &amp;&amp;
         Math.abs(((GM01.ColMatrix2D)obj).getData(0) - 
                                 getData(0)) &lt;= 0.00001 &amp;&amp;
         Math.abs(((GM01.ColMatrix2D)obj).getData(1) - 
                                  getData(1)) &lt;= 0.00001){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Adds one ColMatrix2D object to another ColMatrix2D
    // object, returning a ColMatrix2D object.
    public GM01.ColMatrix2D add(GM01.ColMatrix2D matrix){
      return new GM01.ColMatrix2D(
                            getData(0)+matrix.getData(0),
                            getData(1)+matrix.getData(1));
    }//end add
    //--------------------------------------------------//
    
    //Subtracts one ColMatrix2D object from another
    // ColMatrix2D object, returning a ColMatrix2D object.
    // The object that is received as an incoming
    // parameter  is subtracted from the object on which
    // the method is called.
    public GM01.ColMatrix2D subtract(
                                 GM01.ColMatrix2D matrix){
      return new GM01.ColMatrix2D(
                            getData(0)-matrix.getData(0),
                            getData(1)-matrix.getData(1));
    }//end subtract
    //--------------------------------------------------//
  }//end class ColMatrix2D
  //====================================================//


  //An object of this class represents a 3D column matrix.
  // An object of this class is the fundamental building
  // block for several of the other classes in the
  // library.
  public static class ColMatrix3D{
    double[] data = new double[3];
    
    public ColMatrix3D(
                  double data0,double data1,double data2){
      data[0] = data0;
      data[1] = data1;
      data[2] = data2;
    }//end constructor
    //--------------------------------------------------//
    
    public String toString(){
      return data[0] + "," + data[1] + "," + data[2];
    }//end overridden toString method
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return data[index];
      }//end else
    }//end getData method
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        this.data[index] = data;
      }//end else
    }//end setData method
    //--------------------------------------------------//
    
    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in two matrices and returns true if the
    // values are equal or almost equal and returns false
    // otherwise. 
    public boolean equals(Object obj){
      if(obj instanceof GM01.ColMatrix3D &amp;&amp;
         Math.abs(((GM01.ColMatrix3D)obj).getData(0) - 
                                 getData(0)) &lt;= 0.00001 &amp;&amp;
         Math.abs(((GM01.ColMatrix3D)obj).getData(1) - 
                                 getData(1)) &lt;= 0.00001 &amp;&amp;
         Math.abs(((GM01.ColMatrix3D)obj).getData(2) - 
                                  getData(2)) &lt;= 0.00001){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Adds one ColMatrix3D object to another ColMatrix3D
    // object, returning a ColMatrix3D object.
    public GM01.ColMatrix3D add(GM01.ColMatrix3D matrix){
      return new GM01.ColMatrix3D(
                            getData(0)+matrix.getData(0),
                            getData(1)+matrix.getData(1),
                            getData(2)+matrix.getData(2));
    }//end add
    //--------------------------------------------------//
    
    //Subtracts one ColMatrix3D object from another
    // ColMatrix3D object, returning a ColMatrix3D object.
    // The object that is received as an incoming
    // parameter is subtracted from the object on which
    // the method is called.
    public GM01.ColMatrix3D subtract(
                                 GM01.ColMatrix3D matrix){
      return new GM01.ColMatrix3D(
                            getData(0)-matrix.getData(0),
                            getData(1)-matrix.getData(1),
                            getData(2)-matrix.getData(2));
    }//end subtract
    //--------------------------------------------------//
  }//end class ColMatrix3D
  //====================================================//
  //====================================================//


  public static class Point2D{
    GM01.ColMatrix2D point;
    
    public Point2D(GM01.ColMatrix2D point){//constructor
      //Create and save a clone of the ColMatrix2D object
      // used to define the point to prevent the point
      // from being corrupted by a later change in the
      // values stored in the original ColMatrix2D object
      // through use of its set method.
      this.point = new ColMatrix2D(
                       point.getData(0),point.getData(1));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return point.getData(0) + "," + point.getData(1);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return point.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        point.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//

    //This method draws a small circle around the location
    // of the point on the specified graphics context.
    public void draw(Graphics2D g2D){
      drawOval(g2D,getData(0)-3,
                   getData(1)+3,6,6);
    }//end draw

    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix2D object that
    // defines this Point2D object.
    public GM01.ColMatrix2D getColMatrix(){
      return point;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix2D objects that define two
    // Point2D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(point.equals(((GM01.Point2D)obj).
                                         getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Gets a displacement vector from one Point2D object
    // to a second Point2D object. The vector points from
    // the object on which the method is called to the
    // object passed as a parameter to the method. Kjell
    // describes this as the distance you would have to
    // walk along the x and then the y axes to get from
    // the first point to the second point.
    public GM01.Vector2D getDisplacementVector(
                                      GM01.Point2D point){
      return new GM01.Vector2D(new GM01.ColMatrix2D(
                            point.getData(0)-getData(0),
                            point.getData(1)-getData(1)));
    }//end getDisplacementVector
    //--------------------------------------------------//
    
    //Adds a Vector2D to a Point2D producing a
    // new Point2D.
    public GM01.Point2D addVectorToPoint(
                                      GM01.Vector2D vec){
      return new GM01.Point2D(new GM01.ColMatrix2D(
                          getData(0) + vec.getData(0),
                          getData(1) + vec.getData(1)));
    }//end addVectorToPoint
    //--------------------------------------------------//
    
    //Returns a new Point2D object that is a clone of
    // the object on which the method is called.
    public Point2D clone(){
      return new Point2D(
                  new ColMatrix2D(getData(0),getData(1)));
    }//end clone
    //--------------------------------------------------//
    
    //The purpose of this method is to rotate a point
    // around a specified anchor point in the x-y plane.
    //The rotation angle is passed in as a double value
    // in degrees with the positive angle of rotation
    // being counter-clockwise.
    //This method does not modify the contents of the
    // Point2D object on which the method is called.
    // Rather, it uses the contents of that object to
    // instantiate, rotate, and return a new Point2D
    // object.
    //For simplicity, this method translates the
    // anchorPoint to the origin, rotates around the
    // origin, and then translates back to the
    // anchorPoint.
    /*
    See http://www.ia.hiof.no/~borres/cgraph/math/threed/
    p-threed.html for a definition of the equations
    required to do the rotation.

    x2 = x1*cos - y1*sin
    y2 = x1*sin + y1*cos
    */ 
    public GM01.Point2D rotate(GM01.Point2D anchorPoint,
                               double angle){
      GM01.Point2D newPoint = this.clone();
      
      double tempX ;
      double tempY;
 
      //Translate anchorPoint to the origin
      GM01.Vector2D tempVec = 
            new GM01.Vector2D(anchorPoint.getColMatrix());
      newPoint = 
              newPoint.addVectorToPoint(tempVec.negate());
      
      //Rotate around the origin.
      tempX = newPoint.getData(0);
      tempY = newPoint.getData(1);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(angle*Math.PI/180) -
                      tempY*Math.sin(angle*Math.PI/180));

      newPoint.setData(//new y coordinate
                      1,
                      tempX*Math.sin(angle*Math.PI/180) +
                      tempY*Math.cos(angle*Math.PI/180));

      //Translate back to anchorPoint
      newPoint = newPoint.addVectorToPoint(tempVec);
      
      return newPoint;

    }//end rotate
    //--------------------------------------------------//
    
    //Multiplies this point by a scaling matrix received
    // as an incoming parameter and returns the scaled
    // point.
    public GM01.Point2D scale(GM01.ColMatrix2D scale){
      return new GM01.Point2D(new ColMatrix2D(
                          getData(0) * scale.getData(0),
                          getData(1) * scale.getData(1)));
    }//end scale
    //--------------------------------------------------//
  }//end class Point2D
  //====================================================//


  public static class Point3D{
    GM01.ColMatrix3D point;
    
    public Point3D(GM01.ColMatrix3D point){//constructor
      //Create and save a clone of the ColMatrix3D object
      // used to define the point to prevent the point
      // from being corrupted by a later change in the
      // values stored in the original ColMatrix3D object
      // through use of its set method.
      this.point = 
         new ColMatrix3D(point.getData(0),
                         point.getData(1),
                         point.getData(2));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return point.getData(0) + "," + point.getData(1) 
                                 + "," + point.getData(2);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        return point.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        point.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//

    //This method draws a small circle around the location
    // of the point on the specified graphics context.
    public void draw(Graphics2D g2D){
      
      //Get 2D projection coordinate values.
      ColMatrix2D temp = convert3Dto2D(point);
      drawOval(g2D,temp.getData(0)-3,
                   temp.getData(1)+3,
                   6,
                   6);
    }//end draw
    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix3D object that
    // defines this Point3D object.
    public GM01.ColMatrix3D getColMatrix(){
      return point;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix3D objects that define two
    // Point3D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(point.equals(((GM01.Point3D)obj).
                                         getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//

    //Gets a displacement vector from one Point3D object
    // to a second Point3D object. The vector points from
    // the object on which the method is called to the
    // object passed as a parameter to the method. Kjell
    // describes this as the distance you would have to
    // walk along the x and then the y axes to get from
    // the first point to the second point.
    public GM01.Vector3D getDisplacementVector(
                                      GM01.Point3D point){
      return new GM01.Vector3D(new GM01.ColMatrix3D(
                            point.getData(0)-getData(0),
                            point.getData(1)-getData(1),
                            point.getData(2)-getData(2)));
    }//end getDisplacementVector
    //--------------------------------------------------//
    
    //Adds a Vector3D to a Point3D producing a
    // new Point3D.
    public GM01.Point3D addVectorToPoint(
                                      GM01.Vector3D vec){
      return new GM01.Point3D(new GM01.ColMatrix3D(
                          getData(0) + vec.getData(0),
                          getData(1) + vec.getData(1),
                          getData(2) + vec.getData(2)));
    }//end addVectorToPoint
    //--------------------------------------------------//
    
    //Returns a new Point3D object that is a clone of
    // the object on which the method is called.
    public Point3D clone(){
      return new Point3D(new ColMatrix3D(getData(0),
                                         getData(1),
                                         getData(2)));
    }//end clone
    //--------------------------------------------------//
    
    //The purpose of this method is to rotate a point
    // around a specified anchor point in the following
    // order:
    // Rotate around z - rotation in x-y plane.
    // Rotate around x - rotation in y-z plane.
    // Rotate around y - rotation in x-z plane.
    //The rotation angles are passed in as double values
    // in degrees (based on the right-hand rule) in the
    // order given above, packaged in an object of the
    // class GM01.ColMatrix3D. (Note that in this case,
    // the ColMatrix3D object is simply a convenient
    // container and it has no significance from a matrix
    // viewpoint.)
    //The right-hand rule states that if you point the
    // thumb of your right hand in the positive direction
    // of an axis, the direction of positive rotation
    // around that axis is given by the direction that
    // your fingers will be pointing.
    //This method does not modify the contents of the
    // Point3D object on which the method is called.
    // Rather, it uses the contents of that object to
    // instantiate, rotate, and return a new Point3D
    // object.
    //For simplicity, this method translates the
    // anchorPoint to the origin, rotates around the
    // origin, and then translates back to the
    // anchorPoint.
    /*
    See http://www.ia.hiof.no/~borres/cgraph/math/threed/
    p-threed.html for a definition of the equations
    required to do the rotation.
    z-axis 
    x2 = x1*cos - y1*sin
    y2 = x1*sin + y1*cos
    
    x-axis
    y2 = y1*cos(v) - z1*sin(v)
    z2 = y1*sin(v) + z1* cos(v) 
    
    y-axis
    x2 = x1*cos(v) + z1*sin(v)
    z2 = -x1*sin(v) + z1*cos(v)
    */ 
    public GM01.Point3D rotate(GM01.Point3D anchorPoint,
                               GM01.ColMatrix3D angles){
      GM01.Point3D newPoint = this.clone();
      
      double tempX ;
      double tempY;
      double tempZ;
 
      //Translate anchorPoint to the origin
      GM01.Vector3D tempVec = 
            new GM01.Vector3D(anchorPoint.getColMatrix());
      newPoint = 
              newPoint.addVectorToPoint(tempVec.negate());

      double zAngle = angles.getData(0);
      double xAngle = angles.getData(1);
      double yAngle = angles.getData(2);
      
      //Rotate around z-axis
      tempX = newPoint.getData(0);
      tempY = newPoint.getData(1);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(zAngle*Math.PI/180) -
                      tempY*Math.sin(zAngle*Math.PI/180));

      newPoint.setData(//new y coordinate
                      1,
                      tempX*Math.sin(zAngle*Math.PI/180) +
                      tempY*Math.cos(zAngle*Math.PI/180));
      
      //Rotate around x-axis
      tempY = newPoint.getData(1);
      tempZ = newPoint.getData(2);
      newPoint.setData(//new y coordinate
                      1,
                      tempY*Math.cos(xAngle*Math.PI/180) -
                      tempZ*Math.sin(xAngle*Math.PI/180));

      newPoint.setData(//new z coordinate
                      2,
                      tempY*Math.sin(xAngle*Math.PI/180) +
                      tempZ*Math.cos(xAngle*Math.PI/180));
      
      //Rotate around y-axis
      tempX = newPoint.getData(0);
      tempZ = newPoint.getData(2);
      newPoint.setData(//new x coordinate
                      0,
                      tempX*Math.cos(yAngle*Math.PI/180) +
                      tempZ*Math.sin(yAngle*Math.PI/180));

      newPoint.setData(//new z coordinate
                     2,
                     -tempX*Math.sin(yAngle*Math.PI/180) +
                     tempZ*Math.cos(yAngle*Math.PI/180));
      
      //Translate back to anchorPoint
      newPoint = newPoint.addVectorToPoint(tempVec);
      
      return newPoint;

    }//end rotate
    //--------------------------------------------------//
    
    //Multiplies this point by a scaling matrix received
    // as an incoming parameter and returns the scaled
    // point.
    public GM01.Point3D scale(GM01.ColMatrix3D scale){
      return new GM01.Point3D(new ColMatrix3D(
                          getData(0) * scale.getData(0),
                          getData(1) * scale.getData(1),
                          getData(2) * scale.getData(2)));
    }//end scale
    //--------------------------------------------------//
  }//end class Point3D
  //====================================================//
  //====================================================//

  
  public static class Vector2D{
    GM01.ColMatrix2D vector;
    
    public Vector2D(GM01.ColMatrix2D vector){//constructor
      //Create and save a clone of the ColMatrix2D object
      // used to define the vector to prevent the vector
      // from being corrupted by a later change in the
      // values stored in the original ColVector2D object.
      this.vector = new ColMatrix2D(
                     vector.getData(0),vector.getData(1));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return vector.getData(0) + "," + vector.getData(1);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 1)){
        throw new IndexOutOfBoundsException();
      }else{
        return vector.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 1)){ 
        throw new IndexOutOfBoundsException();
      }else{
        vector.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//
    
    //This method draws a vector on the specified graphics
    // context, with the tail of the vector located at a
    // specified point, and with a small filled circle at
    // the head.
    public void draw(Graphics2D g2D,GM01.Point2D tail){

      drawLine(g2D,
               tail.getData(0),
               tail.getData(1),
               tail.getData(0)+vector.getData(0),
               tail.getData(1)+vector.getData(1));

      fillOval(g2D,
               tail.getData(0)+vector.getData(0)-3,
               tail.getData(1)+vector.getData(1)+3,
               6,
               6);
    }//end draw
    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix2D object that
    // defines this Vector2D object.
    public GM01.ColMatrix2D getColMatrix(){
      return vector;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix2D objects that define two
    // Vector2D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(vector.equals((
                     (GM01.Vector2D)obj).getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//
    
    //Adds this vector to a vector received as an incoming
    // parameter and returns the sum as a vector.
    public GM01.Vector2D add(GM01.Vector2D vec){
      return new GM01.Vector2D(new ColMatrix2D(
                       vec.getData(0)+vector.getData(0),
                       vec.getData(1)+vector.getData(1)));
    }//end add
    //--------------------------------------------------//
    
    //Returns the length of a Vector2D object.
    public double getLength(){
      return Math.sqrt(
           getData(0)*getData(0) + getData(1)*getData(1));
    }//end getLength
    //--------------------------------------------------//
    
    //Multiplies this vector by a scale factor received as
    // an incoming parameter and returns the scaled
    // vector.
    public GM01.Vector2D scale(Double factor){
      return new GM01.Vector2D(new ColMatrix2D(
                                    getData(0) * factor,
                                    getData(1) * factor));
    }//end scale
    //--------------------------------------------------//
    
    //Changes the sign on each of the vector components
    // and returns the negated vector.
    public GM01.Vector2D negate(){
      return new GM01.Vector2D(new ColMatrix2D(
                                            -getData(0),
                                            -getData(1)));
    }//end negate
    //--------------------------------------------------//
    
    //Returns a new vector that points in the same
    // direction but has a length of one unit.
    public GM01.Vector2D normalize(){
      double length = getLength();
      return new GM01.Vector2D(new ColMatrix2D(
                                      getData(0)/length,
                                      getData(1)/length));
    }//end normalize
    //--------------------------------------------------//
  }//end class Vector2D
  //====================================================//


  public static class Vector3D{
    GM01.ColMatrix3D vector;
    
    public Vector3D(GM01.ColMatrix3D vector){//constructor
      //Create and save a clone of the ColMatrix3D object
      // used to define the vector to prevent the vector
      // from being corrupted by a later change in the
      // values stored in the original ColMatris3D object.
      this.vector = new ColMatrix3D(vector.getData(0),
                                    vector.getData(1),
                                    vector.getData(2));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return vector.getData(0) + "," + vector.getData(1) 
                                + "," + vector.getData(2);
    }//end toString
    //--------------------------------------------------//
    
    public double getData(int index){
      if((index &lt; 0) || (index &gt; 2)){
        throw new IndexOutOfBoundsException();
      }else{
        return vector.getData(index);
      }//end else
    }//end getData
    //--------------------------------------------------//
    
    public void setData(int index,double data){
      if((index &lt; 0) || (index &gt; 2)){ 
        throw new IndexOutOfBoundsException();
      }else{
        vector.setData(index,data);
      }//end else
    }//end setData
    //--------------------------------------------------//
    
    //This method draws a vector on the specified graphics
    // context, with the tail of the vector located at a
    // specified point, and with a small circle at the
    // head.
    public void draw(Graphics2D g2D,GM01.Point3D tail){
      
      //Get a 2D projection of the tail
      GM01.ColMatrix2D tail2D = convert3Dto2D(tail.point);
      
      //Get the 3D location of the head
      GM01.ColMatrix3D head = 
                      tail.point.add(this.getColMatrix());
      
      //Get a 2D projection of the head
      GM01.ColMatrix2D head2D = convert3Dto2D(head);
      drawLine(g2D,tail2D.getData(0),
                   tail2D.getData(1),
                   head2D.getData(0),
                   head2D.getData(1));      

      //Draw a small filled circle to identify the head.
      fillOval(g2D,head2D.getData(0)-3,
                   head2D.getData(1)+3,
                   6,
                   6);

    }//end draw
    //--------------------------------------------------//
    
    //Returns a reference to the ColMatrix3D object that
    // defines this Vector3D object.
    public GM01.ColMatrix3D getColMatrix(){
      return vector;
    }//end getColMatrix
    //--------------------------------------------------//

    //This method overrides the equals method inherited
    // from the class named Object. It compares the values
    // stored in the ColMatrix3D objects that define two
    // Vector3D objects and returns true if they are equal
    // and false otherwise. 
    public boolean equals(Object obj){
      if(vector.equals((
                     (GM01.Vector3D)obj).getColMatrix())){
        return true;
      }else{
        return false;
      }//end else
     
    }//end overridden equals method
    //--------------------------------------------------//
    
    //Adds this vector to a vector received as an incoming
    // parameter and returns the sum as a vector.
    public GM01.Vector3D add(GM01.Vector3D vec){
      return new GM01.Vector3D(new ColMatrix3D(
                       vec.getData(0)+vector.getData(0),
                       vec.getData(1)+vector.getData(1),
                       vec.getData(2)+vector.getData(2)));
    }//end add
    //--------------------------------------------------//
    
    //Returns the length of a Vector3D object.
    public double getLength(){
      return Math.sqrt(getData(0)*getData(0) + 
                       getData(1)*getData(1) + 
                       getData(2)*getData(2));
    }//end getLength
    //--------------------------------------------------//
    
    //Multiplies this vector by a scale factor received as
    // an incoming parameter and returns the scaled
    // vector.
    public GM01.Vector3D scale(Double factor){
      return new GM01.Vector3D(new ColMatrix3D(
                                    getData(0) * factor,
                                    getData(1) * factor,
                                    getData(2) * factor));
    }//end scale
    //--------------------------------------------------//
    
    //Changes the sign on each of the vector components
    // and returns the negated vector.
    public GM01.Vector3D negate(){
      return new GM01.Vector3D(new ColMatrix3D(
                                            -getData(0),
                                            -getData(1),
                                            -getData(2)));
    }//end negate
    //--------------------------------------------------//
    
    //Returns a new vector that points in the same
    // direction but has a length of one unit.
    public GM01.Vector3D normalize(){
      double length = getLength();
      return new GM01.Vector3D(new ColMatrix3D(
                                      getData(0)/length,
                                      getData(1)/length,
                                      getData(2)/length));
    }//end normalize
    //--------------------------------------------------//
  }//end class Vector3D
  //====================================================//
  //====================================================//

  
  //A line is defined by two points. One is called the
  // tail and the other is called the head. Note that this
  // class has the same name as one of the classes in
  // the Graphics2D class. Therefore, if the class from
  // the Graphics2D class is used in some future upgrade
  // to this program, it will have to be fully qualified.
  public static class Line2D{
    GM01.Point2D[] line = new GM01.Point2D[2];
    
    public Line2D(GM01.Point2D tail,GM01.Point2D head){
      //Create and save clones of the points used to
      // define the line to prevent the line from being 
      // corrupted by a later change in the coordinate
      // values of the points.
      this.line[0] = new Point2D(new GM01.ColMatrix2D(
                        tail.getData(0),tail.getData(1)));
      this.line[1] = new Point2D(new GM01.ColMatrix2D(
                        head.getData(0),head.getData(1)));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return "Tail = " + line[0].getData(0) + "," 
             + line[0].getData(1) + "\nHead = " 
             + line[1].getData(0) + "," 
             + line[1].getData(1);
    }//end toString
    //--------------------------------------------------//

    public GM01.Point2D getTail(){
      return line[0];
    }//end getTail
    //--------------------------------------------------//
    
    public GM01.Point2D getHead(){
      return line[1];
    }//end getHead
    //--------------------------------------------------//
    
    public void setTail(GM01.Point2D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[0] = new Point2D(new GM01.ColMatrix2D(
                newPoint.getData(0),newPoint.getData(1)));
    }//end setTail
    //--------------------------------------------------//
    
    public void setHead(GM01.Point2D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[1] = new Point2D(new GM01.ColMatrix2D(
                newPoint.getData(0),newPoint.getData(1)));
    }//end setHead
    //--------------------------------------------------//
    
    public void draw(Graphics2D g2D){
      drawLine(g2D,getTail().getData(0),
                   getTail().getData(1),
                   getHead().getData(0),
                   getHead().getData(1));
    }//end draw
    //--------------------------------------------------//
  }//end class Line2D
  //====================================================//


  //A line is defined by two points. One is called the
  // tail and the other is called the head.
  public static class Line3D{
    GM01.Point3D[] line = new GM01.Point3D[2];
    
    public Line3D(GM01.Point3D tail,GM01.Point3D head){
      //Create and save clones of the points used to
      // define the line to prevent the line from being 
      // corrupted by a later change in the coordinate
      // values of the points.
      this.line[0] = new Point3D(new GM01.ColMatrix3D(
                                        tail.getData(0),
                                        tail.getData(1),
                                        tail.getData(2)));
      this.line[1] = new Point3D(new GM01.ColMatrix3D(
                                        head.getData(0),
                                        head.getData(1),
                                        head.getData(2)));
    }//end constructor
    //--------------------------------------------------//

    public String toString(){
      return "Tail = " + line[0].getData(0) + "," 
                       + line[0].getData(1)  + "," 
                       + line[0].getData(2) 
                       + "\nHead = " 
                       + line[1].getData(0) + "," 
                       + line[1].getData(1) + ","      
                       + line[1].getData(2);
    }//end toString
    //--------------------------------------------------//

    public GM01.Point3D getTail(){
      return line[0];
    }//end getTail
    //--------------------------------------------------//
    
    public GM01.Point3D getHead(){
      return line[1];
    }//end getHead
    //--------------------------------------------------//

    public void setTail(GM01.Point3D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[0] = new Point3D(new GM01.ColMatrix3D(
                                    newPoint.getData(0),
                                    newPoint.getData(1),
                                    newPoint.getData(2)));
    }//end setTail
    //--------------------------------------------------//
    
    public void setHead(GM01.Point3D newPoint){
      //Create and save a clone of the new point to
      // prevent the line from being corrupted by a
      // later change in the coordinate values of the
      // point.
      this.line[1] = new Point3D(new GM01.ColMatrix3D(
                                    newPoint.getData(0),
                                    newPoint.getData(1),
                                    newPoint.getData(2)));
    }//end setHead
    //--------------------------------------------------//

    public void draw(Graphics2D g2D){
      
      //Get 2D projection coordinates.
      GM01.ColMatrix2D tail = 
                           convert3Dto2D(getTail().point);
      GM01.ColMatrix2D head = 
                           convert3Dto2D(getHead().point);

      drawLine(g2D,tail.getData(0),
                   tail.getData(1),
                   head.getData(0),
                   head.getData(1));
    }//end draw
    //--------------------------------------------------//
  }//end class Line3D
  //====================================================//

}//end class GM01
//======================================================//
</code>






<para id="p1303">
<emphasis id="strong1246" effect="bold">
<emphasis id="Listing_31" effect="bold">

Listing 31

</emphasis>

. Source code for the game program named GM01test08.

</emphasis>
</para>





<code id="pre1030" display="block">/*GM01test08.java 
Copyright 2008, R.G.Baldwin
Revised 02/28/08.

This is an interactive 3D game program  This game 
simulates a school of prey fish being attacked and eaten
by a predator. The objective for the player is to cause 
the predator to catch and eat all of the prey fish in a 
minimum amount of time.

The strategy is for the player to initiate a series of 
attacks by the predator, properly timed so as to minimize 
the elapsed time required for the predator to catch and 
eat all of the prey fish. The final elapsed time depends 
both on player strategy and random chance. In other words,
as is the case in many games, this game is part strategy 
and part chance.

The prey fish, (shown in red), swim in a large swirling 
cluster. The predator, (shown in blue), swims around the 
cluster, darting into the cluster on command to catch and 
eat as many prey fish as possible during each attack.

When the predator attacks, the prey fish tend to scatter,
breaking up their tight formation and making it more 
difficult for the predator to catch them. However, if the 
predator is allowed to swim around them again for a short 
period following an attack, they will form back into a 
cluster. The attacks should be timed so that the prey fish
are in a reasonably tight cluster at the beginning of each
attack so that multiple prey fish will be caught and 
eaten during the attack. However, allowing too much time 
between attacks is detrimental to minimizing the total 
elapsed time. Thus, the player must make a tradeoff
between elapsed time between attacks and the tightness of
the cluster during the attacks. Another disadvantage of
waiting too long between attacks is explained below.

In addition to some other controls, the GUI provides an 
Attack button and an elapsed-time/kill-count indicator. 
At any point in time, this indicator displays the elapsed 
time in milliseconds when the most recent prey fish was 
caught along with the total number of prey fish that have 
been caught and eaten. The two values are separated by 
a "/" character.

When all of the prey fish have been caught and eaten by 
the predator, the elapsed time indicator shows the time 
in milliseconds required to catch and eat all of the prey
fish.  It also shows the number of prey fish that were 
caught and eaten, which should match one of the player
input values.

Initially, when the player clicks the Start button, the 
predator is not in attack mode. The predator swims around
the school of prey fish encouraging them to bunch up 
together in a smaller and tighter cluster. This behavior 
continues until the player clicks the Attack button, at 
which time the predator enters the attack mode and makes 
an attack on the cluster.

If the player clicks the Attack button too early, or 
doesn't wait long enough between attacks, the prey fish 
will be in a loose cluster, and the attack will yield
very few fish.

If the player waits too long to click the Attack button, 
or waits too long between attacks, the predator will have
spiraled in so close to the prey fish that they will break
formation and begin to scatter, making it difficult for 
the predator to catch a large number of fish during the 
attack. This is the other disadvantage of waiting too 
long that I mentioned above.

The prey fish have a fairly effective defense mechanism
and can do a reasonably good job of escaping the predator.
The final three or four prey fish are usually the most 
difficult to catch.

When the predator is successful in catching a prey fish, 
that fish is removed from the prey-fish population, 
causing the prey-fish population to shrink over time.

Each time the predator is successful in catching a prey 
fish, the program emits an audible beep to provide 
feedback to the player.
 
Even when the predator is not in the attack mode, its 
presence has a significant effect on the behavior of the 
school of prey fish. As the predator swims around the 
school of prey fish, they tend to bunch up into a smaller 
and tighter cluster, but when the predator swims too 
close, the prey fish panic and tend to scatter, breaking
up the tight cluster.

In addition to the elapsed time indicator and the Attack
button, the GUI contains an input text field for the 
number of prey fish that will be in the population plus a 
Start button and a Stop button. The GUI also contains 
check boxes that allow the player to display points only,
direction vectors only, or both for the prey fish. (Only 
the direction vector is displayed for the predator.)

The player specifies the number of randomly-placed prey 
fish that will be in the population and clicks the Start 
button to start the animation. At this point, the prey 
fish swim in a large swirling cluster and the predator 
swims around them encouraging them to form a tighter
cluster  Prey fish motion is random but each fish 
generally tends to spiral toward the center of the 
cluster.

When the user clicks the Attack button, the behavior is 
as described earlier.

The animation continues until the user clicks the Stop 
button. The user can click the Stop button, change any of 
the parameters, and then click Start again to re-start the
game with zero elapsed time and different parameters.

The animation is most impressive when the direction 
vectors are displayed for the prey fish because the 
vectors provide a lot of information about how the prey 
fish are reacting to the predator.

In addition to the school of prey fish and the predator,
the graphical output also shows a large circle drawn
with broken lines. This circle represents the intersection
of a sphere and the x-y plane.

The purpose of the sphere, which is centered on the 
origin, is to provide a soft boundary for keeping the 
prey fish and the predator in the 3D playing field. The 
prey fish and the predator all have a tendency to remain 
inside the sphere, but they may occasionally stray outside
the sphere. If they do, the program code will encourage 
them to return to the 3D playing field inside the sphere.

This game is fully 3D. The prey fish and the predator are
free to swim in any direction in 3D space. The tails on
the prey fish and the predator appear longest when they
are swimming parallel to the x-y plane. As they change 
their angle relative to the x-y plane, the tails appear 
to become shorter and shorter until in some cases, they 
appear not to have a tail at all. This is best observed
by clicking the Stop button just as the fish scatter 
during an attack and freezing the state of the fish in
the 3D world. If you examine the image at that point, you
are likely to see some fish with shorter tails than other
fish.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.util.*;

class GM01test08{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test08
//======================================================//

class GUI extends JFrame implements ActionListener{

  int hSize = 400;//horizontal size of JFrame.
  int vSize = 450;//vertical size of JFrame
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas 
  Graphics2D g2D;//off-screen graphics context.
  int numberPoints = 0;//can be modified by the user.
  JTextField numberPointsField; //user input field.
  Random random = new Random();//random number generator

  //The following collection is used to store the prey
  // objects.
  ArrayList &lt;GM01.Point3D&gt; preyObjects;
  
  //The following collection is used to store the vectors
  // for display.
  ArrayList &lt;GM01.Vector3D&gt; displayVectors;
  
  //The following are used to support user input.
  Checkbox drawPointsBox;//User input field
  Checkbox drawVectorsBox;//User input field.
  JButton attackButton;
  boolean drawPoints = true;
  boolean drawVectors = true;
  
  //The following JTextField is used to display the
  // elapsed time and the number of prey fish that 
  // have been caught and eaten.
  JTextField timer;

  long baseTime;//Used to compute the elapsed time.

  //Used to compute the number of fish caught and eaten.  
  int killCount = 0;

  //Animation takes place while the following is true.
  boolean animate = false;
  
  //Attacks take place while the following is true.
  boolean attack = false;
  
  //Working variables used by the animation code.
  GM01.Vector3D predatorVec;
  GM01.Point3D preyCenter;
  GM01.Point3D predator;
  //----------------------------------------------------//
  
  GUI(){//constructor
  
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
    //Instantiate the user input components.
    numberPointsField = new JTextField("100",5);
    JButton startButton = new JButton("Start");
    attackButton = new JButton("Attack");
    JButton stopButton = new JButton("Stop");
    timer = new JTextField("0",5);
    drawPointsBox = new Checkbox("Draw Points",false);
    drawVectorsBox = new Checkbox("Draw Vectors",true);

    //Instantiate a JPanel that will house the user input
    // components and set its layout manager.
    JPanel controlPanel = new JPanel();
    controlPanel.setLayout(new GridLayout(0,2));

    //Add the user input component and appropriate labels
    // to the control panel.
    controlPanel.add(new JLabel(" Number Prey Fish"));    
    controlPanel.add(numberPointsField);
    controlPanel.add(drawPointsBox);
    controlPanel.add(drawVectorsBox);
    controlPanel.add(startButton);
    controlPanel.add(attackButton);
    controlPanel.add(stopButton);
    controlPanel.add(timer);

    //Add the control panel to the SOUTH position in the
    // JFrame.
    this.getContentPane().add(
                         BorderLayout.SOUTH,controlPanel);

    //Instantiate a new drawing canvas and add it to the
    // CENTER of the JFrame above the control panel.
    myCanvas = new MyCanvas();
    this.getContentPane().add(
                            BorderLayout.CENTER,myCanvas);

    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    
    //Make the size of the off-screen image match the
    // size of the canvas.
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    g2D = (Graphics2D)(osi.getGraphics());
    
    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    
    //Register this object as an action listener on all
    // three buttons.
    startButton.addActionListener(this);
    attackButton.addActionListener(this);
    stopButton.addActionListener(this);
    
    //Make the drawing color RED at startup.
    g2D.setColor(Color.RED);

  }//end constructor
  //----------------------------------------------------//
  
  //This method is called to respond to a click on any
  // of the three buttons.
  public void actionPerformed(ActionEvent e){

    if(e.getActionCommand().equals("Start") &amp;&amp; !animate){
      //Service the Start button.
      
      //Get several user input values.
      numberPoints = Integer.parseInt(
                             numberPointsField.getText());

      if(drawPointsBox.getState()){
        drawPoints = true;
      }else{
        drawPoints = false;
      }//end else
      
      if(drawVectorsBox.getState()){
        drawVectors = true;
      }else{
        drawVectors = false;
      }//end else

      //Initialize some working variables used in the
      // animation process.
      animate = true;
      baseTime = new Date().getTime();
      killCount = 0;
      
      //Enable the Attack button.
      attackButton.setEnabled(true);
      
      //Initialize the text in the timer field.
      timer.setText("0 / 0");
      
      //Cause the run method belonging to the animation
      // thread object to be executed.
      new Animate().start();
    }//end if
    
    
    if(e.getActionCommand().equals("Attack") &amp;&amp; animate){
      //Service the Attack button.
      
      //This will cause the predator to attack the prey
      // objects.
      attack = true;
      
      //Point the predator toward the center of the prey
      // fish formation. Reduce the scale factor to less
      // than 1.0 to slow down the attack and make it
      // easier for the prey fish to escape the predator.
      predatorVec = 
               predator.getDisplacementVector(preyCenter).
                                               scale(1.0);
               
      //Disable the Attack button. It will be enabled
      // again when the attack is finished.
      attackButton.setEnabled(false);
    }//end if
    

    if(e.getActionCommand().equals("Stop") &amp;&amp; animate){
      //Service the Stop button.
      
      //This will cause the run method to terminate and
      // stop the animation. It will also clear the
      // attack flag so that the next time the animation
      // is started, the predator won't be in the 
      // attack mode.
      animate = false;
      attack = false;
    }//end if

  }//end actionPerformed
  //====================================================//
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the update method to eliminate the default
    // clearing of the Canvas in order to reduce or
    // eliminate the flashing that that is often caused by
    // such default clearing.
    //In this case, it isn't necessary to clear the canvas
    // because the off-screen image is cleared each time
    // it is updated. This method will be called when the
    // JFrame and the Canvas appear on the screen or when
    // the repaint method is called on the Canvas object.
    public void update(Graphics g){
      paint(g);//Call the overridden paint method.
    }//end overridden update()
    
    //Override the paint() method. The purpose of the
    // paint method is to display the off-screen image on
    // the screen. This method is called by the update
    // method above.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()

  }//end inner class MyCanvas
  //====================================================//
  
  //This is an animation thread. The purpose of this
  // animation is to simulate something like a school of
  // prey fish and a predator. The animation behavior
  // is described in the opening comments for the program
  // as a whole.
  class Animate extends Thread{
    //Declare a general purpose variable of type Point3D.
    // It will be used for a variety of purposes.
    GM01.Point3D tempPrey;
    
    //Declare two general purpose variables of type
    // Vector3D. They will be used for a variety of
    // purposes.
    GM01.Vector3D tempVectorA;
    GM01.Vector3D tempVectorB;
    //--------------------------------------------------//
    
    public void run(){
      //This method is executed when start is called on
      // this Thread object.
      //Create a new empty container for the prey objects.
      //Note the use of "Generics" syntax.
      preyObjects = new ArrayList&lt;GM01.Point3D&gt;();
      
      //Create a new empty container for the vectors. The
      // only reason the vectors are saved is so that they
      // can be displayed later
      displayVectors = new ArrayList&lt;GM01.Vector3D&gt;();
      
      //Create a set of prey objects at random locations
      // and store references to the prey objects in the
      // preyObjects container.
      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        preyObjects.add(new GM01.Point3D(
          new GM01.ColMatrix3D(
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5))));
                         
        //Populate the displayVectors collection with
        // dummy vectors.
        displayVectors.add(tempVectorA);
      }//end for loop

      //This object that will be the predator.
      // Position it initially near the top of the screen.
      predator = new GM01.Point3D(
                     new GM01.ColMatrix3D(-100,100,-100));

      //Create a reference point to mark the origin. Among
      // other things, it will be used as the center of a
      // sphere, which in turn will be used to attempt to
      // keep the prey and predator objects from leaving
      // the playing field.
      GM01.Point3D origin = 
            new GM01.Point3D(new GM01.ColMatrix3D(0,0,0));
      
      //Declare some variables that will be used to
      // compute and save the average position of all of
      // the prey objects.
      double xSum = 0;
      double ySum = 0;
      double zSum = 0;


      //This is the animation loop. The value of animate
      // is set to true by the Start button and is set to
      // false by the Stop button. Setting it to false
      // will cause the run method to terminate and stop
      // the animation.
      while(animate){
        //Compute and save the average position of all the
        // prey objects at the beginning of the loop. Save
        // the average position in the Point3D object
        // referred to by preyCenter.
        xSum = 0;
        ySum = 0;
        zSum = 0;

        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          xSum += tempPrey.getData(0);
          ySum += tempPrey.getData(1);
          zSum += tempPrey.getData(2);
        }//end for loop
        
        //Construct a reference point at the average
        // position of all the prey objects.
        preyCenter = new GM01.Point3D(
           new GM01.ColMatrix3D(xSum/preyObjects.size(),
                                ySum/preyObjects.size(),
                                zSum/preyObjects.size()));


        //Move all of the prey objects in a way that
        // causes them to spiral toward the preyCenter.
        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          //Stop spiraling toward the center when the
          // population of prey objects contains a
          // single object because there is no center at
          // that point.
          if(preyObjects.size() &gt; 1){
            //Get the next prey object
            tempPrey = preyObjects.get(cnt);
            //Find the displacement vector from this prey
            // object to the preyCenter
            tempVectorA = tempPrey.getDisplacementVector(
                                              preyCenter);
                    
            //Create a vector that is rotated relative to
            // tempVectorA. Note how each component in
            // this new vector is set equal to a different
            // component in tempVectorA. Scale it.
            tempVectorB = new GM01.Vector3D(
              new GM01.ColMatrix3D(
                      tempVectorA.getData(1),
                      tempVectorA.getData(2),
                      tempVectorA.getData(0))).scale(1.2);
                                                       
            //Add the two vectors and move the prey object
            // according to the sum of the vectors. Scale
            // one of the vectors during the addition to
            // adjust the rate at which the object spirals
            // toward the center.
            //Moving the prey object in the direction of
            // the sum of these two vectors produces a
            // motion that causes the prey object to
            // spiral toward the preyCenter instead of
            // simply moving in a straight line toward the
            // preyCenter.
            tempVectorA = 
                  tempVectorA.scale(0.9).add(tempVectorB);
            //Apply an overall scale factor to the sum
            // vector before using it to move the prey
            // object.
            tempPrey = tempPrey.addVectorToPoint(
                                  tempVectorA.scale(0.1));

            //Save a clone of the prey object in its new
            // position. Save a clone instead of the
            // actual object as a safety measure to avoid
            // the possibility of corrupting the object
            // later when the reference variable is used
            // for some other purpose.
            preyObjects.set(cnt,tempPrey.clone());
            
            //Save a normalized version of the direction
            // vector for drawing later. Set the length
            // of the normalized vector to 15 units.
            displayVectors.set(
                 cnt,tempVectorA.normalize().scale(15.0));
          }else{
            //When the population consists of a single
            // prey object, save a dummy direction vector
            // for drawing later. This is necessary to
            // prevent a null pointer exception when the
            // user specifies only one prey object and
            // then clicks the Start button.
            displayVectors.set(
                   cnt,new GM01.Vector3D(
                          new GM01.ColMatrix3D(10,10,0)));
          }//end else
                 
        }//end loop to spiral prey objects toward center.
        

        //Try to keep the prey objects from colliding with
        // one another by moving each prey object away
        // from its close neighbors.
        GM01.Point3D refPrey = null;
        GM01.Point3D testPrey= null;
        for(int row = 0;row &lt; preyObjects.size();row++){
          refPrey = preyObjects.get(row);
          //Compare the position of the reference prey
          // object with the positions of each of the
          // other prey objects.
          for(int col = 0;col &lt; preyObjects.size();col++){
            //Get another prey object for  proximity test.
            testPrey = preyObjects.get(col);
            //Don't test a prey object against itself.
            if(col != row){
              //Get the vector from the refPrey object to
              // the testPrey object.
              tempVectorA = refPrey.
                          getDisplacementVector(testPrey);
              
              //If refPrey is too close to testPrey, move
              // it away from the testPrey object.
              if(tempVectorA.getLength() &lt; 10){
                //Move refPrey away from testPrey by a
                // small amount in the opposite direction.
                refPrey = refPrey.addVectorToPoint(
                         tempVectorA.scale(0.2).negate());

              }//end if on proximity test
            }//end if col != row
          }//end loop on col
          //The refPrey object may or may not have been
          // moved.  Save it anyway.
          preyObjects.set(row,refPrey.clone());
        }//end loop on row


        //Make each prey object react to the predator with
        // a defensive mechanism when the predator
        // approaches the prey object.
        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          
          //Get a displacement vector from the prey object
          // to the predator.
          tempVectorA = tempPrey.getDisplacementVector(
                                                predator);

          //If the prey object is within a certain
          // threshold distance from the predator, move
          // the prey object a random distance in the
          // opposite direction. Then test again to see if
          // the prey object is still within another
          // smaller threshold distance. If so, the prey
          // object was not successful in escaping the
          // predator and has been caught and eaten by the
          // predator. Remove the prey object from the
          // population and sound a beep to notify the
          // user of the successful attack by the
          // predator.
          if(tempVectorA.getLength() &lt; 50){
            //The predator is within striking range of the
            // prey object. Make the prey object try to
            // escape by moving a random distance in the
            // opposite direction. The value returned by
            // the random number generator ranges from 0
            // to 1.0.
            tempVectorA = tempVectorA.negate().scale(
                                     random.nextDouble());
            tempPrey = 
                   tempPrey.addVectorToPoint(tempVectorA);
            
            //Check to see if the escape was successful
            // by testing against a smaller threshold
            // distance.
            //Get a new displacement vector from the prey
            // object to the predator.
            tempVectorA = 
                 tempPrey.getDisplacementVector(predator);
            //Decrease or increase the following
            // threshold distance to cause the prey
            // object to be more or less successful in the
            // escape attempt.
            if(tempVectorA.getLength() &lt; 25){
              //Escape was not successful. The predator is
              // still within striking distance of the
              // prey object. Remove the prey object and
              // its direction vector from the population
              // and sound a beep. Also increase the
              // killCount by 1 for purposes of display
              // only.
              tempPrey = preyObjects.remove(cnt);
              displayVectors.remove(cnt);
              Toolkit.getDefaultToolkit().beep();
              killCount++;
              
              //Display the elapsed time in milliseconds
              // since the Start button was clicked along
              // with the number of fish that have been
              // caught and eaten. The value that is
              // displayed is the elapsed time when the
              // most recent prey fish was caught by the
              // predator and is not the total elapsed
              // time since the Start button was clicked.
              // When all prey fish have been caught, the
              // final time that is displayed is the time
              // required for the predator to catch all of
              // the fish in the population.
              timer.setText(
                       "" 
                       + (new Date().getTime() - baseTime)
                       + " / " 
                       + killCount);

            }else{
              //The escape attempt was successful. Restore
              // a clone of the prey object in its new
              // location along with its direction vector
              // to the population.
              preyObjects.set(cnt,tempPrey.clone());
              //Save a normalized version of the direction
              // vector for drawing later.  It will
              // overwrite the previously saved vector and
              // if you watch closely it will show the
              // prey object running away from the
              // predator..
              displayVectors.set(
                 cnt,tempVectorA.normalize().scale(15.0));
            }//end else
          }//end if distance &lt; 50
        }//end for loop on population


        //Deal with prey objects that stray outside the
        // spherical boundary. Give them a nudge back
        // toward the origin.
        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          
          //Test to determine if the prey object is
          // outside of a sphere centered on the origin
          // with a radius equal to the maximum dimension
          // on the vertical axis.
          if(tempPrey.getDisplacementVector(origin).
                             getLength() &gt; 0.5*osiHeight){
            //Enable the following statement to get an
            // audible beep each time a prey object goes
            // out of bounds.
            //Toolkit.getDefaultToolkit().beep();
            //Give the prey object a nudge back toward the
            // origin and save a clone of the prey object
            // in its new location.
            tempVectorA = 
                   tempPrey.getDisplacementVector(origin);
            tempPrey = tempPrey.addVectorToPoint(
                                  tempVectorA.scale(0.1));
            preyObjects.set(cnt,tempPrey.clone());
          }//end if prey object is out of bounds
        }//end for loop to process each prey object


        //Erase the screen
        g2D.setColor(Color.WHITE);
        GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);


        //Draw a broken-line circle that represents the
        // intersection of the spherical boundary with the
        // x-y plane. Although the prey objects and the
        // predator can stray outside this sphere, they
        // prefer to be inside the sphere.
        GM01.Point3D tempPointA = new GM01.Point3D(
                   new GM01.ColMatrix3D(osiHeight/2,0,0));
        GM01.Point3D tempPointB;
        //The circle is defined by 39 points around the
        // circumference.
        g2D.setColor(Color.BLACK);
        for(int cnt = 0;cnt &lt; 39;cnt++){
          tempPointB = 
           new GM01.Point3D(new GM01.ColMatrix3D(
           osiHeight/2*Math.cos((cnt*360/39)*Math.PI/180),
           osiHeight/2*Math.sin((cnt*360/39)*Math.PI/180),
           0));
            
          //Connect every third pair of points with a line
          if(cnt%3 == 0){
            new GM01.Line3D(
                         tempPointA,tempPointB).draw(g2D);
          }//end if
          //Save the old point.
          tempPointA = tempPointB;
        }//end for loop
        
        //Draw the final line required to close the circle
        new GM01.Line3D(tempPointA,new GM01.Point3D(
                           new GM01.ColMatrix3D(
                             osiHeight/2,0,0))).draw(g2D);


        //Restore the drawing color.
        g2D.setColor(Color.RED);
        //Draw the objects in the preyObjects container
        // and the vectors in the displayVectors
        // container.
        for(int cnt = 0;cnt &lt; preyObjects.size();cnt++){
          tempPrey = preyObjects.get(cnt);
          if(drawPoints){
            tempPrey.draw(g2D);//draw circle around point
          }//end if
          
          if(drawVectors){
            //Draw the vector with its tail at the point.
            displayVectors.get(cnt).draw(g2D,tempPrey);
          }//end if
        }//end for loop
        
        
        //When the predator is not in attack mode, cause
        // it to slowly circle the cluster of prey
        // objects.
        if(!attack){
          //Get a displacement vector pointing from the
          // predator to the preyCenter.
          predatorVec = 
               predator.getDisplacementVector(preyCenter);
                  
          //Create a vector that is rotated relative to
          // predatorVec. Note how each component in
          // this new vector is set equal to a different
          // component in predatorVec
          tempVectorB = new GM01.Vector3D(
            new GM01.ColMatrix3D(
                     predatorVec.getData(1),
                     predatorVec.getData(2),
                     predatorVec.getData(0))).scale(0.15);
                                                     
          //Scale predatorVec and add the two vectors.
          // Then move the predator according to the sum
          // of the vectors.
          //Moving the prey object in the direction of
          // the sum of these two vectors produces a
          // motion that causes the predator to
          // spiral toward the preyCenter instead of
          // simply moving in a straight line toward the
          // preyCenter. The scale factors control the
          // relative motion between the two directions,
          // and are fairly sensitive.
          predatorVec = 
                predatorVec.scale(0.095).add(tempVectorB);
          
          predator = predator.addVectorToPoint(
                                  predatorVec.scale(1.0));

        }else{//attack is true
          //Predator is in attack mode now. Stay in attack
          // mode using the same displacement vector until
          // the predator traverses the entire playing
          // field. This displacement vector originally
          // pointed toward the preyCenter and was created
          // in the actionPerformed method in response to
          // a click on the Attack button. In other words,
          // even though the prey fish scatter, the
          // predator is constrained to move in a straight
          // line across the playing field once an attack
          // is begun. An interesting update might be to
          // allow the predator to adjust its direction
          // as the prey fish scatter and the location of
          // preyCenter changes during the traversal
          // across the playing field.
          predator = predator.addVectorToPoint(
                                 predatorVec.scale(0.25));

          //Check to see if the predator is outside the
          // spherical boundary that defines the playing
          // field.
          if(predator.getDisplacementVector(origin).
                             getLength() &gt; 0.5*osiHeight){
            //Shift out of attack mode and start circling
            // the prey fish again.
            attack = false;
            attackButton.setEnabled(true);
          }//end if
        }//end else


        //Set the color to BLUE and draw the predator and
        // its displacement vector.
        g2D.setColor(Color.BLUE);
        //Enable the following statement to draw a circle
        // around the point that represents the predator.
        //predator.draw(g2D);
        
        //Draw the predator's vector.
        predatorVec.normalize().scale(15.0).draw(
                                            g2D,predator);
        g2D.setColor(Color.RED);//restore red color
        
        //Copy the off-screen image to the canvas and then
        // do it all again.
        myCanvas.repaint();
        
        //Insert a time delay. Change the sleep time to
        // speed up or slow down the animation. 
        try{
          Thread.currentThread().sleep(166);
        }catch(Exception e){
          e.printStackTrace();
        }//end catch
      }//end animation loop
    }//end run method
  }//end inner class named Animate
  //====================================================//

}//end class GUI
</code>






<para id="p1304">
<emphasis id="strong1247" effect="bold">
<emphasis id="Listing_32" effect="bold">

Listing 32

</emphasis>

. Source code for the program named GM01test04.

</emphasis>
</para>





<code id="pre1031" display="block">/*GM01test04.java 
Copyright 2008, R.G.Baldwin
Revised 02/25/08.

This animation program is designed to test many of the 2D
features of the GM01 game-math library.

The animation is generally based on the idea of a 
flocking behavior similar to that exhibited by birds.

A set of Point2D objects is created with random locations.
An additional Point2D object known at the target is also 
created. The target is drawn in red while the pursuers
are drawn in black.

An algorithm is executed that attempts to cause the points
to chase the target without colliding with one another.
Even though the algorithm causes the points to chase the 
target, it also tries to keep the points from colliding 
with the target.

A GUI is provided that contains an input text field for 
the number of points plus a Start button and a Stop
button. The GUI also contains check boxes that allow the 
user to elect to display points only, direction vectors 
only, or both. (The point and the direction vector is
always displayed for the target.)

The user specifies the number of randomly-placed points 
and clicks the Start button, at which time the animation
begins and the points start chasing the target.  Target 
motion is random. The animation continues until the user 
clicks the Stop button. The user can click the Stop 
button, change the number of points, and then click Start 
again to re-start the animation with a different number
of points chasing the target.

The algorithm seems to cause the points to come together 
and fly in formation while chasing the target. The most 
common formation is hexagonal but sometimes triangles and
incomplete hexagons also appear. I have no explanation for
this behavior. The tendency to fly in formation is more
visually obvious when only the points are displayed.

On the other hand, the animation is most impressive when 
the direction vectors are displayed, with or without 
points, because the vectors illustrate the dogged 
determination and undying focus that the pursuers maintain
while chasing the target.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.util.*;

class GM01test04{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test04
//======================================================//

class GUI extends JFrame implements ActionListener{

  int hSize = 400;//horizontal size of JFrame.
  int vSize = 400;//vertical size of JFrame
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas 
  Graphics2D g2D;//off-screen graphics context.
  int numberPoints = 0;//can be modified by the user.
  JTextField numberPointsField; //user input field.
  Random random = new Random();//random number generator

  //The following collection is used to store the points.
  ArrayList &lt;GM01.Point2D&gt; points;
  
  //The following collection is used to store the vectors
  // for display.
  ArrayList &lt;GM01.Vector2D&gt; vectors;
  
  //The following are used to support user input.
  Checkbox drawPointsBox;//User input field
  Checkbox drawVectorsBox;//User input field.
  boolean drawPoints = true;
  boolean drawVectors = true;
  
  //Animation takes place while the following is true.
  boolean animate = false;
  //----------------------------------------------------//
  
  GUI(){//constructor
  
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
    //Instantiate the user input components.
    numberPointsField =new JTextField("6",5);
    JButton startButton = new JButton("Start");
    JButton stopButton = new JButton("Stop");
    drawPointsBox = new Checkbox("Draw Points",true);
    drawVectorsBox = new Checkbox("Draw Vectors",true);

    //Instantiate a JPanel that will house the user input
    // components and set its layout manager.
    JPanel controlPanel = new JPanel();
    controlPanel.setLayout(new GridLayout(0,2));

    //Add the user input component and appropriate labels
    // to the control panel.
    controlPanel.add(new JLabel(" Number Points"));    
    controlPanel.add(numberPointsField);
    controlPanel.add(drawPointsBox);
    controlPanel.add(drawVectorsBox);
    controlPanel.add(startButton);
    controlPanel.add(stopButton);

    //Add the control panel to the SOUTH position in the
    // JFrame.
    this.getContentPane().add(
                         BorderLayout.SOUTH,controlPanel);

    //Instantiate a new drawing canvas and add it to the
    // CENTER of the JFrame above the control panel.
    myCanvas = new MyCanvas();
    this.getContentPane().add(
                            BorderLayout.CENTER,myCanvas);

    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    
    //Make the size of the off-screen image match the
    // size of the canvas.
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    g2D = (Graphics2D)(osi.getGraphics());
    
    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    
    //Register this object as an action listener on the
    // startButton and the stopButton
    startButton.addActionListener(this);
    stopButton.addActionListener(this);
    
  }//end constructor
  //----------------------------------------------------//
  
  //This method is called to respond to a click on the
  // startButton or the stopButton.
  public void actionPerformed(ActionEvent e){

    if(e.getActionCommand().equals("Start") &amp;&amp; !animate){
      numberPoints = Integer.parseInt(
                             numberPointsField.getText());

      if(drawPointsBox.getState()){
        drawPoints = true;
      }else{
        drawPoints = false;
      }//end else
      
      if(drawVectorsBox.getState()){
        drawVectors = true;
      }else{
        drawVectors = false;
      }//end else

      animate = true;
      new Animate().start();
    }//end if
    
    if(e.getActionCommand().equals("Stop") &amp;&amp; animate){
      //This will cause the run method to terminate and
      // stop the animation.
      animate = false;
    }//end if

  }//end actionPerformed
  //====================================================//
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the update method to eliminate the default
    // clearing of the Canvas in order to reduce or
    // eliminate the flashing that that is often caused by
    // such default clearing.
    //In this case, it isn't necessary to clear the canvas
    // because the off-screen image is cleared each time
    // it is updated. This method will be called when the
    // JFrame and the Canvas appear on the screen or when
    // the repaint method is called on the Canvas object.
    public void update(Graphics g){
      paint(g);//Call the overridden paint method.
    }//end overridden update()
    
    //Override the paint() method. The purpose of the
    // paint method is to display the off-screen image on
    // the screen. This method is called by the update
    // method above.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()

  }//end inner class MyCanvas
  //====================================================//
  
  //This is an animation thread.
  class Animate extends Thread{
    //Declare a general purpose variable of type Point2D.
    // It will be used for a variety of purposes.
    GM01.Point2D tempPoint;
    
    //Declare a general purpose variable of type Vector2D.
    // It will be used for a variety of purposes.
    GM01.Vector2D tempVector;
    
    public void run(){
      //This method is executed when start is called on
      // this thread.
      //Create a new empty container for the points.
      points = new ArrayList&lt;GM01.Point2D&gt;();
      
      //Create a new empty container for the vectors.
      vectors = new ArrayList&lt;GM01.Vector2D&gt;();
      
      //Create a set of Point objects at random locations
      // and store references to the points in the
      // ArrayList object..
      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        points.add(new GM01.Point2D(
          new GM01.ColMatrix2D(
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5))));
                         
        //Populate vectors collection with dummy vectors.
        vectors.add(tempVector);
      }//end for loop

      //Create a Point2D object that will be the target
      // that will be chased by the other Point2D objects.
      GM01.Point2D target = new GM01.Point2D(
          new GM01.ColMatrix2D(
                          100*(random.nextDouble()-0.5),
                          100*(random.nextDouble()-0.5)));
  
      //Create a Vector2D object that will be used to
      // control the motion of the target.
      GM01.Vector2D targetVec = new GM01.Vector2D(
             new GM01.ColMatrix2D(
               100*(random.nextDouble()-0.5),
               100*(random.nextDouble()-0.5))).scale(0.3);

      //Create a reference point to mark the origin.
      GM01.Point2D zeroPoint = 
              new GM01.Point2D(new GM01.ColMatrix2D(0,0));

      //Declare a variable that will be used to control
      // the update frequency of the target vector.
      int animationLoopCounter = 0;
      
      //This is the animation loop. The value of animate
      // is set to true by the Start button and is set to
      // false by the Stop button. Setting it to false
      // will cause the run method to terminate and stop
      // the animation.
      while(animate){
        animationLoopCounter++;
        
        //Try to keep the points from colliding with one
        // another.  Note, however, that this algorithm
        // is far from perfect in accomplishing that.
        for(int row = 0;row &lt; points.size();row++){
          for(int col = 0;col &lt; points.size();col++){
            GM01.Point2D refPoint = points.get(row);
            GM01.Point2D testPoint = points.get(col);
            
            if(col != row){
              //Get the distance of the testPoint from the
              // refPoint.
              tempVector = testPoint.
                          getDisplacementVector(refPoint);
              
              if(tempVector.getLength() &lt; 25){
                //Modify testPoint to move it away from
                // the refPoint and save the modified
                // point.
                tempVector = tempVector.negate();
                tempPoint = testPoint.addVectorToPoint(
                                   tempVector.scale(0.1));
                points.set(col,tempPoint.clone());
              }else{
                //Do nothing.
              }//end else
            }//end if col != row
          }//end loop on col
        }//end loop on row

        //Move all of the points toward the target but try
        // to keep them separated from the target.
        for(int cnt = 0;cnt &lt; points.size();cnt++){
          //Get the next point.
          tempPoint = points.get(cnt);
          //Find the distance from this point to the
          // target.
          tempVector = 
                  tempPoint.getDisplacementVector(target);
          if(tempVector.getLength() &lt; 10){
            //Modify the point to move it away from the
            // target and save the modified point.
            tempVector = tempVector.negate();
            tempPoint = tempPoint.addVectorToPoint(
                                   tempVector.scale(0.1));
            //Save the modified point.
            points.set(cnt,tempPoint.clone());
          }else{
            //Modify the point to move it toward the
            // target and save the modified point.
            tempPoint = tempPoint.addVectorToPoint(
                                   tempVector.scale(0.1));
            points.set(cnt,tempPoint.clone());
          }//end else
          
          //Save a normalized version of the direction
          // vector for drawing later.
          vectors.set(
                  cnt,tempVector.normalize().scale(15.0));
          
        }//end for loop
        
        //Insert a delay.
        try{
          Thread.currentThread().sleep(166);
        }catch(Exception e){
          e.printStackTrace();
        }//end catch
        
        //Erase the screen
        g2D.setColor(Color.WHITE);
        GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);
        g2D.setColor(Color.BLACK);
        
        //Draw the points and the vectors in the arrayList
        // objects.
        for(int cnt = 0;cnt &lt; numberPoints;cnt++){
          tempPoint = points.get(cnt);
          if(drawPoints){
            tempPoint.draw(g2D);
          }//end if
          
          if(drawVectors){
            tempVector = vectors.get(cnt);
            tempVector.draw(g2D,tempPoint);
          }//end if
        }//end for loop
        
        
        //Cause the targets movements to be slightly less
        // random by using the same vector for several
        // successive movements
        if(animationLoopCounter%10 == 0){
          //Get a new vector
          targetVec = new GM01.Vector2D(
              new GM01.ColMatrix2D
               (100*(random.nextDouble()-0.5),
               100*(random.nextDouble()-0.5))).scale(0.3);
        }//else use the same vector again.
                               
        //Test to see if this displacement vector will
        // push the target outside the limit. If so,
        // modify the vector to send the target back
        // toward the origin.
        if(target.getDisplacementVector(zeroPoint).
                              getLength() &gt; 0.4*osiWidth){
          targetVec = target.getDisplacementVector(
                                    zeroPoint).scale(0.1);

        }//end if
   
        //Modify the location of the target point.
        target = target.addVectorToPoint(targetVec);
        
        //Set the color to RED and draw the target and its
        // vector.
        g2D.setColor(Color.RED);
        target.draw(g2D);
        targetVec.normalize().scale(15.0).draw(
                                              g2D,target);
        
        g2D.setColor(Color.BLACK);
        
        myCanvas.repaint();
      }//end while loop
    }//end run
  }//end inner class named Animate
  //====================================================//

}//end class GUI

</code>









<para id="p1305">
<emphasis id="strong1248" effect="bold">
<emphasis id="Listing_33" effect="bold">

Listing 33

</emphasis>

. Source code for the program named GM01test03.

</emphasis>
</para>





<code id="pre1032" display="block">
/*GM01test03.java 
Copyright 2008, R.G.Baldwin
Revised 02/25/08.

This is a 3D update from the 2D version named GM01test04.
Basically all that was required to perform the update was
to specify 3D classes from the game-math library in place
of the 2D classes used in the 2D version. Virtually 
everything else took care of itself.

The visual behavior of this 3D version is more realistic 
than the 2D version. This is particularly true when the 
target gets in the middle of the pursuers and the display 
is showing both points and vectors. In this 3D version, 
a pursuer is free to swing around in any plane as the 
target passes by whereas in the 2D version, a pursuer is
constrained to swing around only in the plane of the 
screen. That causes the motion to be less fluid. This is
best demonstrated with only one pursuer because that makes
it easy to see the behavior of an individual pursuer.

One thing that I did notice, is that unlike the 2D 
version, the pursuers in this 3D version don't seem to 
have a tendency to form up and fly in formation while 
chasing the target. This may be because they have more 
options in terms of avoiding collisions while giving 
chase, but that is pure speculation since I don't know
why they tend to fly in formation in the 2D version.

This animation program is designed to test many of the 3D
features of the GM01 game-math library.

The animation is generally based on the idea of a 
flocking behavior similar to that exhibited by birds.

A set of Point3D objects is created with random locations.
An additional Point3D object known at the target is also 
created. The target is drawn in red while the pursuers
are drawn in black.

An algorithm is executed that attempts to cause the points
to chase the target without colliding with one another.
Even though the algorithm causes the points to chase the 
target, it also tries to keep the points from colliding 
with the target.

A GUI is provided that contains an input text field for 
the number of points plus a Start button and a Stop
button. The GUI also contains check boxes that allow the 
user to elect to display points only, direction vectors 
only, or both. (Both the point and the direction vector
are always displayed for the target.)

The user specifies the number of randomly-placed points 
and clicks the Start button, at which time the animation
begins and the points start chasing the target.  Target 
motion is random. The animation continues until the user 
clicks the Stop button. The user can click the Stop 
button, change the number of points, and then click Start 
again to re-start the animation with a different number
of points chasing the target.

The animation is most impressive when the direction 
vectors are displayed, with or without points, because the
vectors illustrate the dogged determination and undying 
focus that the pursuers maintain while chasing the target.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.util.*;

class GM01test03{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class GM01test03
//======================================================//

class GUI extends JFrame implements ActionListener{

  int hSize = 400;//horizontal size of JFrame.
  int vSize = 400;//vertical size of JFrame
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas 
  Graphics2D g2D;//off-screen graphics context.
  int numberPoints = 0;//can be modified by the user.
  JTextField numberPointsField; //user input field.
  Random random = new Random();//random number generator

  //The following collection is used to store the points.
  ArrayList &lt;GM01.Point3D&gt; points;
  
  //The following collection is used to store the vectors
  // for display.
  ArrayList &lt;GM01.Vector3D&gt; vectors;
  
  //The following are used to support user input.
  Checkbox drawPointsBox;//User input field
  Checkbox drawVectorsBox;//User input field.
  boolean drawPoints = true;
  boolean drawVectors = true;

  //Animation takes place while the following is true.
  boolean animate = false;
  //----------------------------------------------------//
  
  GUI(){//constructor
  
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
    //Instantiate the user input components.
    numberPointsField =new JTextField("6",5);
    JButton startButton = new JButton("Start");
    JButton stopButton = new JButton("Stop");
    drawPointsBox = new Checkbox("Draw Points",true);
    drawVectorsBox = new Checkbox("Draw Vectors",true);

    //Instantiate a JPanel that will house the user input
    // components and set its layout manager.
    JPanel controlPanel = new JPanel();
    controlPanel.setLayout(new GridLayout(0,2));

    //Add the user input component and appropriate labels
    // to the control panel.
    controlPanel.add(new JLabel(" Number Points"));    
    controlPanel.add(numberPointsField);
    controlPanel.add(drawPointsBox);
    controlPanel.add(drawVectorsBox);
    controlPanel.add(startButton);
    controlPanel.add(stopButton);

    //Add the control panel to the SOUTH position in the
    // JFrame.
    this.getContentPane().add(
                         BorderLayout.SOUTH,controlPanel);

    //Instantiate a new drawing canvas and add it to the
    // CENTER of the JFrame above the control panel.
    myCanvas = new MyCanvas();
    this.getContentPane().add(
                            BorderLayout.CENTER,myCanvas);

    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    
    //Make the size of the off-screen image match the
    // size of the canvas.
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();

    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    g2D = (Graphics2D)(osi.getGraphics());
    
    //Translate the origin to the center.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    
    //Register this object as an action listener on the
    // startButton and the stopButton
    startButton.addActionListener(this);
    stopButton.addActionListener(this);

  }//end constructor
  //----------------------------------------------------//
  
  //This method is called to respond to a click on the
  // startButton or the stopButton.
  public void actionPerformed(ActionEvent e){

    if(e.getActionCommand().equals("Start") &amp;&amp; !animate){
      numberPoints = Integer.parseInt(
                             numberPointsField.getText());

      if(drawPointsBox.getState()){
        drawPoints = true;
      }else{
        drawPoints = false;
      }//end else
      
      if(drawVectorsBox.getState()){
        drawVectors = true;
      }else{
        drawVectors = false;
      }//end else

      animate = true;
      new Animate().start();
    }//end if
    
    if(e.getActionCommand().equals("Stop") &amp;&amp; animate){
      //This will cause the run method to terminate and
      // stop the animation.
      animate = false;
    }//end if

  }//end actionPerformed
  //====================================================//
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the update method to eliminate the default
    // clearing of the Canvas in order to reduce or
    // eliminate the flashing that that is often caused by
    // such default clearing.
    //In this case, it isn't necessary to clear the canvas
    // because the off-screen image is cleared each time
    // it is updated. This method will be called when the
    // JFrame and the Canvas appear on the screen or when
    // the repaint method is called on the Canvas object.
    public void update(Graphics g){
      paint(g);//Call the overridden paint method.
    }//end overridden update()
    
    //Override the paint() method. The purpose of the
    // paint method is to display the off-screen image on
    // the screen. This method is called by the update
    // method above.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()

  }//end inner class MyCanvas
  //====================================================//
  
  //This is an animation thread.
  class Animate extends Thread{
    //Declare a general purpose variable of type Point3D.
    // It will be used for a variety of purposes.
    GM01.Point3D tempPoint;
    
    //Declare a general purpose variable of type Vector3D.
    // It will be used for a variety of purposes.
    GM01.Vector3D tempVector;
    
    public void run(){
      //This method is executed when start is called on
      // this thread.
      //Create a new empty container for the points.
      points = new ArrayList&lt;GM01.Point3D&gt;();
      
      //Create a new empty container for the vectors.
      vectors = new ArrayList&lt;GM01.Vector3D&gt;();
      
      //Create a set of Point objects at random locations
      // and store references to the points in the
      // ArrayList object..
      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        points.add(new GM01.Point3D(
          new GM01.ColMatrix3D(
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5),
                         100*(random.nextDouble()-0.5))));
                         
        //Populate vectors collection with dummy vectors.
        vectors.add(tempVector);
      }//end for loop

      //Create a Point3D object that will be the target
      // that will be chased by the other Point3D objects.
      GM01.Point3D target = new GM01.Point3D(
          new GM01.ColMatrix3D(
                          100*(random.nextDouble()-0.5),
                          100*(random.nextDouble()-0.5),
                          100*(random.nextDouble()-0.5)));
  
      //Create a Vector3D object that will be used to
      // control the motion of the target.
      GM01.Vector3D targetVec = new GM01.Vector3D(
             new GM01.ColMatrix3D(
               100*(random.nextDouble()-0.5),
               100*(random.nextDouble()-0.5),
               100*(random.nextDouble()-0.5))).scale(0.3);

      //Create a reference point to mark the origin.
      GM01.Point3D zeroPoint = 
            new GM01.Point3D(new GM01.ColMatrix3D(0,0,0));

      //Declare a variable that will be used to control
      // the update frequency of the target vector.
      int animationLoopCounter = 0;
      
      //This is the animation loop. The value of animate
      // is set to true by the Start button and is set to
      // false by the Stop button. Setting it to false
      // will cause the run method to terminate and stop
      // the animation.
      while(animate){
        animationLoopCounter++;

        //Try to keep the points from colliding with one
        // another.
        for(int row = 0;row &lt; points.size();row++){
          for(int col = 0;col &lt; points.size();col++){
            GM01.Point3D refPoint = points.get(row);
            GM01.Point3D testPoint = points.get(col);
            
            if(col != row){
              //Get the distance of the testPoint from the
              // refPoint.
              tempVector = testPoint.
                          getDisplacementVector(refPoint);
              
              if(tempVector.getLength() &lt; 25){
                //Modify testPoint to move it away from
                // the refPoint and save the modified
                // point.
                tempVector = tempVector.negate();
                tempPoint = testPoint.addVectorToPoint(
                                   tempVector.scale(0.1));
                points.set(col,tempPoint.clone());
              }else{
                //Do nothing.
              }//end else
            }//end if col != row
          }//end loop on col
        }//end loop on row

        //Move all of the points toward the target but try
        // to keep them separated from the target.
        for(int cnt = 0;cnt &lt; points.size();cnt++){
          //Get the next point.
          tempPoint = points.get(cnt);
          //Find the distance from this point to the
          // target.
          tempVector = 
                  tempPoint.getDisplacementVector(target);
          if(tempVector.getLength() &lt; 10){
            //Modify the point to move it away from the
            // target and save the modified point.
            tempVector = tempVector.negate();
            tempPoint = tempPoint.addVectorToPoint(
                                   tempVector.scale(0.1));
            //Save the modified point.
            points.set(cnt,tempPoint.clone());
          }else{
            //Modify the point to move it toward the
            // target and save the modified point.
            tempPoint = tempPoint.addVectorToPoint(
                                   tempVector.scale(0.2));
            points.set(cnt,tempPoint.clone());
          }//end else
          
          //Save a normalized version of the direction
          // vector for drawing later.
          vectors.set(
                  cnt,tempVector.normalize().scale(15.0));
                  
        }//end for loop
  
        //Insert a delay.
        try{
          Thread.currentThread().sleep(166);
        }catch(Exception e){
          e.printStackTrace();
        }//end catch
        
        //Erase the screen
        g2D.setColor(Color.WHITE);
        GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);
        g2D.setColor(Color.BLACK);
        
        //Draw the points and the vectors in the arrayList
        // objects.
        for(int cnt = 0;cnt &lt; numberPoints;cnt++){
          tempPoint = points.get(cnt);
          if(drawPoints){
            tempPoint.draw(g2D);
          }//end if
          
          if(drawVectors){
            tempVector = vectors.get(cnt);
            tempVector.draw(g2D,tempPoint);
          }//end if
        }//end for loop
        
        //Cause the targets movements to be slightly less
        // random by using the same vector for several
        // successive movements
        if(animationLoopCounter%10 == 0){
          //Get a new vector
          targetVec = new GM01.Vector3D(
              new GM01.ColMatrix3D
               (100*(random.nextDouble()-0.5),
               100*(random.nextDouble()-0.5),
               100*(random.nextDouble()-0.5))).scale(0.3);
        }//else use the same vector again.
                               
        //Test to see if this displacement vector will
        // push the target outside the limit. If so,
        // modify the vector to send the target back
        // toward the origin.
        if(target.getDisplacementVector(zeroPoint).
                              getLength() &gt; 0.4*osiWidth){
          targetVec = target.getDisplacementVector(
                                    zeroPoint).scale(0.1);
        }//end if
   
        //Modify the location of the target point.
        target = target.addVectorToPoint(targetVec);
        
        //Set the color to RED and draw the target and its
        // displacement vector.
        g2D.setColor(Color.RED);
        target.draw(g2D);
        targetVec.normalize().scale(15.0).draw(
                                              g2D,target);

        g2D.setColor(Color.BLACK);
        
        myCanvas.repaint();
      }//end while loop
    }//end run
  }//end inner class named Animate
  //====================================================//

}//end class GUI
</code>






<para id="p1306">
<emphasis id="strong1249" effect="bold">
<emphasis id="Listing_34" effect="bold">

Listing 34

</emphasis>

. Source code for the program named StringArt04.

</emphasis>
</para>





<code id="pre1033" display="block">/*StringArt04.java 
Copyright 2008, R.G.Baldwin
Revised 03/03/08

This program animates the behavior of the earlier program
named StringArt03.  See the comments at the beginning of
that program for a description of both programs. The only
significant difference in the behavior of the two 
programs is that this program slows the rotation process 
down so that the user can see it happening in real time.
Of course, quite a few changes were required to convert
the program from a static program to an animated program.

Tested using JDK 1.6 under WinXP.
*********************************************************/
import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;

class StringArt04{
  public static void main(String[] args){
    GUI guiObj = new GUI();
  }//end main
}//end controlling class StringArt04
//======================================================//

class GUI extends JFrame implements ActionListener{
  //Specify the horizontal and vertical size of a JFrame
  // object.
  int hSize = 300;
  int vSize = 470;
  Image osi;//an off-screen image
  int osiWidth;//off-screen image width
  int osiHeight;//off-screen image height
  MyCanvas myCanvas;//a subclass of Canvas 
  Graphics2D g2D;//off-screen graphics context.

  JTextField numberPointsField;//User input field.
  JTextField loopsField;//User input field.
  int numberPoints = 6;//Can be modified by the user.
  int loopLim = 1;//Can be modified by the user.
  
  JTextField zRotationField;//User input field
  JTextField xRotationField;//User input field
  JTextField yRotationField;//User input field
  double zRotation;//Rotation around z in degrees.
  double xRotation;//Rotation around x in degrees.
  double yRotation;//Rotation around y in degrees
  
  JTextField xAnchorPointField;//User input field
  JTextField yAnchorPointField;//User input field
  JTextField zAnchorPointField;//User input field
  double xAnchorPoint;//Rotation anchor point.
  double yAnchorPoint;//Rotation anchor point.
  double zAnchorPoint;//Rotation anchor point.
  
  GM01.Point3D anchorPoint;
//  boolean animate = false;
  
  //The following variable is used to refer to an array
  // object containing the points that define the
  // vertices of a geometric object.
  GM01.Point3D[] points;
  
  //----------------------------------------------------//
  
  GUI(){//constructor
  
    //Set JFrame size, title, and close operation.
    setSize(hSize,vSize);
    setTitle("Copyright 2008,R.G.Baldwin");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
    //Instantiate the user input components.
    numberPointsField =new JTextField("6");
    loopsField = new JTextField("1");
    zRotationField = new JTextField("0");
    xRotationField = new JTextField("0");
    yRotationField = new JTextField("0");
    xAnchorPointField = new JTextField("0");
    yAnchorPointField = new JTextField("0");
    zAnchorPointField = new JTextField("0");
    JButton button = new JButton("Animate");

    //Instantiate a JPanel that will house the user input
    // components and set its layout manager.
    JPanel controlPanel = new JPanel();
    controlPanel.setLayout(new GridLayout(0,2));

    //Add the user input components and appropriate labels
    // to the control panel.
    controlPanel.add(new JLabel(" Number Points"));    
    controlPanel.add(numberPointsField);
    controlPanel.add(new JLabel(" Number Loops"));
    controlPanel.add(loopsField);
    controlPanel.add(new JLabel(
                               " Rotate around Z (deg)"));
    controlPanel.add(zRotationField);
    controlPanel.add(new JLabel(
                               " Rotate around X (deg)"));
    controlPanel.add(xRotationField);
    controlPanel.add(new JLabel(
                               " Rotate around Y (deg)"));
    controlPanel.add(yRotationField);
    controlPanel.add(new JLabel(" X anchor point"));
    controlPanel.add(xAnchorPointField);
    controlPanel.add(new JLabel(" Y anchor point"));
    controlPanel.add(yAnchorPointField);
    controlPanel.add(new JLabel(" Z anchor point"));
    controlPanel.add(zAnchorPointField);
    controlPanel.add(button);

    //Add the control panel to the SOUTH position in the
    // JFrame.
    this.getContentPane().add(
                         BorderLayout.SOUTH,controlPanel);
    
    //Create a new drawing canvas and add it to the
    // CENTER of the JFrame above the control panel.
    myCanvas = new MyCanvas();
    this.getContentPane().add(
                            BorderLayout.CENTER,myCanvas);

    //This object must be visible before you can get an
    // off-screen image.  It must also be visible before
    // you can compute the size of the canvas.
    setVisible(true);
    
    //Make the size of the off-screen image match the
    // size of the canvas.
    osiWidth = myCanvas.getWidth();
    osiHeight = myCanvas.getHeight();
    
    //Create an off-screen image and get a graphics
    // context on it.
    osi = createImage(osiWidth,osiHeight);
    g2D = (Graphics2D)(osi.getGraphics());
    
    
    //Translate the origin to the center of the off-screen
    // image.
    GM01.translate(g2D,0.5*osiWidth,-0.5*osiHeight);
    
    //Register this object as an action listener on the
    // button.
    button.addActionListener(this);

    //Cause the overridden paint method belonging to
    // myCanvas to be executed.
    myCanvas.repaint();
    
  }//end constructor
  //----------------------------------------------------//
  
  //The purpose of this method is to draw the appropriate
  // material onto the off-screen image.
  void drawOffScreen(Graphics2D g2D){
    //Erase the off-screen image and draw new axes.
    setCoordinateFrame(g2D);

    //The following ColMatrix3D object must be populated
    // with three rotation angles in degrees that
    // specify the following rotational angles in order
    // according to the right-hand rule as applied to 
    // the indicated axis.
    // Rotate around z, in x-y plane
    // Rotate around x, in y-z plane
    // Rotate around y, in x-z plane
    GM01.ColMatrix3D angles = new GM01.ColMatrix3D(
                         zRotation,xRotation,yRotation);
                           
    //The following code causes the anchor point to be
    // drawn and the points in the array to be rotated.
    g2D.setColor(Color.BLACK);
    anchorPoint.draw(g2D);
    for(int cnt = 0;cnt &lt; numberPoints;cnt++){
      points[cnt] = points[cnt].rotate(
                                      anchorPoint,angles);
    }//end for loop
    
    //Implement the algorithm that draws lines connecting
    // points on the geometric object.
    GM01.Line3D line;
    
    //Begin the outer loop.
    for(int loop = 1;loop &lt;= loopLim;loop++){
      //The following variable specifies the array
      // element containing a point on which a line will
      // start.
      int start = -1;
      
      //The following variable specifies the number of
      // points that will be skipped between the starting
      // point and the ending point for a line.
      int skip = loop;
      //The following logic causes the element number to
      // wrap around when it reaches the end of the
      // array.
      while(skip &gt;= 2*numberPoints-1){
        skip -= numberPoints;
      }//end while loop
      
      //The following variable specifies the array
      // element containing a point on which a line will
      // end.
      int end = start + skip;

      //Begin inner loop. This loop actually constructs
      // the GM01.Line3D objects and causes visual
      // manifestations of those objects to be drawn on
      // the off-screen image. Note the requirement to
      // wrap around when the element numbers exceed the
      // length of the array.
      for(int cnt = 0;cnt &lt; numberPoints;cnt++){
        if(start &lt; numberPoints-1){
          start++;
        }else{
          //Wrap around
          start -= (numberPoints-1);
        }//end else
        
        if(end &lt; numberPoints-1){
          end++;
        }else{
          //Wrap around.
          end -= (numberPoints-1);
        }//end else
        
        //Create some interesting colors.
        g2D.setColor(new Color(cnt*255/numberPoints,
                               127+cnt*64/numberPoints,
                               255-cnt*255/numberPoints));
        
        //Create a line that connects points on the
        // geometric object.
        line = new GM01.Line3D(points[start],points[end]);
        line.draw(g2D);
      }//end inner loop
    }//end outer loop
  }//end drawOffScreen
  //----------------------------------------------------//

  //This method is used to draw orthogonal
  // 3D axes on the image that intersect at the origin.
  private void setCoordinateFrame(
                        Graphics2D g2D){
    
    //Erase the screen
    g2D.setColor(Color.WHITE);
    GM01.fillRect(g2D,-osiWidth/2,osiHeight/2,
                                      osiWidth,osiHeight);

    //Draw x-axis in RED
    g2D.setColor(Color.RED);
    GM01.Point3D pointA = new GM01.Point3D(
                   new GM01.ColMatrix3D(-osiWidth/2,0,0));
    GM01.Point3D pointB = new GM01.Point3D(
                    new GM01.ColMatrix3D(osiWidth/2,0,0));
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw y-axis in GREEN
    g2D.setColor(Color.GREEN);
    pointA = new GM01.Point3D(
                  new GM01.ColMatrix3D(0,-osiHeight/2,0));
    pointB = new GM01.Point3D(
                   new GM01.ColMatrix3D(0,osiHeight/2,0));
    new GM01.Line3D(pointA,pointB).draw(g2D);
    
    //Draw z-axis in BLUE. Make its length the same as the
    // length of the x-axis.
    g2D.setColor(Color.BLUE);
    pointA = new GM01.Point3D(
                   new GM01.ColMatrix3D(0,0,-osiWidth/2));
    pointB = new GM01.Point3D(
                    new GM01.ColMatrix3D(0,0,osiWidth/2));
    new GM01.Line3D(pointA,pointB).draw(g2D);

  }//end setCoordinateFrame method
  //----------------------------------------------------//
  
  //This method is called to respond to a click on the
  // button.
  public void actionPerformed(ActionEvent e){
    //Get user input values and use them to modify several
    // values that control the drawing.
    numberPoints = Integer.parseInt(
                             numberPointsField.getText());

    loopLim = Integer.parseInt(loopsField.getText());
    
    //Rotation around z in degrees.
    zRotation = 
             Double.parseDouble(zRotationField.getText());
    //Rotation around x in degrees.
    xRotation = 
             Double.parseDouble(xRotationField.getText());
    //Rotation around y in degrees
    yRotation = 
             Double.parseDouble(yRotationField.getText());

    //Rotation anchor point values.
    xAnchorPoint = 
          Double.parseDouble(xAnchorPointField.getText());
    yAnchorPoint = 
          Double.parseDouble(yAnchorPointField.getText());
    zAnchorPoint = 
          Double.parseDouble(zAnchorPointField.getText());


    //The following object contains the 3D coordinates
    // of the point around which the rotations will
    // take place.
    anchorPoint = new GM01.Point3D(
             new GM01.ColMatrix3D(
               xAnchorPoint,yAnchorPoint,zAnchorPoint));


    //Instantiate a new array object with a length
    // that matches the new value for numberPoints.    
    points = new GM01.Point3D[numberPoints];
    
    //Create a set of Point3D objects that specify
    // locations on the circumference of a circle that
    // is in the x-y plane with a radius of 50 units. Save
    // references to the Point3D objects in the array.
    for(int cnt = 0;cnt &lt; numberPoints;cnt++){
      points[cnt] = new GM01.Point3D(
        new GM01.ColMatrix3D(
          50*Math.cos((cnt*360/numberPoints)*Math.PI/180),
          50*Math.sin((cnt*360/numberPoints)*Math.PI/180),
          0.0));
    }//end for loop that creates the points

    //Spawn an animation thread
    Animate animate = new Animate();
    animate.start();
    
  }//end actionPerformed
  //====================================================//
  
  
  //This is an inner class of the GUI class.
  class MyCanvas extends Canvas{
    //Override the update method to eliminate the default
    // clearing of the Canvas in order to reduce or
    // eliminate the flashing that that is often caused by
    // such default clearing.
    //In this case, it isn't necessary to clear the canvas
    // because the off-screen image is cleared each time
    // it is updated. This method will be called when the
    // JFrame and the Canvas appear on the screen or when
    // the repaint method is called on the Canvas object.
    public void update(Graphics g){
      paint(g);//Call the overridden paint method.
    }//end overridden update()
    
    //Override the paint() method. The purpose of the
    // paint method is to display the off-screen image on
    // the screen. This method is called by the update
    // method above.
    public void paint(Graphics g){
      g.drawImage(osi,0,0,this);
    }//end overridden paint()
  }//end inner class MyCanvas
  //====================================================//
  
  //This is an animation thread.
  class Animate extends Thread{
    public void run(){
      //Compute incremental rotation values.
      int steps = 100;//Number of steps in the animation.
      double zRotationInc = zRotation/steps;
      double xRotationInc = xRotation/steps;
      double yRotationInc = yRotation/steps;
      
      //Do the animated rotation in three distinct stages,
      // rotating around one axis during each stage.
      for(int axis = 0;axis &lt; 3;axis++){
        for(int cnt = 0;cnt &lt; steps;cnt++){
          //Select the axis about which the image will
          // be rotated during this step..
          if(axis % 3 == 0){
            zRotation = zRotationInc;
            xRotation = 0;
            yRotation = 0;
          }else if(axis % 3 == 1){
            zRotation = 0;
            xRotation = xRotationInc;
            yRotation = 0;
          }else if(axis % 3 == 2){
            zRotation = 0;
            xRotation = 0;
            yRotation = yRotationInc;
          }//end else

          //Draw a new off-screen image based on
          // user input values.
          drawOffScreen(g2D);
          //Copy off-screen image to canvas.
          myCanvas.repaint();

          //Sleep for ten milliseconds.
          try{
            Thread.currentThread().sleep(10);
          }catch(InterruptedException ex){
            ex.printStackTrace();
          }//end catch
        }//end for loop
      }//end for loop on axis
    }//end run
  }//end inner class named Animate
  //====================================================//
    
}//end class GUI
</code>








</section>
<section id="h11010">
<title>
<emphasis id="Exercises" effect="bold">

Exercises

</emphasis>


</title>




<section id="h21006">
<title>
<emphasis id="Exercise_1" effect="bold">

Exercise 1

</emphasis>


</title>




<para id="p1307">
Using Java and the game-math library named 

<emphasis id="strong1250" effect="bold">
GM01

</emphasis>
, or using a 
different programming environment of your choice, write a program that   creates 
the wireframe drawing of  half of a sphere protruding
  upward from the x-z plane as shown in 

<link id="a1231" target-id="Figure_11">

Figure 11

</link>

. The 
north and south poles of the sphere lie on the y-axis. The x-z plane intersects
  the sphere at the equator and only the northern
  hemisphere is visible.

</para>




<para id="p1308">
Cause your name to appear in the screen output in some manner.

</para>




<para id="p1309">
<emphasis id="Figure_11" effect="bold">


<emphasis id="strong1251" effect="bold">
Figure 11

</emphasis>
</emphasis>


<emphasis id="strong1252" effect="bold">
 Screen output from Exercise 1.

</emphasis>
</para>




<para id="p1310">
<media id="media1010" alt="Missing image." display="block">
<image id="img1010" mime-type="image/jpeg" src="../../media/0140ex01.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21007">
<title>
<emphasis id="Exercise_2" effect="bold">

Exercise 2

</emphasis>


</title>




<para id="p1311">
Using Java and the game-math library named 

<emphasis id="strong1253" effect="bold">
GM01

</emphasis>
, or using a 
different programming environment of your choice, write a program that demonstrates your ability to animate two or more objects and have them moving around in a 3D world.

</para>




<para id="p1312">
Cause your name to appear in the screen output in some manner.

</para>




</section>
<section id="h21008">
<title>
<emphasis id="Exercise_3" effect="bold">

Exercise 3

</emphasis>


</title>




<para id="p1313">
Beginning with a 3D world similar to the one that you created in


<link id="a1232" target-id="Exercise_2">

Exercise 2

</link>

, demonstrate your ability to cause your 
program to recognize when two of your animated objects collide and to do 
something that can be noticed by a human observer when the collision occurs.

</para>




<para id="p1314">
Cause your name to appear in the screen output in some manner.

</para>




</section>
<section id="h21009">
<title>
<emphasis id="Exercise_4" effect="bold">

Exercise 4

</emphasis>


</title>




<para id="p1315">
Beginning with a program similar to the one that you wrote in


<link id="a1233" target-id="Exercise_1">

Exercise 1

</link>

, create a wireframe drawing of  a complete sphere as shown in


<link id="a1234" target-id="Figure_12">

Figure 12

</link>

. The north and south poles of the sphere lie 
on the y-axis. As before, the x-z plane intersects the 
sphere at the equator, but in this case, the entire sphere is visible.

</para>




<para id="p1316">
<emphasis id="Figure_12" effect="bold">


<emphasis id="strong1254" effect="bold">
Figure 12

</emphasis>
</emphasis>


<emphasis id="strong1255" effect="bold">
 Screen output from Exercise 4.

</emphasis>
</para>




<para id="p1317">
<media id="media1011" alt="Missing image." display="block">
<image id="img1011" mime-type="image/jpeg" src="../../media/0140ex04.jpg" width="451" height="451"/>
</media>


</para>




</section>
<section id="h21010">
<title>
<emphasis id="Exercise_5" effect="bold">

Exercise 5

</emphasis>


</title>




<para id="p1318">
Beginning with a program similar to the one that you wrote in


<link id="a1235" target-id="Exercise_1">

Exercise 1

</link>

, create a wireframe drawing of  one-eighth 
of a sphere as shown in 

<link id="a1236" target-id="Figure_13">

Figure 13

</link>

. The north and south 
poles of the sphere lie on the y-axis. As before, the x-z plane intersects the 
sphere at the equator. In this case, only that portion of the sphere described 
by positive coordinate values is visible.

</para>




<para id="p1319">
Cause your name to appear in the screen output in some manner.

</para>




<para id="p1320">
<emphasis id="Figure_13" effect="bold">


<emphasis id="strong1256" effect="bold">
Figure 13

</emphasis>
</emphasis>


<emphasis id="strong1257" effect="bold">
 Screen output from Exercise 5.

</emphasis>
</para>




<para id="p1321">
<media id="media1012" alt="Missing image." display="block">
<image id="img1012" mime-type="image/jpeg" src="../../media/0140ex05.jpg" width="451" height="451"/>
</media>


</para>


	

<para id="p1322">
-end- 

</para>






</section>
</section>
</content>




</document>